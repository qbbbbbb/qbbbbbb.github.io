<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SystemVerilog_用户自定义和枚举数据类型</title>
    <link href="/2024/05/08/SystemVerilog_%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9E%9A%E4%B8%BE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/05/08/SystemVerilog_%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9E%9A%E4%B8%BE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>参考</li></ul><hr /><h2 id="用户自定义类型">1. 用户自定义类型</h2><ul><li><p>Verilog 并没有提供用户自行扩展 变量和线网 类型的机制。</p></li><li><p>System Verilog 增加了用户定义新变量和线网类型的能力。</p><ul><li><p>System Verilog同C一样，可以使用typedef关键字来建立用户自定义类型。</p></li><li><p>其允许使用现有的数据类型建立新的数据类型；新的数据类型定义后，可以声明这个类型的变量。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">unsigned</span> uint;<br>...<br>uint a,b;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>typedef 命名习惯是使用_t来作为用户自定义类型的结尾。</p></li></ul><h3 id="局部-typedef-声明">1.1 局部 typedef 声明</h3><ul><li><p>用户自定义类型可以在<strong>局部定义</strong>，也可以在<strong>编译单元域</strong>进行外部定义。</p></li><li><p>对于局部的typedef声明，其定义可以在模块内部或设计的接口部分。</p></li><li><p>举例如下，其中nibble自定义类型只能被模块内部看到，其它模块和接口不受其影响。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> alu(...);<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] nibble;<br>    nibble opA,opB;<br>    ...<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="共享typedef定义">1.2 共享typedef定义</h3><ul><li><p>如果用户自定义类型会在很多模型中都被使用，那么typedef可以在包内声明。</p><ul><li><p>可以通过<ahref="https://binbinqian.cn/2024/01/05/%E5%8C%85/">这篇博客</a>中介绍的包的内容引用 方法使用用户自定义类型。</p></li><li><p>举例如下</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">package</span> chip_types;<br><span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> TWO_STATE </span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">bit</span> dtype_t; <br>    <span class="hljs-meta">`<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">logic</span> dtype_t; <br>    <span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">endpackage</span> <br><br><span class="hljs-keyword">module</span> counter<br>    (<span class="hljs-keyword">output</span> chip_types::dtype_t[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] count,<br>     <span class="hljs-keyword">input</span> chip_type::dtype_t clock,resetN); <br>    <br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clock,<span class="hljs-keyword">negedge</span> resetN) <br>        <span class="hljs-keyword">if</span>(! resetN)count&lt;=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        count&lt;=count+<span class="hljs-number">1</span>; <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>typedef也可以在编译单元域中声明，这样模块在每次使用时，不需要再引用包名。</p><ul><li><p>举例如下</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">package</span> chip_types;<br><span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> TWO_STATE</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">bit</span> dtype_t;<br><span class="hljs-meta">`<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">logic</span> dtype_t;<br><span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">endpackage</span><br><br><span class="hljs-keyword">import</span> chip_types::dtype_t;<span class="hljs-comment">//导入定义到$unit</span><br><br><span class="hljs-keyword">module</span> counter<br>    (<span class="hljs-keyword">output</span> dtype_t[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]count,<br>     <span class="hljs-keyword">input</span> dtype_t clock,resetN);<br><br>    <span class="hljs-keyword">always</span>(<span class="hljs-keyword">posedge</span> clock, <span class="hljs-keyword">negedge</span> resetN)<br>        <span class="hljs-keyword">if</span>(!resetN) count&lt;=<span class="hljs-number">0</span>;<br>e1se count&lt;=count+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="枚举数据类型">2. 枚举数据类型</h2><ul><li><p>在Verilog中，没有枚举类型。为了给数值创建一个标签，需要使用parameter/`define 来表示每个值。</p><ul><li>以状态机为例，常用parameter表示几个状态值；同时需要声明变量来使用这些常数值。<ul><li>如声明 reg [3:0]state，但是并没有什么办法来限制state的值一定在声明的几个常数中。</li><li>虽然可以添加"full case"编译指令来通知综合工具，让状态变量只使用case列表中的常数值。但编译指令不影响仿真，会导致仿真与综合结果不相同。</li></ul></li></ul></li><li><p>在System Verilog中，增加了枚举数据类型声明，使用enum关键字。</p></li></ul><p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">enum</span> &#123;WAITE,LOAD,STORE&#125;State,NextState;<br></code></pre></td></tr></table></figure></p><ul><li><p>枚举类型会限制数值的合法集合，不会出现和Verilog一样超出列表常数值的情况。</p></li><li><p>如果是从包中导入枚举类型，如果只导入枚举类型定义名，并不会自动导入枚举值标签，在使用时就可能会出现错误。</p><ul><li><p>举例如下</p><figure><imgsrc="./SystemVerilog_用户自定义和枚举数据类型.assets/image-20240508121556726.png"alt="image-20240508121556726" /><figcaption aria-hidden="true">image-20240508121556726</figcaption></figure></li><li><p>需要显式的导入每个标签，或者使用通配符导入整个包。</p></li></ul></li><li><p>枚举类型 标签序列</p><ul><li>state：单个标签</li><li>state[N]：标签序列，state0...stateN</li><li>state[N:M]：标签序列，stateN...stateM</li></ul></li><li><p>枚举类型列表中的标签在其作用域内必须是唯一的。</p><ul><li><p>不可以在同一个作用域内两个枚举类型列表中都包含相同的标签，如下所示。</p><figure><imgsrc="./SystemVerilog_用户自定义和枚举数据类型.assets/image-20240508165342911.png"alt="image-20240508165342911" /><figcaption aria-hidden="true">image-20240508165342911</figcaption></figure></li><li><p>可以包含枚举类型声明的作用域包括：</p><ul><li>编译单元、模块、任务、函数。</li><li>接口、程序、begin...end、fork...join块。</li></ul></li><li><p>上面代码的错误可以将相同标签置于不同作用域中来修正，如下图所示。</p><figure><imgsrc="./SystemVerilog_用户自定义和枚举数据类型.assets/image-20240508165427769.png"alt="image-20240508165427769" /><figcaption aria-hidden="true">image-20240508165427769</figcaption></figure></li></ul></li><li><p>枚举类型的基类</p><ul><li><p>枚举类型的默认基类是int，其是32bit两态类型。</p></li><li><p>同样也支持显式声明，如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">bit</span> &#123;TRUE,FALSE&#125; Boolean;<br><span class="hljs-keyword">enum</span> <span class="hljs-keyword">logic</span>[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] &#123;WAIT,LOAD,READY&#125; state;<br></code></pre></td></tr></table></figure></li><li><p>在枚举类型声明时，可以同时进行初始化，但初始化值应与显式声明位宽相匹配。</p></li></ul></li><li><p>枚举类型操作的强类型检验</p><ul><li><p>声明的枚举类型变量只可以进行以下赋值：</p><ul><li>枚举类型列表中的一个标签</li><li>同类枚举类型的其它变量</li><li>通过cast转换成枚举类型变量的数值</li></ul></li><li><p>举例如下</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;WAIT,LOAD,READY&#125; states_t;<br>states_t state,next_state;<br><span class="hljs-keyword">int</span> foo;<br><br>(<span class="hljs-number">1</span>) state = next_state; <span class="hljs-comment">//合法</span><br>(<span class="hljs-number">2</span>) foo = state+<span class="hljs-number">1</span>; <span class="hljs-comment">//合法</span><br>(<span class="hljs-number">3</span>) state = foo+<span class="hljs-number">1</span>;  <span class="hljs-comment">//非法赋值，因为不是同一个枚举类型</span><br>(<span class="hljs-number">4</span>) next_state = state+<span class="hljs-number">1</span>;  <span class="hljs-comment">//非法赋值，state+1得到的结果是int类型，int类型赋值给枚举类型。</span><br>(<span class="hljs-number">5</span>) state++; <span class="hljs-comment">//非法赋值</span><br>(<span class="hljs-number">6</span>) next_state+= state;  <span class="hljs-comment">//非法赋值</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>表达式强制转换为枚举类型</p><ul><li><p>前面介绍的第(4)种情况，可以使用强制转换操作符或者动态$cast()系统函数。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">next_state = state_t(state+<span class="hljs-number">1</span>);  <span class="hljs-comment">//合法</span><br><span class="hljs-built_in">$cast</span>(next_state,state+<span class="hljs-number">1</span>);  <span class="hljs-comment">//合法</span><br></code></pre></td></tr></table></figure><ul><li>其中强制转换符不会检查转换表达式结果是否是合法值。但$cast()会对其进行检查，具体可见<ahref="">这篇博客</a></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>System Verilog</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SystemVerilog_数据类型</title>
    <link href="/2024/05/05/SystemVerilog_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/05/05/SystemVerilog_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://www.cnblogs.com/Alfred-HOO/articles/17436702.html"class="uri">https://www.cnblogs.com/Alfred-HOO/articles/17436702.html</a></li><li><ahref="https://blog.csdn.net/weixin_41969690/article/details/108006834"class="uri">https://blog.csdn.net/weixin_41969690/article/details/108006834</a></li></ul></li></ul><hr /><h2 id="增强的-文本值赋值">1. 增强的 文本值赋值</h2><ul><li><p>在Verilog中，可以很轻松的为变量赋值0、X、Z，但是很难实现直接为每1bit赋值为1.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//例如在verilog 中，可以通过以下三种方式，为每1bit赋值为1.</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] data;<br><span class="hljs-keyword">assign</span> data = <span class="hljs-number">64&#x27;hFFFF_FFFF_FFFF_FFFF</span>;<br><span class="hljs-keyword">assign</span> data = ~<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> data = -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>SystemVerilog 增强了文本值赋值功能，举例如下。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> data = <span class="hljs-number">&#x27;b1</span>;  <span class="hljs-comment">//将data所有的bit位都设置为1</span><br><span class="hljs-comment">// 与此相同的有</span><br><span class="hljs-number">&#x27;b0</span>/<span class="hljs-number">&#x27;bx</span>/<span class="hljs-number">&#x27;bz</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="define-增强">2. `define 增强</h2><h3 id="字符串内的宏变量替换">2.1 字符串内的宏变量替换</h3><ul><li><p>在Verilog中，`define 宏中可以使用双引号 ”“，但是双引号内的文本就变成了字符串，没有意义。</p><ul><li><p>举例如下，其中%h并不会被换成data的值，%h仅作为一个字符串。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">define</span> print(v)\</span><br><span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;variable v=%h&quot;</span>,v);<br><br>`print(data);<br></code></pre></td></tr></table></figure><ul><li>注意，对于多行宏，需要在行后添加，如果没有该，则认为该行为宏中最后一行</li></ul></li></ul></li><li><p>SystemVerilog可以进行宏文本字符串中的变量替换，需要在双引号前添加 `，这样字符串内的%h会被正确解释为格式变量。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">define</span> print(v)\</span><br><span class="hljs-built_in">$display</span>(`<span class="hljs-string">&quot;variable v=%h`&quot;</span>,v)<br><br>`print(data);<br></code></pre></td></tr></table></figure><ul><li><p>如果字符串中有需要加”“的，Verilog中会使用转义符：，如下。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;variable \&quot;v\&quot;=%h&quot;</span>,v);  <span class="hljs-comment">//打印出：variable &quot;v&quot; = 5</span><br></code></pre></td></tr></table></figure><ul><li><p>那么在System Verilog 的宏文本字符串变量替换中，需要更改如下。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">define</span> print(v)\</span><br><span class="hljs-built_in">$display</span>(`<span class="hljs-string">&quot;variable `\`&quot;</span>v`\`<span class="hljs-string">&quot;=%h`&quot;</span>,v)<br><br>`print(data);<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="通过宏建立标识符名">2.2 通过宏建立标识符名</h3><ul><li><p>在Verilog中，不可能通过连接两个或多个文本宏来建立一个新的标识符。</p></li><li><p>System Verilog中可以使用两个连续的`来将多个文本宏连接在一起，形成一个新的名字。</p></li><li><p>举例如下。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//(1)</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> append_front_2a(MOD) `&quot;MOD.master`&quot;</span><br><span class="hljs-built_in">$display</span>(`append_front_2a(clock2a));<br><span class="hljs-comment">//clock2a.master</span><br><span class="hljs-comment">//(2)</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> append_front_2b(MOD) `&quot;MOD master`&quot;</span><br><span class="hljs-built_in">$display</span>(`append_front_2b(clock2b));<br><span class="hljs-comment">//clock2b master</span><br><span class="hljs-comment">//(3)</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> append_front_2c_bad(MOD) `&quot;MOD_master`&quot;</span><br><span class="hljs-built_in">$display</span>(`append_front_2c_bad(clock2c));<br><span class="hljs-comment">//MOD_master</span><br><span class="hljs-comment">//(4)</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> append_front_2c_good(MOD) `&quot;MOD``_master`&quot;</span><br><span class="hljs-built_in">$display</span>(`append_front_2c_good(clock2c));<br><span class="hljs-comment">//clock2c_master</span><br><span class="hljs-comment">//(5)</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> append_front_3(MOD) `&quot;MOD``.master`&quot;</span><br><span class="hljs-built_in">$display</span>(`append_front_3(clock3));<br><span class="hljs-comment">//clock3.master</span><br><span class="hljs-comment">//(6)</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> append_middle(MOD) `&quot;top_``MOD``_master`&quot;</span><br><span class="hljs-built_in">$display</span>(`append_middle(clock4));<br><span class="hljs-comment">//top_clock4_master</span><br><span class="hljs-comment">//(7)</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> append_end(MOD) `&quot;top_``MOD`&quot;</span><br><span class="hljs-built_in">$display</span>(`append_end(clock5));<br><span class="hljs-comment">//top_clock5</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="systemverilog-变量">3. SystemVerilog 变量</h2><h3 id="systemverilog-数据类型">3.1 SystemVerilog 数据类型</h3><ul><li>Verilog 数据类型主要有变量类型和线网类型。<ul><li>变量类型：reg、integer、time变量，每一位都有四种逻辑：0、1、x、z.</li><li>线网类型：wire、wor、wand等。</li></ul></li><li>SystemVerilog 数据类型<ul><li>变量类型，其使用所有Verilog变量类型，同时还增加了一些其它变量类型，如：<strong>byte和int</strong>。</li><li>线网类型：相较于Verilog的线网类型，没有任何扩展。</li></ul></li><li>SystemVerilog-2005标准中，变量类型可以是两态的，也可以是四态的。而<strong>线网只能是四态的。</strong></li></ul><h3 id="systemverilog-四态变量">3.2 SystemVerilog 四态变量</h3><ul><li><p>logic 与 reg/wire</p><ul><li><p>logic除了作为一个变量以外，还可以被连续赋值、门单元和模块所驱动。</p></li><li><p>logic类型只能有一个驱动，在单驱动情况下，可以替换掉reg/wire。对于多驱动，如双向端口，需要使用wire来定义。</p></li><li><p>另外，在wire定义时赋值是连续赋值；而在logic定义时赋值是赋初值，且赋初值是不能综合的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> mysignal0 = A &amp; B;     <span class="hljs-comment">// continuous assignment, AND gate</span><br><span class="hljs-keyword">logic</span> mysignal1 = A &amp; B;    <span class="hljs-comment">// not synthesizable, initializes mysignal1 to the value of A &amp; B at time 0 and then makes no further changes to it.</span><br><span class="hljs-keyword">logic</span> mysignal2;<br><span class="hljs-keyword">assign</span> mysignal2 = A &amp; B;   <span class="hljs-comment">// Continuous assignment, AND gate</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>关键字logic并不是变量类型，其是一种数据类型，表示信号具有四态值。</p><ul><li><p>Verilog线网类型缺省为四态logic数据类型，也可以用logic关键字来显示声明。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] addr;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>当logic关键字单独使用时，则暗示这是一个变量，相当于：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">var</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] addr;<br></code></pre></td></tr></table></figure></li></ul><h3 id="systemverilog-两态变量">3.3 SystemVerilog 两态变量</h3><ul><li><p>SystemVerilog 新增了几个<strong>两态变量</strong>，包括：</p><ul><li>bit：1bit整数。</li><li>byte：8bit整数。</li><li>shortint：16bit整数。</li><li>int：32bit整数。</li><li>longint：64bit整数。</li></ul></li><li><p>在可综合的RTL硬件模型中，更愿意用四态类型。</p><ul><li>Z态用于表示未连接或三态逻辑。</li><li>X态用于检测设计错误。</li><li>而在更高级的建模中，几乎用不到X和Z态，因此可用两态变量。</li></ul></li><li><p>SystemVerilog中允许变量声明为bit数据类型。</p><ul><li><p>关键字bit与logic一样，并不是变量类型，是一种数据类型，区别在于其是两态值。</p></li><li><p>当bit关键字单独使用时，则暗示这是一个变量，相当于：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">var</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] addr;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用类似C语言的变量类型</p><ul><li><p>如 int 和byte，在使用DPI（直接编程接口）：Verilog模型到C/C++接口，使用两种语言表示方法相同的数据类型，便于数据交互。</p></li><li><p>int 还可用作for循环中的控制变量。</p><ul><li>在可综合的RTL模型中，循环控制变量只是一个临时变量，不需要四态值，因此无论是抽象模型还是可综合的RTL模型中，都可以使用int作为for循环的控制变量。</li></ul></li></ul></li><li><p>仿真初始值</p><ul><li>四态变量<ul><li>仿真器认为变量所有bit均为逻辑X，直到赋值给变量（如复位逻辑），数据才会有值。</li><li>四态变量也可以通过<strong>内嵌初始化定义</strong>开始仿真的值，但这是<strong>不可综合</strong>的。</li></ul></li><li>两态变量<ul><li>仿真器认为数据是从逻辑0开始的。</li><li>由于两态变量不存储X态，因此他们不能描述未初始化状态。</li></ul></li></ul></li><li><p>给一个两态变量赋值四态变量是合法的，X态和Z态都会转化成逻辑0.</p></li><li><p>其它抽象类型</p><ul><li>SystemVerilog增加了void类型表示无存储，可用于标签联合体以及用于定义无返回值的函数。</li><li>SystemVerilog还定义了与Verilog中real类似的shortreal，其中real是64bit的双精度浮点数，而shortreal是32bit的单精度浮点数。</li></ul></li></ul><h3 id="显示及隐式-变量和线网类型">3.4 显示及隐式 变量和线网类型</h3><ul><li><p>当四态或两态数据类型没有显式指定数据类型是变量还是线网类型时，会推断其为隐式变量。</p></li><li><p>SystemVerilog允许在任何数据前使用var关键字，显式表示对象是一个变量。</p><ul><li><p>var关键字并不影响变量的仿真和综合行为。</p></li><li><p>该显示描述方式可以用在用户自定义类型的变量上。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">bit</span> &#123;FALSE, TRUE&#125; bool_t;<br><span class="hljs-keyword">var</span> bool_t c;<br></code></pre></td></tr></table></figure></li><li><p>还可以直接使用var关键字声明变量，不指定数据类型，此时默认变量为logic数据类型。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">var</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>所有的Verilog线网类型都是四态逻辑数据类型。</p><ul><li><p>线网可以使用线网类型和logic数据类型进行声明。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] busB;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="有符号和无符号修饰符">3.5 有符号和无符号修饰符</h3><ul><li><p>IEEE Verilog-2001中允许将任何数据类型声明为有符号数，缺省数据类型为无符号数。</p></li><li><p>System Verilog增加了缺省为有符号数的数据类型。</p><ul><li><p>包括<strong>byte、shortint、int、longint</strong>。</p></li><li><p>需要使用关键字unsigned来将这些数据定义为无符号。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">int</span> s_int;  <span class="hljs-comment">//有符号32位变量</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">unsigned</span> u_int;  <span class="hljs-comment">//无符号32位变量</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>System Verilog 中的符号声明与C语言不同。</p><ul><li><p>C语言中，signed/unsigned关键字可以在数据类型关键字前面/后面指定。</p></li><li><p>Verilog中，signed关键字只能在数据类型后面声明（没有unsigned关键字）。</p></li><li><p>System Verilog中，只允许在数据类型后面声明关键字signed或unsigned。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//合法的C语言声明</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> u1;<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">unsigned</span> u2;<br>/Verilog 声明<br><span class="hljs-keyword">reg</span> <span class="hljs-keyword">signed</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] s;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="静态和自动变量">4. 静态和自动变量</h2><h3 id="动态变量">4.1 动态变量</h3><ul><li><p>可以定义一个任务或函数中的变量是动态的，即变量的存储区在需要时由软件工具动态地分配，在不需要的时候被释放。</p></li><li><p>其主要用作测试程序、抽象系统级、总线功能模型中的验证程序。举例如下：</p><ul><li><p>测试函数被设置为动态函数，这样可以在任务上一个调用还在运行时，再调用该任务。</p></li><li><p>其中用于统计错误次数的变量error_count被设置为静态函数。</p><ul><li>如果error_count设置为动态变量，那么每次调用都会被重新创建，无法保存之前统计的值。</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-keyword">packed</span> &#123;...&#125; packet_t;<br><span class="hljs-keyword">task</span> <span class="hljs-keyword">automatic</span> check_results<br>    (<span class="hljs-keyword">input</span> packet_t sent,recieved);<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">int</span> total_errors);<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> error_count;<br>    ...<br>    <span class="hljs-keyword">if</span>(sent!==recieved)error_count++;<br>    total errors=error_count;<br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>自动变量也允许编写递归函数（函数调用其自身）。</p><ul><li><p>含有自动变量的任务或函数，每次调用，都会建立新的变量存储空间，当访问结束后，空间会被释放掉。</p></li><li><p>举例如下，其中变量lo和hi，以及函数内部变量mid都是动态变量，因此每次递归调用都会分配新的变量。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">automatic</span> <span class="hljs-keyword">int</span> b_add(<span class="hljs-keyword">int</span> lo,hi);<br>    <span class="hljs-keyword">int</span> mid = (lo+hi+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(lo+<span class="hljs-number">1</span>!=hi)<br>        <span class="hljs-keyword">return</span> (b_add(lo,(mid-<span class="hljs-number">1</span>))+b_add(mid,hi));<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> (array[lo] + array[hi]);<br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>在Verilog中，通过声明整个任务/函数是动态的，来表明内部变量是动态的。</p></li><li><p>在System Verilog中，增加了声明静态变量和动态变量的能力。</p><ul><li>可以通过static和automatic分别声明变量为静态和动态。</li><li>注意静态/动态显式声明需要在任务/函数/begin...end块/fork...join块中。</li><li>不能出现在module的一级声明中，在模块级，所有的变量都是静态的。</li></ul></li><li><p>在System Verilog中，在未显式声明动态 函数/任务情况下，所有的存储方式都缺省为静态的。</p><ul><li>如果在显式声明动态函数/任务下，所有变量默认为动态的，除非使用关键字static显示声明。</li></ul></li></ul><h3 id="静态变量和自动变量的初始化">4.2 静态变量和自动变量的初始化</h3><ul><li>Verilog 只允许在模块module级，对变量进行初始化。<ul><li>不允许在任务/函数/begin...end/fork...join中声明变量不可以进行初始化。</li></ul></li><li>可重入函数 &amp; 不可重入函数<ul><li>可重入函数是指能够被多个线程“同时”调用的函数，并且能保证函数结果正确不必担心数据错误的函数.</li><li>不可重入函数是指不能运行在多任务环境下，除非能保证互斥的函数。</li></ul></li></ul><h4 id="system-verilog初始化">4.2.1 System Verilog初始化</h4><ul><li><p>对Verilog进行扩展，在任务、函数中也可以内嵌初始值。</p></li><li><p>在非动态任务和函数中声明的变量默认是静态的。</p><ul><li>初始值会在仿真开始时进行一次赋值，之后对任务/函数的再次调用不会重新初始化变量。</li><li><strong>在任务/函数中初始化静态变量是不可综合的</strong>。</li></ul></li><li><p>静态变量初始化规则：举例如下</p><ul><li><p>当函数第一次被调用时，变量count的初始值为0，在下次调用时，不会再进行初始化。</p></li><li><p>变量temp在函数第一次调用时，初始值被设置为0，而不是data的值。</p><ul><li>因为初始化是发生在仿真开始前，而不是函数调用时。</li></ul><figure><img src="image-20240507160551866.png" alt="image-20240507160551866" /><figcaption aria-hidden="true">image-20240507160551866</figcaption></figure></li></ul></li><li><p>动态变量初始化规则</p><ul><li>任务和函数中的动态变量，每次任务和函数调用时都会被动态创建，调用完毕会被动态的释放。</li><li>如果将上面代码中的count和temp声明为动态变量，那么在每次函数被调用时，都会进行一次初始化。</li></ul></li><li><p>动态变量<strong>是可以综合</strong>的，但需要动态变量只用于暂时存储，<strong>不会传送到任务/函数/过程块的外部</strong>。</p></li></ul><h4 id="静态和动态变量的使用原则">4.2.2 静态和动态变量的使用原则</h4><ul><li>在always和initial块中，如果没有需要初始化的可以使用静态变量；如果需要初始化，则可以使用动态变量。</li><li>如果一个任务/函数是用来描述独立的硬件电路，并且是<strong>不可重入</strong>的，那么应该将它声明为静态的，其内部变量也应该是静态的。</li><li>如果一个任务/函数是可重入的，那么应该设置为动态的，其内部变量也应该是动态的。<ul><li>除非有特殊需求，需要在两次调用之间保持变量的值。</li></ul></li></ul><h3 id="变量初始化的确定性">4.3 变量初始化的确定性</h3><h4 id="初始化确定机制">4.3.1 初始化确定机制</h4><ul><li><p>在Verilog-2001标准中，允许在变量声明时直接对其进行初始化。</p><ul><li><p>但在标准中指出，变量的初始化与在仿真0时刻执行的initial块和always块中的初始化顺序一样，都是不确定的。</p></li><li><p>举例如下：i和j谁先被赋值是不确定的，因此j可能是X态。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">integer</span> i=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">integer</span> j;<br><span class="hljs-keyword">initial</span> j=i;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在SystemVerilog中，规定了所有变量初始化优先于仿真时刻0执行的事件。</p><ul><li><p>举例如下</p><figure><img src="image-20240507165819628.png" alt="image-20240507165819628" /><figcaption aria-hidden="true">image-20240507165819628</figcaption></figure><ul><li>对于Verilog，可能发送两种情况：<ul><li>（1）在初始化resetN之前，先激活了always块，仍然在仿真0时刻，初始化resetN，因此resetN存在一个X到0的跳变。always块采样到该跳变，于是执行了count的初始化。</li><li>（2）在激活了always块之前，首先对resetN进行初始化，仍在仿真0时刻，激活always块，但无法采样到negedgeresetN，需要等待下一个clk的上升沿或下一个resetN的negedge。</li></ul></li><li>对于System Verilog，消除了不确定性，保证只有上面的（2）会发生。</li></ul></li></ul></li></ul><h4 id="时序逻辑的异步输入初始化">4.3.2 时序逻辑的异步输入初始化</h4><ul><li><p>在tb编写测试激励时，可能出现下面情况：</p><p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">bit</span> resetN = <span class="hljs-number">1</span>;  <span class="hljs-comment">//resetN是异步复位检测 negedge resetN</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    resetN = <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">2</span> resetN = <span class="hljs-number">1</span>; <br><span class="hljs-keyword">end</span>    <br></code></pre></td></tr></table></figure></p><ul><li>由于resetN为bit数据类型，因此若没有初始化为1，其在仿真开始时会被初始化为0.</li><li>对于Verilog，可能出现以下两种情况<ul><li>（1）initial块先于变量初始化，即resetN 先0后1，不符合测试要求。</li><li>（2）变量初始化先于initial块，即resetN 先1后0，符合测试要求。</li></ul></li><li>对于System Verilog，必定是情况（2）。</li></ul></li></ul><h3 id="强制类型转换">4.4 强制类型转换</h3><ul><li>SystemVerilog加入了强制数据类型转换，其主要包括静态转换和动态转换。</li></ul><h4 id="静态转换编译时转换">4.4.1 静态转换（编译时转换）</h4><ul><li>其格式为：<code>&lt;type&gt;'(&lt;expression&gt;)</code>，将一个值强制转换为任何数据类型，包括用户自定义类型。<ul><li><p>举例如下:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-number">7</span>+<span class="hljs-keyword">int</span>&#x27;(<span class="hljs-number">2</span><span class="hljs-variable">.0</span>*<span class="hljs-number">3</span><span class="hljs-variable">.0</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li>可以将值强制转换为任意向量长度，格式为：<code>&lt;size&gt;'(&lt;expression&gt;)</code><ul><li><p>举例如下，将文本值2转为16bit位宽。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">y=a+b**<span class="hljs-number">16</span>&#x27;(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li>可以将值强制转换为有符号/无符号数，其格式为：<code>&lt;signed/unsigned&gt;'(&lt;expression&gt;)</code><ul><li><p>举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">y=y-<span class="hljs-keyword">signed</span>&#x27;(&#123;a,b&#125;);<br></code></pre></td></tr></table></figure></li></ul></li><li>因为静态转换是在编译时进行的转换，总是会进行的。但<strong>不会检查</strong>要转换的表达式是否在转换后是合法的，因此在转换前需要确定。</li></ul><h4 id="动态强制类型转换">4.4.2 动态强制类型转换</h4><ul><li><p>SystemVerilog提供一个新的系统函数<code>$cast</code>，是动态的，在运行时会检查转换值的正确性。</p></li><li><p>$cast包含两个<strong>变量</strong>，目标<strong>变量</strong>和源<strong>变量</strong>。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-built_in">$cast</span>(dest_var,source_exp);<br></code></pre></td></tr></table></figure></li><li><p>$cast将源变量转化为目标变量数据类型，如果赋值是无效的（非法的），将会报告出错误，并且源变量保持不变。</p><ul><li><p>以下几种情况都会导致无效的强制类型转换。</p><ul><li>real 转 int。</li><li>将数值转为枚举类型，但转化后不在枚举合法值列表中。</li></ul></li><li><p>如果转换成功，$cast会返回1，如果转换不成功，会返回0.举例如下。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">status=<span class="hljs-built_in">$cast</span>(next_state,state+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(status == <span class="hljs-number">0</span>) next_state = s1;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>$cast不可以和直接修改源表达式的操作符一起使用。如：++/+=。</p></li><li><p>静态转换是可综合的，但动态$cast系统函数是不可综合的。</p><ul><li>一般来说，系统任务和系统函数不是一种可综合的结构。</li></ul></li></ul><h2 id="常数">5. 常数</h2><ul><li><p>在Verilog中，提供三种类型的常数：</p><ul><li>parameter：可以使用defparam以及例化参数传递进行重定义。</li><li>specparam：不可以赋值给parameter，不能通过参数传递进行修改；唯一的修改方式是通过SDF反标修改。</li><li>localparam：不可以重定义，但是他可以基于其它常数，进行修改。</li></ul></li><li><p>Verilog限制三个常数只能在模块、静态任务和静态函数中声明，在动态函数/任务以及always块、initial块中声明是违法的。</p></li><li><p>SystemVerilog新增了将任何变量声明为常数的能力，使用const关键字。</p><ul><li><p>const常数声明必须包含数据类型。</p></li><li><p>const主要为了保证值不被错误的代码改变。</p></li><li><p>const可以在动态任务和函数中声明。也可以在模块级、静态任务和函数中声明。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">const</span> <span class="hljs-keyword">real</span> C1 = <span class="hljs-number">3</span><span class="hljs-variable">.14</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>System Verilog</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIPI-CSI-5</title>
    <link href="/2024/05/04/MIPI-CSI-5/"/>
    <url>/2024/05/04/MIPI-CSI-5/</url>
    
    <content type="html"><![CDATA[<ul><li>本节主要介绍 CSI-2 的实现案例</li></ul><hr><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li><p>假设物理层为D-PHY，实现框图如下图所示。</p><p><img src="/2024/05/04/MIPI-CSI-5/image-20240504123518115.png" alt="image-20240504123518115"></p></li><li><p>实现案例没有展示错误恢复机制和错误处理细节相关内容，主要从数据流向进行介绍。</p></li><li><p>实现案例中传输的数据为RAW8格式，其不需要完成Pixel 和 Byte 转换的打包和解包过程。</p></li></ul><h2 id="2-CSI-2-Transmitter-Detailed-Block-Diagram"><a href="#2-CSI-2-Transmitter-Detailed-Block-Diagram" class="headerlink" title="2. CSI-2 Transmitter Detailed Block Diagram"></a>2. CSI-2 Transmitter Detailed Block Diagram</h2><ul><li><p>其框图如下图所示。</p><ul><li><p>主要包括三部分：（1）协议层（2）Lane 分发层 （3）D-PHY 物理层</p><p><img src="/2024/05/04/MIPI-CSI-5/image-20240504130436223.png" alt="image-20240504130436223"></p></li></ul></li></ul><h2 id="3-CSI-2-Receiver-Detailed-Block-Diagram"><a href="#3-CSI-2-Receiver-Detailed-Block-Diagram" class="headerlink" title="3. CSI-2 Receiver Detailed Block Diagram"></a>3. CSI-2 Receiver Detailed Block Diagram</h2><ul><li><p>其框图如下图所示。</p><ul><li><p>同样包括三部分：（1）协议层（2）Lane 合并层 （3）D-PHY 物理层</p><p><img src="/2024/05/04/MIPI-CSI-5/image-20240504130740594.png" alt="image-20240504130740594"></p></li></ul></li></ul><h2 id="4-D-PHY-物理层-实现细节"><a href="#4-D-PHY-物理层-实现细节" class="headerlink" title="4. D-PHY 物理层 实现细节"></a>4. D-PHY 物理层 实现细节</h2><ul><li><p>D-PHY接口如下图所示。</p><p><img src="/2024/05/04/MIPI-CSI-5/image-20240504131006134.png" alt="image-20240504131006134"></p><ul><li>图中左侧为CSI-2 发送端输出，从上至下分别为 Clock Lane、Data1 Lane、Data2 Lane。</li><li>图中右侧为CSI-2 接收端输出，从上至下分别为 Clock Lane、Data1 Lane、Data2 Lane。</li></ul></li></ul><h3 id="4-1-CSI-2-Clock-Lane-Transmitter"><a href="#4-1-CSI-2-Clock-Lane-Transmitter" class="headerlink" title="4.1 CSI-2 Clock Lane Transmitter"></a>4.1 CSI-2 Clock Lane Transmitter</h3><ul><li><p>其框架如下图所示。</p><p><img src="/2024/05/04/MIPI-CSI-5/image-20240504133151332.png" alt="image-20240504133151332"></p></li><li><p>图中主要包含三部分</p><ul><li>LP-TX，用于低功耗功能（Low-power function）。</li><li>HS-TX，用于高速功能（High-speed function）。</li><li>CIL-MCNN，用于Lane控制和接口逻辑。</li></ul></li><li><p>与LLP Layer的PPI接口有：</p><ul><li>TxDDRClkHS-Q（Input）：高速传输DDR时钟（Quadrature）信号。</li><li>TxRequestHS（Input）：高速传输Request信号。此信号高有效，用来让Lane模块开始传输HS时钟。</li><li>TxReadyHS（Output）：高速传输Ready信号。此信号高有效，用来指示时钟Lane在传输HS时钟。</li><li>Shutdown（Input）：关闭Lane模块。此信号高有效，用来强制Lane模块进入“shutdown”，禁用所有活动。<ul><li>当Shutdown为高时，所有PPI输入信号都会被忽略，并且所有PPI输出都会被驱动到默认的无效状态。</li><li>Shutdown是电平触发信号，不依赖于任何时钟。</li></ul></li><li>TxUlpmClk（Input）：时钟Lane上的Transmit Ultra Low-Power Mode信号。<ul><li>此信号高有效，会让时钟Lane模块进入Ultra Low-Power模式。</li><li>Lane模块会保持这种极低功耗状态，直到TxUlpmClk被置为无效。</li></ul></li></ul></li></ul><h3 id="4-2-CSI-2-Clock-Lane-Receiver"><a href="#4-2-CSI-2-Clock-Lane-Receiver" class="headerlink" title="4.2 CSI-2 Clock Lane Receiver"></a>4.2 CSI-2 Clock Lane Receiver</h3><ul><li><p>其框架如下图所示。</p><p><img src="/2024/05/04/MIPI-CSI-5/image-20240504135210769.png" alt="image-20240504135210769"></p></li><li><p>其主要包含三个部分：</p><ul><li>LP-RX，用于低功耗功能（Low-power function）。</li><li>HS-RX，用于高速功能（High-speed function）。</li><li>CIL-MCNN，用于Lane控制和接口逻辑。</li></ul></li><li><p>与LLP Layer的PPI接口有：</p><ul><li>RxDDRClkHS（Output）：高速接收DDR时钟信号，用来采样所有数据lane中的数据</li><li>RxClkActiveHS（Output）：高速接收有效信号（High-Speed Reception Active）。此信号高有效，用来指示时钟Lane正在接收有效时钟。该信号是异步的。</li><li>Stopstate（Output）：Lane是否处于Stop状态。此信号高有效，用来指示Lane模块当前是否处于Stop状态。该信号是异步的。</li><li>Shutdown（Input）：关闭Lane模块。此信号高有效，用来强制Lane模块进入“shutdown”，禁用所有活动。与Transmitter端相同。</li><li>RxUlpmEsc（Output）：Escape Ultra Low Power（Recieve）模式。<ul><li>此信号高有效，用来指示Lane模块是否已经进入到了Ultral Low Power模式。</li><li>Lane模块会在此信号有效时保持这种模式，直到再次检测到了一个Stop state。</li></ul></li></ul></li></ul><h3 id="4-3-CSI-2-Data-Lane-Transmitter"><a href="#4-3-CSI-2-Data-Lane-Transmitter" class="headerlink" title="4.3 CSI-2 Data Lane Transmitter"></a>4.3 CSI-2 Data Lane Transmitter</h3><ul><li><p>其框架如下图所示。</p><p><img src="/2024/05/04/MIPI-CSI-5/image-20240504142223120.png" alt="image-20240504142223120"></p></li><li><p>其主要包含三个部分：</p><ul><li>LP-RX，用于低功耗功能（Low-power function）。</li><li>HS-RX，用于高速功能（High-speed function）。</li><li>CIL-MFEN，用于Lane控制和接口逻辑。<ul><li>对于可选的 去斜(deskew) 校准功能，数据Lane会发送一个Deskew Sequence进行校正。</li></ul></li></ul></li><li><p>与LLP Layer的PPI接口有：</p><ul><li>TxDDRClkHS-I（Input）：高速发送DDR时钟（同相位，in-phase）。</li><li>TxByteClkHS（Input）：高速发送Byte时钟。用来同步高速传输时钟域里的PPI信号。<ul><li>建议在传输数据通道模块中共享一个TxByteClkHS信号。</li><li>TxByteClkHS的频率必须恰好是 high-speed bit rate 的1&#x2F;8。</li></ul></li><li>TxDataHS[7:0]（Input）：高速发送Data信号。要发送的8 bit高速数据。</li><li>TxRequestHS（Input）：高速发送Request信号。<ul><li>TxRequestHS的一次低到高的转换会让Lane模块发起一个Start-of-Transmission序列。</li><li>TxRequestHS一次高到低的转换会让Lane模块发起一个End-of-Transmission序列。</li><li>此信号高有效，高电平时指示LLP正通过 TxByteDataHS 接口发送有效数据。</li><li>在TxByteClkHS的时钟上升沿上，当TxRequestHS和TxReadyHS同时有效时，Lane模块会接受（accept）数据。</li><li>协议总是在TxRequestHS有效的时候提供合法的发送数据。一旦被置为有效，TxRequestHS会保持高电平，直到所有数据都被接受（accpet）了。</li></ul></li><li>TxReadyHS（Output）：高速发送Ready信号。<ul><li>此信号高有效，用来指示TxDataHS被Lane模块所接受（accepted）即将会被串行发送出去。</li><li>TxReadyHS在TxByteClkHS的上升沿采样有效。</li></ul></li><li>Shutown（Input）：关闭Lane模块。此信号高有效，用来强制Lane模块进入“shutdown”。与前面介绍相同。</li><li>TxUlpmEsc（Input）：Escape Mode Transmit Unltra Low Power。此信号高有效，和TxRequestEsc信号一起被置位，让Lane模块进入极低功耗（Ultra Low Power）模式。Lane模块会保持这种模式，直到TxRequestEsc被置为无效。</li><li>TxRequestEsc（Input）：此信号高有效，和TxUlpmEsc一起被置位，用来请求进入到Escape Mode。一旦进入Esacape Mode， Lane会一直处于Escape Mode，直到TxRequestEsc被置为无效。TxRequestEsc只会在<strong>TxRequestHS为低的时候</strong>，<strong>被协议置位。</strong></li><li>TxClkEsc（Input）：Escape Mode Transmit Clock。这个时钟直接被用于产生escape序列。这个时钟的周期决定了低功耗信号的symbol time。</li></ul></li></ul><h3 id="4-4-CSI-2-Data-Lane-Receiver"><a href="#4-4-CSI-2-Data-Lane-Receiver" class="headerlink" title="4.4 CSI-2 Data Lane Receiver"></a>4.4 CSI-2 Data Lane Receiver</h3><ul><li><p>其框架如下图所示。</p><p><img src="/2024/05/04/MIPI-CSI-5/image-20240504154421964.png" alt="image-20240504154421964"></p></li><li><p>其主要包含三个部分：</p><ul><li>LP-RX，用于低功耗功能（Low-power function）。</li><li>HS-RX，用于高速功能（High-speed function）。</li><li>CIL-SFEN，用于Lane控制和接口逻辑。<ul><li>对于可选的 去斜(deskew) 校准功能，支持Deskew Pattern，对接收数据进行Deskew优化。</li></ul></li></ul></li><li><p>与LLP Layer的PPI接口有：</p><ul><li><p>RxDDRClkHS（Input）：高速接收DDR时钟信号，用来采样所有数据lane中的数据。这个信号由CSI-2时钟Lane接收器所提供。</p></li><li><p>RxByteClkHS（Output）：高速接收Byte时钟信号。</p><ul><li>此信号用来同步在高速接收时钟域内的信号。</li><li>RxByteClkHS信号是通过接收到的RxDDRClkHS整除来产生的。</li></ul></li><li><p>RxDataHS[7:0]（Output）：高速接收Data信号。Lane模块接收的8 bit高速数据。</p><ul><li>连接到RxDataHS[0]的信号首先被接收(LSB 优先)。</li><li>数据在RxByteClkHS上升沿的时候被采样传输。</li></ul></li><li><p>RxValidHS（Output）：高速接收Data Valid信号。</p><ul><li>此信号高有效，用来指示Lane模块正在通过接口RxDataHS输出有效数据到LLP层。</li><li>协议层会在RxValidHS有效的时候，在每一个RxByteClkHS的时钟上升沿的时候去抓取RxDataHS信号。</li><li>协议没有提供降低接收数据速度的功能（throttle）。</li></ul></li><li><p>RxActiveHS（Output）： 高速接收Active信号。此信号高有效，用来指示Lane模块正在从Lane中接收高速传输数据。</p></li><li><p>RxSyncHS（Output）：接收器监测 ”同步“ 信号。</p><ul><li>此信号高有效，用来指示Lane模块已经监测到了一个正确的同步事件。</li><li>在一个典型的高速传输中，当RxActiveHS首次被置位时，一次高速传输的开始点，RxSyncHS会保持高电平，时间是一个RxByteClkHS周期。</li><li>这个信号被拉低，会用ErrSotSyncHS来报告。</li></ul></li><li><p>RxUlpmEsc（Output）：Escape Ultra Low Power （Receive）模式，此信号高有效。</p><ul><li>置位后用来指示Lane模块已经进入了极低功耗模式。</li><li>Lane模块会保持在这种模式中，直到在Lane上检测到了一个StopState。</li></ul></li><li><p>Stopstate（Output）：Lane处于Stop状态。此信号高有效，用来指示Lane模块正处于Stop状态。此信号是异步的。</p></li><li><p>Shutdown（Input）：关闭Lane模块。此信号高有效，用来强制Lane模块进入“shutdown”，与前面介绍相同。</p></li><li><p>ErrSotHS（Output）：Start-of-Transmission（SoT）Error信号。</p><ul><li>如果高速SoT前导序列出错，但此时仍然能够达到适当的同步，这个错误信号置位的时间为RxByteClkHS的一个周期。这种错误被认为是前导序列的一个“软错误”，载荷数据的信任度会降低。</li></ul></li><li><p>ErrSotSyncHS（Output）：Start-of-Transmission同步Error信号。</p><ul><li>如果高速SoT前导序列出错，并且不能期望得到一个适当的同步。这个错误信号置位的时间为RxByteClkHS的一个周期。</li></ul></li><li><p>ErrControl（Output）：控制错误。这个信号在一个错误的 line state sequence 被检测到时置位。</p></li><li><p>ErrEsc（Output）： Escape Entry Error。</p><ul><li>如果接收到了一个无法识别的escape entry命令，这个信号会被置位，并且保持为高。</li><li>直到下一个line state变化发生。</li><li>接收器只有在ULPS模式下，支持的escape entry命令。</li></ul></li></ul></li></ul><p>​    </p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>高速串行总线</category>
      
      <category>MIPI 接口协议</category>
      
      <category>CSI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIPI-CSI-4</title>
    <link href="/2024/05/01/MIPI-CSI-4/"/>
    <url>/2024/05/01/MIPI-CSI-4/</url>
    
    <content type="html"><![CDATA[<ul><li>本篇博客将重点介绍 YUV&#x2F;RGB&#x2F;RAW 三种图像格式在CSI-2协议中的数据传输格式。</li></ul><hr><h2 id="1-YUV-图像数据"><a href="#1-YUV-图像数据" class="headerlink" title="1. YUV 图像数据"></a>1. YUV 图像数据</h2><h3 id="1-1-关于YUV"><a href="#1-1-关于YUV" class="headerlink" title="1.1 关于YUV"></a>1.1 关于YUV</h3><ul><li><p>YUV将亮度与色度进行分离。</p><ul><li>Y 表示亮度，即灰度值。另外，其还包含了较多的绿色通道信息。</li><li>U 表示蓝色通道与亮度的差值。</li><li>V 表示红色通道与亮度的差值。</li></ul></li><li><p>YUV 优点</p><ul><li>研究发现，人眼对亮度的敏感程度超过了色度。<ul><li>因此YUV将亮度与色度信息分离，并使用不同bit进行存储，这样可以更高效的存储图像数据。</li></ul></li></ul></li><li><p>YUV 采样方式</p><ul><li><p>色度通道的采样率可以低于亮度通道，且不会明显降低图像质量。因此存在以下4种 YUV 采样方式。</p><ul><li><p>4:4:4：表示完全采样，每个像素都有独立的Y&#x2F;U&#x2F;V值。</p><p><img src="/2024/05/01/MIPI-CSI-4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hrdXpoYW5n,size_16,color_FFFFFF,t_70.png" alt="img"></p></li><li><p>4:2:2：相邻每两个像素点共用一个U&#x2F;V值。</p><p><img src="/2024/05/01/MIPI-CSI-4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hrdXpoYW5n,size_16,color_FFFFFF,t_70-1714554207000-3.png" alt="YUV422"></p></li><li><p>4:2:0：相邻每四个像素点共用一个U&#x2F;V值。</p><p><img src="/2024/05/01/MIPI-CSI-4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hrdXpoYW5n,size_16,color_FFFFFF,t_70-1714554674228-6.png" alt="YUV420"></p></li><li><p>4:1:1：与YUV420采样类似，都是四个像素点共用一个U&#x2F;V值，但YUV411是水平方向的四个像素点。如下图。</p><p><img src="/2024/05/01/MIPI-CSI-4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hrdXpoYW5n,size_16,color_FFFFFF,t_70-1714554841893-9.png" alt="YUV411"></p></li></ul></li></ul></li></ul><h3 id="1-2-Legacy-YUV420-8-bit"><a href="#1-2-Legacy-YUV420-8-bit" class="headerlink" title="1.2 Legacy YUV420 8-bit"></a>1.2 Legacy YUV420 8-bit</h3><ul><li><p>Legacy YUV420数据格式主要是为了和已经存在的系统做兼容。非Legacy 的YUV420数据格式能够减少实现开销。</p></li><li><p>Legacy YUV420 8-bit 数据传输如下图格式，在奇数行发送UYYUYY…，在偶数行发送VYYVYY…。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240501195556022.png" alt="image-20240501195556022"></p></li><li><p>传输数据若按照CSI-2协议进行传输，则传输结果如下图所示。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240501200356370.png" alt="image-20240501200356370"></p></li><li><p>其帧格式如下图所示。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240501201741491.png" alt="image-20240501201741491"></p></li></ul><h3 id="1-3-YUV420-8-bit"><a href="#1-3-YUV420-8-bit" class="headerlink" title="1.3 YUV420 8-bit"></a>1.3 YUV420 8-bit</h3><ul><li><p>YUV420 8-bit 传输数据格式如下图所示。其在奇数行只进行YYY…传输，在偶数行进行UYVYUYVY…序列传输。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240501202026705.png" alt="image-20240501202026705"></p><ul><li>因此，在偶数行传输的数据大小是奇数行传输数据大小的两倍。</li><li><a href="https://binbinqian.cn/2024/04/24/MIPI-CSI-3/">这篇博客</a>3.1节中介绍到，同一帧中，相同Data Type的行都应该是相同长度，但YUV420 是一个例外。</li></ul></li><li><p>传输数据若按照CSI-2协议进行传输，则传输结果如下图所示。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240501204953435.png" alt="image-20240501204953435"></p></li><li><p>其帧格式如下图所示。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240501205620557.png" alt="image-20240501205620557"></p></li></ul><h3 id="1-4-YUV420-10-bit"><a href="#1-4-YUV420-10-bit" class="headerlink" title="1.4 YUV420 10-bit"></a>1.4 YUV420 10-bit</h3><ul><li><p>其传输数据格式如下图所示。</p><ul><li><p>奇数行仍然只传输Y数据，不同的是，在传输四个字节之后，将每个Y数据LSB 2bit组合，生成新的传输字节。</p></li><li><p>偶数行传输UYVY，并将对应的LSB 2bit 数据组合，生成新的传输字节。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240501210003353.png" alt="image-20240501210003353"></p></li></ul></li><li><p>传输数据若按照CSI-2协议进行传输，则传输结果如下图所示，LSB优先传输。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240501210508931.png" alt="image-20240501210508931"></p></li><li><p>其帧格式如下图所示。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240501210639485.png" alt="image-20240501210639485"></p></li></ul><h3 id="1-5-YUV422-8-bit"><a href="#1-5-YUV422-8-bit" class="headerlink" title="1.5 YUV422 8-bit"></a>1.5 YUV422 8-bit</h3><ul><li><p>YUV 422 是相邻的两个像素点共用一组U&#x2F;V值。</p></li><li><p>YUV422 8-bit 数据传输如下图所示，其发送数据序列为UYVY。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240501211128604.png" alt="image-20240501211128604"></p></li><li><p>其帧格式如下图所示。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240501211228665.png" alt="image-20240501211228665"></p></li></ul><h3 id="1-6-YUV422-10-bit"><a href="#1-6-YUV422-10-bit" class="headerlink" title="1.6 YUV422 10-bit"></a>1.6 YUV422 10-bit</h3><ul><li><p>其数据传输格式如下图所示，LSB优先传输。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240501211451599.png" alt="image-20240501211451599"></p></li><li><p>其帧格式如下图所示。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240501211517398.png" alt="image-20240501211517398"></p></li></ul><h2 id="2-RGB-图像数据"><a href="#2-RGB-图像数据" class="headerlink" title="2. RGB 图像数据"></a>2. RGB 图像数据</h2><h3 id="2-1-RGB888"><a href="#2-1-RGB888" class="headerlink" title="2.1 RGB888"></a>2.1 RGB888</h3><ul><li><p>其数据传输格式如下图所示，以BGR的字节序列进行传输。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502120948993.png" alt="image-20240502120948993"></p></li><li><p>其帧格式如下图所示。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502121027927.png" alt="image-20240502121027927"></p></li></ul><h3 id="2-2-RGB666"><a href="#2-2-RGB666" class="headerlink" title="2.2 RGB666"></a>2.2 RGB666</h3><ul><li><p>其传输数据格式如下图所示，将R\G\B拼接在一起，得到BGR[17:0]进行传输。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502122314573.png" alt="image-20240502122314573"></p></li><li><p>在CSI串行传输时，LSB优先发送。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502122338245.png" alt="image-20240502122338245"></p></li><li><p>其帧格式如下图所示。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502122614390.png" alt="image-20240502122614390"></p></li></ul><h3 id="2-3-RGB565"><a href="#2-3-RGB565" class="headerlink" title="2.3 RGB565"></a>2.3 RGB565</h3><ul><li><p>与2.2节相同，将R\G\B拼接在一起，得到BGR[15:0]进行传输。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502124617195.png" alt="image-20240502124617195"></p></li></ul><h3 id="2-4-RGB555"><a href="#2-4-RGB555" class="headerlink" title="2.4 RGB555"></a>2.4 RGB555</h3><ul><li><p>在CSI-2总线上传输RGB555数据时，需要做特殊处理，如下图所示。</p><ul><li><p>其在绿色通道中填充1bit 数据0，来实现与RGB565相同的处理方式。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502124759680.png" alt="image-20240502124759680"></p></li></ul></li></ul><h3 id="2-5-RGB444"><a href="#2-5-RGB444" class="headerlink" title="2.5 RGB444"></a>2.5 RGB444</h3><ul><li><p>通用，在CSI-2总线上传输时，需要进行填充，如下图所示。</p><ul><li><p>在红色和蓝色通道填充数据‘1’，在绿色通道填充数据‘1,0’，从而实现与RGB565相同的处理方式。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502125010140.png" alt="image-20240502125010140"></p></li></ul></li></ul><h2 id="3-RAW-图像数据"><a href="#3-RAW-图像数据" class="headerlink" title="3. RAW 图像数据"></a>3. RAW 图像数据</h2><h3 id="3-1-关于RAW"><a href="#3-1-关于RAW" class="headerlink" title="3.1 关于RAW"></a>3.1 关于RAW</h3><ul><li>RAW 文件并不包含影像数据，而是包含进入相机并被感光器接收的光线强弱数据。</li><li>RAW 文件是 相机拍摄后原始数据格式的统称。</li><li>RAW 6&#x2F;7&#x2F;8&#x2F;10&#x2F;12&#x2F;14&#x2F;16&#x2F;20&#x2F;24被用来传输图像传感器RAW图像数据，但RAW数据类型不仅限于这几种。</li></ul><h3 id="3-2-RAW-6-7-8"><a href="#3-2-RAW-6-7-8" class="headerlink" title="3.2 RAW 6&#x2F;7&#x2F;8"></a>3.2 RAW 6&#x2F;7&#x2F;8</h3><ul><li><p>在CSI-2总线上传输格式均为直接拼接传输，仍以字节为单位，LSB优先。具体可参考协议P128。</p></li><li><p>下图为RAW 7 在CSI-2协议中传输格式。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502151703673.png" alt="image-20240502151703673"></p></li></ul><h3 id="3-3-RAW-10"><a href="#3-3-RAW-10" class="headerlink" title="3.3 RAW 10"></a>3.3 RAW 10</h3><ul><li><p>将数据进行拆分得到两部分：RAW[9:2]，RAW[1:0]；并将LSB 2bit进行拼接，得到一个新的Byte。如下图所示。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502154831720.png" alt="image-20240502154831720"></p></li><li><p>其帧格式如下图所示。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502154907692.png" alt="image-20240502154907692"></p></li></ul><h3 id="3-4-RAW-12"><a href="#3-4-RAW-12" class="headerlink" title="3.4 RAW 12"></a>3.4 RAW 12</h3><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502155256090.png" alt="image-20240502155256090"></p><h3 id="3-5-RAW-14"><a href="#3-5-RAW-14" class="headerlink" title="3.5 RAW 14"></a>3.5 RAW 14</h3><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502155639958.png" alt="image-20240502155639958"></p><h3 id="3-6-RAW-16"><a href="#3-6-RAW-16" class="headerlink" title="3.6 RAW 16"></a>3.6 RAW 16</h3><ul><li><p>传输格式如下图所示。</p><ul><li><p>注意，LSB优先是指在字节中传输时，是LSB优先，与字节顺序无关。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502161421909.png" alt="image-20240502161421909"></p></li></ul></li></ul><h3 id="3-7-RAW-20"><a href="#3-7-RAW-20" class="headerlink" title="3.7 RAW 20"></a>3.7 RAW 20</h3><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502162903505.png" alt="image-20240502162903505"></p><h2 id="4-用户自定义类型数据"><a href="#4-用户自定义类型数据" class="headerlink" title="4. 用户自定义类型数据"></a>4. 用户自定义类型数据</h2><ul><li><p>对于用户自定义类型数据，满足以下几点：</p><ul><li><p>包的大小可以随意变化。</p></li><li><p>包与包之间的间隔区间可以随意变化。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240502172838382.png" alt="image-20240502172838382"></p></li></ul></li></ul><h2 id="5-建议的内存存储格式"><a href="#5-建议的内存存储格式" class="headerlink" title="5. 建议的内存存储格式"></a>5. 建议的内存存储格式</h2><ul><li><p>通用数据接收如下图所示。</p><ul><li><p>以RX端 Buffer中每个单元位宽为 32bit 为例。</p></li><li><p>RX端接收的第一个字节数据被放置在Buffer的LSB中，以此类推，第四个字节数据被放置在Buffer的MSB中。</p><p><img src="/2024/05/01/MIPI-CSI-4/image-20240503130017484.png" alt="image-20240503130017484"></p></li></ul></li><li><p>对于前面介绍的三种数据格式，与通用数据接收格式类似，具体可参考协议中P142。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>高速串行总线</category>
      
      <category>MIPI 接口协议</category>
      
      <category>CSI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIPI-CSI-3</title>
    <link href="/2024/04/25/MIPI-CSI-3/"/>
    <url>/2024/04/25/MIPI-CSI-3/</url>
    
    <content type="html"><![CDATA[<hr><ul><li>本篇博客接着MIPI-CSI-2继续介绍CSI协议中Low Level Protocol (LLP)相关内容。</li></ul><h2 id="1-Latency-Reduction-and-Transport-Efficiency-LRTE"><a href="#1-Latency-Reduction-and-Transport-Efficiency-LRTE" class="headerlink" title="1. Latency Reduction and Transport Efficiency (LRTE)"></a>1. Latency Reduction and Transport Efficiency (LRTE)</h2><ul><li>LRTE是CSI-2可选特性，能够促使系统达到最优的传输效率。LRTE主要有两部分<ul><li>Interpacket Latency Reduction (ILR)</li><li>Enhanced Transport Efficiency</li></ul></li></ul><h3 id="1-1-ILR"><a href="#1-1-ILR" class="headerlink" title="1.1 ILR"></a>1.1 ILR</h3><ul><li><p>根据D-PHY和C-PHY的物理规范，CSI-2短包之间和长包之间通过EOT、LPS、SOT包分隔符分开。</p></li><li><p>一些高级图像会通过降低这些分隔符的开销，来提升速度。</p></li><li><p>如下图所示，将EOT、LPS、SOT包分隔符替换为EPD(Efficient Packet Delimiter)。</p><ul><li>EPD避免了HS-LPS-HS 的转换。</li></ul><p><img src="/2024/04/25/MIPI-CSI-3/image-20240424124613940.png" alt="image-20240424124613940"></p></li><li><p>EPD由PHY层 和&#x2F;或 LLP层提供的元素构成。</p><ul><li>其中PHY层产生的EPD元素被称为 Packet Delimiter Quick(PDQ).</li><li>其中LLP层产生的EPD元素被称为Spacers. 如果一个Lane插入了Spacers，那么所有的Lane都需要插入Spacers.</li></ul></li><li><p>LRTE要求EPD应在高速传输模式下最后一个包数据之后插入，不允许在EOT之后再插入EPD。</p><ul><li>但存在某些特殊情况，允许在EOT后插入Spacers，但不可插入PDQ。</li></ul></li></ul><h3 id="1-2-C-PHY-EPD"><a href="#1-2-C-PHY-EPD" class="headerlink" title="1.2 C-PHY EPD"></a>1.2 C-PHY EPD</h3><ul><li><p>C-PHY EPD中的PDQ是由7-UI Sync Word构成的。</p></li><li><p>PDQ由TX 端 PHY层生成，RX端 PHY层解析。</p><ul><li>TX端，在PHY层的PPI接口处应重复使用<code>TxSendSyncHS</code>，以通知C-PHY生成PDQ控制码。</li><li>RX端，在PHY层接收到PDQ控制码时，应在PPI处重复使用<code>RxSyncHS</code>，以通知LLP层。</li></ul></li><li><p>Spacer Word 数量可通过寄存器配置指定，Space Word的值为0xFFFF。</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240424133058197.png" alt="image-20240424133058197"></p></li></ul><h3 id="1-3-D-PHY-EPD"><a href="#1-3-D-PHY-EPD" class="headerlink" title="1.3 D-PHY EPD"></a>1.3 D-PHY EPD</h3><ul><li><p>在D-PHY下，有两种EPD选项。但无论哪种选项，当打开EPD使能后，都需要用Filler字节对齐所有Lane上的数据，Filler字节的值是0x00.</p></li><li><p>D-PHY EPD Option 1</p><ul><li><p>传输模式如下图所示。</p><img src="image-20240424145122800.png" alt="image-20240424145122800" style="zoom: 50%;" /></li><li><p>PDQ是由D-PHY中的HS-Idle构成的。</p><ul><li>注意：HS-Idle并不被ALP模式所支持。</li><li>TX端，在PHY层的PPI接口处应重复使用<code>TxSendPDQHS</code>，以通知D-PHY生成PDQ控制码。</li><li>RX端，在PHY层接收到PDQ控制码时，应在PPI处重复使用<code>RXDetectPDQHS</code>，以通知LLP层。</li></ul></li><li><p>Spacers仍是由LLP生成的，其字节值为0xFF.</p><ul><li>DPHY RX端接收到数据包之后，会先将数据加载到缓冲区中，之后再处理传递至LLP层。</li><li>因此在数据包传输之间插入Spacers，以便RX端足够的时间去处理接收到的数据，避免数据丢失。</li></ul></li></ul></li><li><p>D-PHY EPD Option 2</p><ul><li><p>传输模式如下图所示。</p><img src="image-20240424154817918.png" alt="image-20240424154817918" style="zoom:50%;" /></li><li><p>该模式下只有LLP层生成的Spacer，没有PHY层生成的PDQ 来实现包间隔。</p></li><li><p>由于Option 1中提到，HS-Idle并不被ALP模式支持，但Option 2可以被ALP模式支持。</p></li><li><p>在连续传输数据包时，PDQ还可用作数据包之间的分界。</p><ul><li>但Option 2模式下，数据包的间隔只有Spacers，所以在大量数据包连续传输时，可能影响数据传输的稳定性和准确性。</li></ul></li><li><p>DPHY EPD Option 2同样也可应用于C-PHY&#x2F;D-PHY Escape模式下LPDT 传输。</p></li><li><p>Option 2 下，无论是高速模式还是LPDT模式，EPD都不能在EoT&#x2F;EoTp之后插入。</p></li></ul></li></ul><h3 id="1-4-Using-ILR-and-Enhanced-Transport-Efficiency-Together"><a href="#1-4-Using-ILR-and-Enhanced-Transport-Efficiency-Together" class="headerlink" title="1.4 Using ILR and Enhanced Transport Efficiency Together"></a>1.4 Using ILR and Enhanced Transport Efficiency Together</h3><ul><li><p>如下图所示，同时使用EPD和ALPS。</p><img src="image-20240424164848440.png" alt="image-20240424164848440" style="zoom:50%;" /></li></ul><h2 id="2-Data-Scrambling"><a href="#2-Data-Scrambling" class="headerlink" title="2. Data Scrambling"></a>2. Data Scrambling</h2><ul><li><p>数据加扰(Data Scrambling) 目的是减轻EMI和RF自干扰的影响，数据加扰主要是使用了一种数据随机化技术。</p></li><li><p>如下图所示，数据加扰被应用到每个Lane。</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240424170608673.png" alt="image-20240424170608673"></p></li></ul><h3 id="2-1-D-PHY-Scrambling"><a href="#2-1-D-PHY-Scrambling" class="headerlink" title="2.1 D-PHY Scrambling"></a>2.1 D-PHY Scrambling</h3><ul><li><p>如下图所示，D-PHY下，使用两条Lane进行传输，突发传输两个数据包。</p><ul><li>在SoT之后，HS-ZERO和HS-Sync会被发送到Lane中。</li><li>加扰主要通过LFSR电路实现，用于产生伪随机序列，与串行输入的数据进行异或操作。<ul><li>在每次传输开始时，需要对LFSR seed 进行初始化。</li><li>在Burst起始位置，紧跟HS Sync之后第一个要发送字节之前，由D-PHY立即生成初始化值。</li><li>在EDP Option1 下，EPD HS-Idle发送之后，立即生成初始化值。</li><li>在EDP Option2 下，突发传输的包之间不需要再次初始化。</li></ul></li></ul><p><img src="/2024/04/25/MIPI-CSI-3/image-20240424170905884.png" alt="image-20240424170905884"></p></li></ul><h3 id="2-2-C-PHY-Scrambling"><a href="#2-2-C-PHY-Scrambling" class="headerlink" title="2.2 C-PHY Scrambling"></a>2.2 C-PHY Scrambling</h3><ul><li><p>如下图所示，C-PHY下，使用两条Lane进行传输，突发传输两个数据包。</p><ul><li><p>在SoT之后，Preamble和Sync被发送到Lane上。</p></li><li><p>每条Lane 的LFSR总是在Sync Word被发送时，初始化LFSR seed。</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240424180929986.png" alt="image-20240424180929986"></p></li></ul></li><li><p>Different Seed for Sync Word</p><ul><li><p>在某些场景下，传输的图像可能带有相同&#x2F;高度相似的长包包头和相同的像素数据的长包。</p></li><li><p>如果每个包传输开始LFSR都被初始化相同的seed值，则加扰后的伪随机序列会同样高速相似，导致信号随机性减少。</p></li><li><p>为了减轻这个问题，TX端每次发送sync word时，会选择不同的Sync Type，用于通知RX端使用了哪个Starting Seed。</p></li><li><p>下表为C-PHY中定义的五种Sync Type，而CSI-2协议只会使用Sync Type前面四种。</p><ul><li>如果只使用一个seed值，那么这个seed值应是seed3。</li></ul><p><img src="/2024/04/25/MIPI-CSI-3/image-20240430110531878.png" alt="image-20240430110531878"></p></li></ul></li><li><p>扰码器&#x2F;解码器 结构</p><ul><li><p>下图为单条Lane中扰码器&#x2F;解码器结构。</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240430112708367.png" alt="image-20240430112708367"></p></li><li><p>由LFSR产生的PRBS（Pseudo-Random Binary Sequence）伪随机数被用作seed index，并根据Sync Type选择合适的seed初始值。</p></li><li><p>下图为多条Lane中扰码器&#x2F;解码器结构示意图。</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240430152613101.png" alt="image-20240430152613101"></p></li><li><p>扰码电路的具体实现如下电路所示。</p><ul><li><p>其中PktD0-7 为输入一个Byte的数据，其与LFSR生成的PRBS序列G(x)进行异或，加扰运算，得到输出发送数据TxD0-7.</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240430154559927.png" alt="image-20240430154559927"></p></li></ul></li></ul></li></ul><h2 id="3-传输数据格式"><a href="#3-传输数据格式" class="headerlink" title="3. 传输数据格式"></a>3. 传输数据格式</h2><h3 id="3-1-Packet-Data-Payload-Size-Rules"><a href="#3-1-Packet-Data-Payload-Size-Rules" class="headerlink" title="3.1 Packet Data Payload Size Rules"></a>3.1 Packet Data Payload Size Rules</h3><ul><li>对于YUV&#x2F;RGB&#x2F;RAW 数据类型，一个长包包含一行的图像数据。<ul><li>如果数据包的虚拟通道号相同，且都属于同一帧，那么相同的Data Type的长包长度应相同。<strong>YUV420例外。</strong></li></ul></li><li>对于用户自定义的数据类型(Data Type)、USL Data Type 以及 SROI Data Type，长包的长度可以是任意的，包与包之间的间隔也是可变的。</li><li>对于所有的Data Type，长包中的有效数据长度必须是8 bits的整数倍。<ul><li>有些Data Type的数据长度可能不足8 bits整数倍，可以通过填充额外的像素到有效数据的结尾，以满足要求。</li></ul></li></ul><h3 id="3-2-帧格式示例"><a href="#3-2-帧格式示例" class="headerlink" title="3.2 帧格式示例"></a>3.2 帧格式示例</h3><ul><li><p>CSI-2协议中一共给出了以下三种帧格式示例。</p><ul><li><p>常见帧格式</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240430162602213.png" alt="image-20240430162602213"></p></li><li><p>Digital Interlaced Video</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240430181522535.png" alt="image-20240430181522535"></p></li><li><p>Digital Interlaced Video with Accurate Synchronization Timing Information</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240430181618897.png" alt="image-20240430181618897"></p></li></ul></li></ul><h3 id="3-3-Data-Interleaving"><a href="#3-3-Data-Interleaving" class="headerlink" title="3.3 Data Interleaving"></a>3.3 Data Interleaving</h3><ul><li>CSI-2协议支持交错传输不同数据类型的数据包，主要通过以下两种方式进行交错传输。</li></ul><h4 id="3-3-1-Data-Type-Interleaving"><a href="#3-3-1-Data-Type-Interleaving" class="headerlink" title="3.3.1 Data Type Interleaving"></a>3.3.1 Data Type Interleaving</h4><ul><li><p>在视频数据传输时，可以使用Data Type来进行标识，交错传输不同数据格式的数据包。</p></li><li><p>RX端会在接收到的数据包头中解析该数据格式类型，如下图所示。</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240430183323311.png" alt="image-20240430183323311"></p></li><li><p>他们是相同虚拟通道的数据包，无论Data Type值是什么，他们都共享相同的 <strong>帧开始&#x2F;结束</strong> 和 <strong>行开始&#x2F;结束</strong> 同步信息。</p><ul><li><p>根据定义，相同虚拟通道内所有处于Frame Start和Frame End包之间的包，无论Data Type是什么，都属于同一帧。</p></li><li><p>下图为<strong>Packet Level交错数据传输</strong>。</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240430184252724.png" alt="image-20240430184252724"></p></li><li><p>下图为<strong>Frame Level交错数据传输</strong>。</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240430184344306.png" alt="image-20240430184344306"></p></li></ul></li></ul><h4 id="3-3-2-Virtual-Channel-Identifier-Interleaving"><a href="#3-3-2-Virtual-Channel-Identifier-Interleaving" class="headerlink" title="3.3.2 Virtual Channel Identifier Interleaving"></a>3.3.2 Virtual Channel Identifier Interleaving</h4><ul><li><p>这种方式允许一条数据流中存在不同的数据类型，他们在不同的虚拟通道上。</p></li><li><p>每个虚拟通道有自己的Frame Start和Frame End包。</p></li><li><p>不同的虚拟通道可能有不同的帧率，即使不同虚拟通道中可能存在相同Data Type的数据，仍属于不同数据帧。</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240430185124342.png" alt="image-20240430185124342"></p></li><li><p>另外，每条虚拟通道还允许使用Data Type Interleaving.</p><ul><li>因此，RX端可以通过检测VCI以及Data Type值的组合情况，来解析不同的数据包。</li></ul></li></ul><h3 id="3-4-Data-Format"><a href="#3-4-Data-Format" class="headerlink" title="3.4 Data Format"></a>3.4 Data Format</h3><ul><li><p>D-PHY to C-PHY</p><ul><li><p>对于D-PHY，序列中的字节是按照LSB优先的方式串行传输。</p></li><li><p>对于C-PHY，连续两个字节被编码为7个5bit的symbol，之后再按照LSS(Least Significant Symbol)优先的方式进行传输。</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240501120259564.png" alt="image-20240501120259564"></p></li></ul></li><li><p>通用8bit长包数据类型如下图所示。</p><p><img src="/2024/04/25/MIPI-CSI-3/image-20240501120616798.png" alt="image-20240501120616798"></p><ul><li>Null 和 Blanking Data <ul><li>对于null和blanking数据类型，接收器需要忽略包中有效数据的内容。</li><li>Null包没有任何含义。</li><li>Blanking包可能有专门用途，比如在一条ITU-R BT.656风格的视频流中，它作为帧之间的blanking lines。</li></ul></li><li>Embedded Information<ul><li>如下图所示，在每一帧图像数据的开头和结尾处，有可能嵌入额外信息的行。</li><li>对于这些额外嵌入信息的行，在数据传输时，需要标识为特殊的Data Type，即0x12.</li><li>在帧的开始处可能存在0行或多行内嵌数据。这些行被称为帧头（frame header）。</li><li>在帧的结尾处可能存在0行或多行内嵌数据。这些行被称为帧尾（frame footer）。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高速串行总线</category>
      
      <category>MIPI 接口协议</category>
      
      <category>CSI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIPI-CSI-2</title>
    <link href="/2024/04/24/MIPI-CSI-2/"/>
    <url>/2024/04/24/MIPI-CSI-2/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/vivo01/article/details/126289397">https://blog.csdn.net/vivo01/article/details/126289397</a></li><li><a href="https://www.cnblogs.com/Kroner/p/18017607">https://www.cnblogs.com/Kroner/p/18017607</a></li><li><a href="https://cloud.tencent.com/developer/article/2063788">https://cloud.tencent.com/developer/article/2063788</a></li></ul></li></ul><hr><ul><li>本篇博客主要介绍CSI协议中Low Level Protocol (LLP)相关内容。</li><li>LLP是一种以字节为导向、基于数据包的协议，支持使用短数据包和长数据包格式传输任意数据。其特性如下。<ul><li>Transport of arbitrary data (Payload independent)  </li><li>8-bit word size</li><li>Support for up to sixteen interleaved virtual channels on the same D-PHY Link, or up to 32 interleaved virtual channels on the same C-PHY Link</li><li>Special packets for frame start, frame end, line start and line end information </li><li>Descriptor for the type, pixel depth and format of the Application Specific Payload data</li><li>16-bit Checksum Code for error detection.</li><li>6-bit Error Correction Code for error detection and correction (D-PHY physical layer only)</li></ul></li></ul><h2 id="1-LLP-包格式"><a href="#1-LLP-包格式" class="headerlink" title="1. LLP 包格式"></a>1. LLP 包格式</h2><ul><li><p>数据格式如下图所示，有两种数据包结构，长数据包和短数据包。</p><ul><li><p>每个数据包的传输都是经历先从低功耗状态退出，之后是SOT序列，表示数据包的开始，之后是EOT，表示数据包的结束。</p><img src="image-20240410105430220.png" alt="image-20240410105430220" style="zoom:67%;" /></li></ul></li></ul><h3 id="1-1-D-PHY长数据包格式"><a href="#1-1-D-PHY长数据包格式" class="headerlink" title="1.1 D-PHY长数据包格式"></a>1.1 D-PHY长数据包格式</h3><ul><li><p>D-PHY长数据包格式如下图所示，主要包含三部分：32bit的数据包头，可变大小的应用相关数据以及16bit的数据包尾。</p><ul><li>数据包头<ul><li>Data ID：作为数据的标识，其中[7:6]表示Virtual Channel的4bit标识中的低两位，[5:0]是Data Type的标识。</li><li>Word Count：用于计数传输字节的个数，接收端根据该值判断数据接收何时结束。</li><li>VCX+ECC：<ul><li>[7:6] 虚拟通道扩展 VCX，表示Virtual Channel的4bit标识中的最高两位。</li><li>[5:0] 错误检测和纠正码 ECC，可以对数据包头进行1bit的错误进行纠正；并检测出2bit的错误，但不能纠正。</li></ul></li></ul></li><li>数据包尾<ul><li>16bit CRC(循环冗余校验) 检测输出数据是否有错误。</li></ul></li></ul><p><img src="/2024/04/24/MIPI-CSI-2/image-20240410131938094.png" alt="image-20240410131938094"></p></li></ul><h3 id="1-2-C-PHY长数据包格式"><a href="#1-2-C-PHY长数据包格式" class="headerlink" title="1.2 C-PHY长数据包格式"></a>1.2 C-PHY长数据包格式</h3><ul><li><p>C-PHY长数据包格式如下图所示，主要包含四部分：数据包头、可变大小的应用相关数据、16bit的数据包尾 以及零&#x2F;多个填充字节(FILLER).</p><ul><li>数据包头<ul><li>其长度为6N*16bit，其中N为Lane 的个数。可以看到其由两个相同部分组合得到。<ul><li>在两个相同部分之间需要插入7-symbol的Sync Word。</li></ul></li><li>5bit RES + 3bit VCX<ul><li>5bit保留位，设置为0.</li><li>3bit VCX是Virtual Channel的5bit标识中的最高三位。</li></ul></li><li>8bit DI<ul><li>2bit VCX是Virtual Channel的5bit标识中的最低两位。</li><li>6bit Data Type 是数据标识。</li></ul></li><li>16bit WC：与DPHY一样。</li><li>16bit  PH-CRC<ul><li>CPHY不需要ECC纠正码，因为它的传输是基于5进制的symbol，一个symbol传输错误，那么会有多个bit都是错的，使得ECC纠正码无效。</li><li>因此需要 数据包头(PH)的CRC码，计算前面4个字节，使得多bit错误被检测出来。</li><li>并发送多个副本（后面接着的相同部分字段），接收器根据CRC及副本可以尽可能恢复丢失&#x2F;损坏的数据。</li><li>C-PHY 还在数据包头中插入Sync Word，有助于接收器重新同步数据。</li></ul></li></ul></li><li>数据包尾<ul><li>16bit CRC(循环冗余校验) 检测输出数据是否有错误。</li></ul></li><li>FILLER<ul><li><a href="https://binbinqian.cn/2023/10/28/MIPI-CSI-1/">这篇博客</a>中介绍到CPHY中LLP层会确保传输的字节数目是2N的整数倍，在LLP层主要通过FILLER进行调节。</li></ul></li></ul><p><img src="/2024/04/24/MIPI-CSI-2/image-20240410140559921.png" alt="image-20240410140559921"></p></li><li><p>长包格式下，无论是DPHY还是CPHY，对于Packet Data 可以按照任何字节顺序(MSB-LSB&#x2F;LSB-MSB)进行传输；对于Packet Header&#x2F;Footer，需要先传输LSB字节，后传输MSB字节。</p></li></ul><h3 id="1-3-短数据包格式"><a href="#1-3-短数据包格式" class="headerlink" title="1.3 短数据包格式"></a>1.3 短数据包格式</h3><ul><li><p>DPHY短数据包格式如下图</p><ul><li><p>短数据包仅有32bit，包含三部分：Data ID、16-bit 有效数据、8bitVCX+ECC。</p><p><img src="/2024/04/24/MIPI-CSI-2/image-20240419155943004.png" alt="image-20240419155943004"></p></li></ul></li><li><p>CPHY短数据包格式如下图</p><ul><li><p>短数据包长度为6N*16 bit,其中N为Lane的个数。</p><p><img src="/2024/04/24/MIPI-CSI-2/image-20240419163331034.png" alt="image-20240419163331034"></p></li></ul></li></ul><h3 id="1-4-Virtual-Channel-Identifier"><a href="#1-4-Virtual-Channel-Identifier" class="headerlink" title="1.4 Virtual Channel Identifier"></a>1.4 Virtual Channel Identifier</h3><ul><li><p>如下图所示，RX端从接收的数据包中提取包头中VCX标识信息，并将数据送入指定通道。</p><ul><li>对于DPHY，Virtual Channel Identifier 有4bit，因此最大可支持16个通道的数据传输。</li><li>对于CPHY，Virtual Channel Identifier 有5bit，因此最大可支持32个通道的数据传输。</li></ul><p><img src="/2024/04/24/MIPI-CSI-2/image-20240419171500476.png" alt="image-20240419171500476"></p></li></ul><h2 id="2-Packet-Error-Correction"><a href="#2-Packet-Error-Correction" class="headerlink" title="2. Packet Error Correction"></a>2. Packet Error Correction</h2><h3 id="2-1-D-PHY-Packet-Header-Error-Correction"><a href="#2-1-D-PHY-Packet-Header-Error-Correction" class="headerlink" title="2.1 D-PHY Packet Header Error Correction"></a>2.1 D-PHY Packet Header Error Correction</h3><ul><li><p>在1.1节中介绍到，可以使用ECC对数据包头进行错误检测，可以纠正1bit错误，检测到2bit错误。</p></li><li><p>如下图所示，32bit的数据包头映射为ECC的输入26bit D，映射关系如下图所示。</p><ul><li>DI[7:0] - D[7:0], WC[7:0] - D[15:8], WC[15:8] - D[23:16], VCX[1:0] - D[25:24].</li></ul><p><img src="/2024/04/24/MIPI-CSI-2/image-20240422101635914.png" alt="image-20240422101635914"></p></li><li><p>Hamming code</p><ul><li><p>假设要传输的真实数据bit数为d，校验位Parity bit 数位p，则需要满足规则 d+p+1≤2<sup>p</sup>.</p><ul><li>以d&#x3D;4为例，则p&#x3D;3，一共实际传输的为7bit。</li><li>由于原始发送数据4bit，一共有16种可能的字符，经过编码后，7个bit可以有128种不同组合，112种是错误的码字。</li><li>对于汉明码，要求正确的码字之间最小的汉明距离d<sub>min</sub>为3. 则可以纠正的错误的最大比特数为$\frac{d_{min}-1}{2}$, 可以检测的错误的最大比特数为$d_{min}-1$.<ul><li>汉明距离：两个码字之间对应bit位置上值不同的比特个数。</li></ul></li></ul></li><li><p>汉明码生成矩阵G可由单位矩阵I和奇偶校验产生矩阵A构成。<br>$$<br>G&#x3D;[I|A]<br>$$</p><ul><li><p>包头加上ECC码可以根据下面等式获取，其中p为包头即Fig 47中的输入D（26bit&#x2F;64bit），G是上面介绍的汉明码生成矩阵。<br>$$<br>PH&#x3D;p*G<br>$$</p></li><li><p>若要校验接收的码字是否正确，检查故障校验(syndrome check) 向量s，s由下面等式得到。其中H为奇偶校验矩阵。<br>$$<br>s&#x3D;H*PH \<br>H&#x3D;[A^T|I]<br>$$</p><ul><li>如果s全部元素都为0，则表示接收到的数据均正确。</li><li>如果s中包含了非零元素，那么至少有1个错误。</li></ul></li></ul></li></ul></li><li><p>Hamming Modified Code</p><ul><li><p>汉明码最多可以检测到2bit，校正1bit的错误，但是无法区分是1bit还是2bit，因此在原有汉明码的基础上加了1bit校验位，来实现区分。</p></li><li><p>以传输数据bit数 d&#x3D;26为例，则校验位应为5。如果增加1bit校验位，可以修正64bit序列的前26bit，如下图所示。</p><ul><li><p>行定义了数据位置的3个LSB，列定义了数据位置的3个MSB，举例6‘b100101 对应的是第37个bit位置，对应的故障为0x68.</p></li><li><p>故障对应关系是MSB左对齐：0x68&#x3D;0110_1000，对应的分别是 P7 P6 P5 P4 P3 P2 P1 P0.</p></li></ul><p><img src="/2024/04/24/MIPI-CSI-2/image-20240422164159274.png" alt="image-20240422164159274"></p><ul><li>若要计算26bit中P0的值，则需要将26bit中P0值为1的数据位异或起来。例如：<code> P0 = D0^D1^D2^D4^D5^D7^D10^D11^D13^D16^D20^D21^D22^D23^D24</code></li></ul><p><img src="/2024/04/24/MIPI-CSI-2/image-20240422165900674.png" alt="image-20240422165900674"></p></li></ul></li><li><p>ECC Generation on TX Side</p><ul><li><p>64bit&#x2F;26bit Header的校验码生成器分别如下图所示。</p><ul><li>生成器电路基于上面的表格产生对应的校验码。</li></ul><img src="image-20240422171813921.png" alt="image-20240422171813921" style="zoom:67%;" /><img src="image-20240422171833852.png" alt="image-20240422171833852" style="zoom:67%;" /></li></ul></li><li><p>ECC on RX Side</p><ul><li><p>64bit 电路结构如下图所示。</p><ul><li>需要RX端对接收的数据再次生成一个新的ECC，之后利用这个ECC和接收到的ECC进行异或计算。</li><li>得到的值可能会有以下四种情况<ul><li>如果值为0，则表示没有错误。</li><li>如果值与Table4有匹配上的元素，则证明发生了单bit错误，对应bit位可以通过反转&#x2F;与1异或来进行修正。</li><li>如果值只有1个bit，则表示奇偶校验位中出现单bit错误，错误的位置就是故障bit的位置，接收的数据没有错误。</li><li>如果不满足上面三种情况，则表示发生了不可修复的错误，需要置位一个错误标志，指示包头数据损坏。</li></ul></li></ul><p><img src="/2024/04/24/MIPI-CSI-2/image-20240422172110089.png" alt="image-20240422172110089"></p></li><li><p>26bit 电路结构如下图所示。</p><p><img src="/2024/04/24/MIPI-CSI-2/image-20240422182631898.png" alt="image-20240422182631898"></p></li></ul></li></ul><h3 id="2-2-Checksum-Generation"><a href="#2-2-Checksum-Generation" class="headerlink" title="2.2 Checksum Generation"></a>2.2 Checksum Generation</h3><ul><li><p>在DPHY和CPHY的长数据包包尾以及CPHY的包头中都需要进行CRC校验。</p><ul><li>所有情况中，校验和的实现都是16-bit CRC。</li></ul></li><li><p>CRC校验的根本思想</p><ul><li>在要发送的数据码后附加校验码，附加的校验码要求生成的新的拼接码能够被一个特定的数A整除，在RX端，同样检测接收到的拼接码能够整除这个特定的数A。</li></ul></li><li><p>下图展示了16bit串行CRC实现方案</p><p><img src="/2024/04/24/MIPI-CSI-2/image-20240423110544668.png" alt="image-20240423110544668"></p><ul><li>多项式公式<ul><li>CRC的标准除数，一般是使用多项式公式来表示的，例如，多项式$x^4+x^3+x+1$ 表示为2进制数是’b11011.</li><li>可以看到除数位数是多项式最高次幂+1，但CRC长度始终要比除数位数少1，去除掉最高bit。</li></ul></li><li>实现流程<ul><li>选定一个标准除数</li><li>在要发送的数据(M bit)后面加上K-1位0，然后将这个新数(M+K-1 bit)以模2除法的方式除以标准除数，所得到的余数就是该数据的CRC校验码，也成为FCS(帧校验序列)。</li><li>将这个CRC校验码附加在原M bit 数据后，构成M+K-1 bit 新数据，发送给RX端。</li><li>RX端将接收的数据除以标准除数，如果余数为0，则认为数据正确。</li></ul></li></ul></li></ul><h2 id="3-Short-Packet-Data-Type-Codes"><a href="#3-Short-Packet-Data-Type-Codes" class="headerlink" title="3. Short Packet Data Type Codes"></a>3. Short Packet Data Type Codes</h2><h3 id="3-1-Synchronization-Short-Packet-Data-Type-Codes"><a href="#3-1-Synchronization-Short-Packet-Data-Type-Codes" class="headerlink" title="3.1 Synchronization Short Packet Data Type Codes"></a>3.1 Synchronization Short Packet Data Type Codes</h3><ul><li><p>下面这些短包数据类型只能通过短包形式进行传输。</p><p><img src="/2024/04/24/MIPI-CSI-2/image-20240423154133906.png" alt="image-20240423154133906"></p></li></ul><h4 id="3-1-1-Frame-Synchronization-Packets（帧同步包）"><a href="#3-1-1-Frame-Synchronization-Packets（帧同步包）" class="headerlink" title="3.1.1 Frame Synchronization Packets（帧同步包）"></a>3.1.1 Frame Synchronization Packets（帧同步包）</h4><ul><li>每个图像帧都是从一个“帧开始FS”包开始，这个包中有Frame Start Code。</li><li>FS包之后是1个或多个含有图像数据的长包， 以及0个&#x2F;多个包含同步编码的短包。</li><li>每个图像帧都是以一个“帧结束FE”的包结束，这个包中有Frame End Code。</li><li>对于FS和FE同步包，Data Filed 应该包含16bit的Frame Number，对于同一个帧，FS和FE同步包的帧号是一样的。<ul><li>当帧号为0时，帧号无效。</li></ul></li></ul><h4 id="3-1-2-Line-Synchronization-Packets（行同步包）"><a href="#3-1-2-Line-Synchronization-Packets（行同步包）" class="headerlink" title="3.1.2 Line Synchronization Packets（行同步包）"></a>3.1.2 Line Synchronization Packets（行同步包）</h4><ul><li><p>行同步包是可选的，其短包中Data Filed 应该包含16bit的 Line Number.</p><ul><li>对于一个特定的行，LS和LE中的Line Number应该是相同的。</li><li>行号是逻辑上的行号，并不一定与物理行号相同。</li></ul></li><li><p>行号可以是以下几种情况</p><ul><li><p>（1）行号为0，表示无效行号。</p></li><li><p>（2）相同虚拟通道和数据类型，连续行的LS包，行号都增加1。</p><ul><li><p>当在新的FS包之后第一个行包中，LS被重置为1。</p></li><li><p>这种模式用于progressive scan，逐行扫描视频数据流。</p></li></ul></li><li><p>（3）相同虚拟通道和数据类型，连续行的LS包，行号都增加一个相同的任意值，这个任意值大于1。</p><ul><li>当在新的FS包之后第一个行包中，LS被重置为任意的非零初始值。</li><li>这种模式用于interlaced，交织扫描视频数据流。</li></ul></li></ul></li><li><p>下图展示了几种情况</p><ul><li><p>DT1，行号递增1</p></li><li><p>DT2，行号递增2</p></li><li><p>DT3，无行号</p></li><li><p>DT4，无效行号</p></li></ul><p><img src="/2024/04/24/MIPI-CSI-2/image-20240423154705649.png" alt="image-20240423154705649"></p></li></ul><h3 id="3-2-Generic-Short-Packet-Data-Type-Codes"><a href="#3-2-Generic-Short-Packet-Data-Type-Codes" class="headerlink" title="3.2 Generic Short Packet Data Type Codes"></a>3.2 Generic Short Packet Data Type Codes</h3><ul><li>主要包含快门开关的时序信息，闪光灯触发等信息的机制。</li></ul><h2 id="4-Packet-Spacing"><a href="#4-Packet-Spacing" class="headerlink" title="4. Packet Spacing"></a>4. Packet Spacing</h2><ul><li><p>CSI-2协议要求在包传输之间需要支持进入和退出LPS状态。</p><ul><li><p>但也有可选的实现方案会在包传输之间仍保持HS状态。</p></li><li><p>包间隔不需要是8bit的整数倍，因为RX端在下一个数据包包头前的SOT序列中重新同步并修正对齐字节边界。</p></li></ul></li><li><p>下图为多数据包传输时Packet Spacing的插入。</p><ul><li><p>Line Blanking 和 Frame Blanking的定义如下图所示。</p></li><li><p>RX端要能处理Line Blanking Period 接近0的情况，在PHY层，为其定义为minimum inter-packet sapcing.</p></li><li><p>TX端定义了Frame Blanking Period的最小时间，并且要求是可编程的。</p><ul><li>建议FS包到第一个数据包之间的间隔以及最后一个数据包到FE包之间的间隔要尽可能接近minimum inter-packet sapcing.</li></ul><p><img src="/2024/04/24/MIPI-CSI-2/image-20240423162813180.png" alt="image-20240423162813180"></p></li><li><p>FS包和FE包的位置可以在Frame Blanking Period内发生变化，以确保可以提供精确到像素级的垂直同步时序信息。</p><ul><li>垂直同步(Vertical Sync)：表示一帧图像的起始是否对齐。</li></ul></li><li><p>LS和LE包的位置可以在Line Blanking Period 内发生变化，以确保可以提供精确到像素级的水平同步时序信息。</p><ul><li>水平同步(Horizontal Sync)：表示一行像素点起始是否对齐。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高速串行总线</category>
      
      <category>MIPI 接口协议</category>
      
      <category>CSI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIPI-CPHY-2</title>
    <link href="/2024/04/18/MIPI-CPHY-2/"/>
    <url>/2024/04/18/MIPI-CPHY-2/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li>C-PHY 2.1 Spec</li><li><a href="https://blog.csdn.net/xianghbo/article/details/128992304">https://blog.csdn.net/xianghbo/article/details/128992304</a></li><li><a href="https://blog.csdn.net/cy413026/article/details/133130068">https://blog.csdn.net/cy413026/article/details/133130068</a></li></ul></li></ul><hr><h2 id="1-传输数据结构"><a href="#1-传输数据结构" class="headerlink" title="1. 传输数据结构"></a>1. 传输数据结构</h2><ul><li>数据格式<ul><li>HS模式下，最小数据单元是16bit。</li><li>LP模式下，最小数据单元是8bit。</li></ul></li><li>在HS模式下，将16bit数据映射为一组7个symbol，分别是s0,s1,s2…s6。<ul><li>其中s6被设置为最高位，s0被设置为最低位。</li><li>先传输s0，之后是s1…s6。</li></ul></li></ul><h3 id="1-1-Encoding-Decoding"><a href="#1-1-Encoding-Decoding" class="headerlink" title="1.1 Encoding, Decoding"></a>1.1 Encoding, Decoding</h3><ul><li><p>参考<a href="https://binbinqian.cn/2024/04/08/MIPI-CPHY-1/">这篇博客</a>中的第1节中Figure3流程图，下面将着重介绍其中部分模块。</p></li><li><p>Encoder相关的发射电路如下图所示。</p><ul><li>其中Transmit Symbol Encoding Logic 模块产生需要发送的Wire State。</li><li>之后通过Transmit Pre-Drivers模块将3bit的Wire State发送出去。</li></ul><p><img src="/2024/04/18/MIPI-CPHY-2/image-20240411104606168.png" alt="image-20240411104606168"></p></li><li><p>Decoder相关的接收电路如下图所示。</p><ul><li>主要包含两部分功能模块：Decoder以及时钟恢复电路。</li><li>Decoder根据查找表、当前UI接收的Wire State以及前一UI接收的Wire State判断Symbol值。</li></ul><p><img src="/2024/04/18/MIPI-CPHY-2/image-20240411112138494.png" alt="image-20240411112138494"></p></li></ul><h2 id="2-Lane-States-and-Line-Levels"><a href="#2-Lane-States-and-Line-Levels" class="headerlink" title="2. Lane States and Line Levels"></a>2. Lane States and Line Levels</h2><ul><li><p>HS Mode &amp; LP Mode</p><ul><li><p>HS-TX始终以差分方式驱动Lane，而LP-TX是独立的驱动Lane中的一根线，并且以单端方式进行。</p><p><img src="/2024/04/18/MIPI-CPHY-2/image-20240411135641293.png" alt="image-20240411135641293"></p></li><li><p>HS和LP模式下Lane的状态码如下表所示。</p><p><img src="/2024/04/18/MIPI-CPHY-2/image-20240411135907249.png" alt="image-20240411135907249"></p></li></ul></li><li><p>Alternate Low-Power(ALP) Mode</p><ul><li><p>ALP Mode除了HS Mode的六种状态外还定义了两种状态：ALP-Pause State和ALP-Pause Wake State。</p></li><li><p>ALP模式下也是差分信号传输。</p></li><li><p>在ALP-Pause模式下，将Lane的三条线设置为相同电压值。</p><ul><li>ALP-Pause可以进一步分为ALP-Pause Stop和ALP-Pause ULPS状态，具体由电平设置决定。</li></ul></li><li><p>Reciever端辨别ALP-Pause State和ALP-Wake State的转化是通过电平转变实现的。</p><p><img src="/2024/04/18/MIPI-CPHY-2/image-20240411140603257.png" alt="image-20240411140603257"></p></li></ul></li></ul><h2 id="3-操作模式"><a href="#3-操作模式" class="headerlink" title="3. 操作模式"></a>3. 操作模式</h2><h3 id="3-1-HS-LP-操作模式"><a href="#3-1-HS-LP-操作模式" class="headerlink" title="3.1 HS &amp; LP 操作模式"></a>3.1 HS &amp; LP 操作模式</h3><ul><li>主要涉及到的几种操作模式包括<ul><li>HS  Data or Calibration Burst</li><li>Turnaround Procedure</li><li>Escape Command</li></ul></li><li>操作状态序列具体可见协议P41.</li></ul><h3 id="3-2-高速数据传输"><a href="#3-2-高速数据传输" class="headerlink" title="3.2 高速数据传输"></a>3.2 高速数据传输</h3><ul><li><p>高速数据以突发形式传输，为了帮助接收端同步，在发射端可以对发送的数据的开始和结束进行扩展(Premable、Post Sequence)。</p></li><li><p>C-PHY中存在与D-PHY相同的SOT和EOT序列，应在突发传输数据的前端和后端。</p></li><li><p>下图为高速数据传输波形图。</p><ul><li><p>LP111-LP001-LP000，标识高速数据传输即将开始。之后关闭低功耗驱动器，打开高速传输驱动器。</p></li><li><p>之后经过t3-PREPARE时间后，开始发送<strong>前导码</strong>。</p><ul><li><p>前导码主要包含三部分：t3-PREBEGIN，t3-PROGSEQ，t3-PREEND.</p></li><li><p>t3-PREBEGIN前几个Wire State可能接收端无法接收，t3-SETTLE之后，接收器启用，可以接收发送端发送的数据，并对其进行解码。</p><ul><li>t3-PREBEGIN是由多组 7个3 组合的，具体数目可由设计者指定。</li></ul></li><li><p>t3-PROGSEQ设计者可选择是否包含，但应注意该部分不可以包含Sync Word, Post sequence, and ALP Codes。下图两张图分别是包含和不包含的情况。</p></li><li><p>t3-PREEND包含了一组7个3的组合。</p></li><li><p>前导码的长度主要取决于接收端电路实现。</p></li></ul></li><li><p>前导码之后是<strong>Sync Word</strong>，其标识了数据包的开始，并可用作数据包的定时对齐。其组合包含4，4，4，4.</p></li><li><p><strong>Post</strong></p><ul><li>当接收器检测到七个连续的’4’，标识Packet Data数据传输完成。可以有多组，取决于接收端电路设计。</li><li>Post状态长度可调，与t3-PREBEGIN类似。</li></ul></li><li><p>在t3-POST结束时，高速传输驱动器关闭，低功耗驱动器打开，并进入状态<strong>LP-111</strong>。</p></li></ul><p><img src="/2024/04/18/MIPI-CPHY-2/image-20240411153813184.png" alt="image-20240411153813184"></p></li></ul><h3 id="3-3-ALP-操作模式"><a href="#3-3-ALP-操作模式" class="headerlink" title="3.3 ALP 操作模式"></a>3.3 ALP 操作模式</h3><ul><li><p>ALP传输情况如下图所示。</p><p><img src="/2024/04/18/MIPI-CPHY-2/image-20240411144637406.png" alt="image-20240411144637406"></p><ul><li><p>（1）高速数据传输以ALP-Pause Stop或ALP-Pause ULPS开始，该阶段，Lane的三根线都被驱动到相同的电平。</p></li><li><p>（2）Transmitter发送”+x“ state 来唤醒Reciever，该阶段被称为ALP-Pause-Wake。</p></li><li><p>（3）Transmitter开始发送前导码。</p><ul><li>前导码是用于同步接收端和发送端的符号序列，可保证正确的数据传输。</li><li>前导码由全3序列&#x2F;全1序列组成，具体由突发传输类型决定。</li></ul></li><li><p>（4）前导码发送之后发送包数据，主要根据传输类型进行划分，如下图所示，共介绍了5种不同情况。</p></li><li><p>（5）在任何突发传输完成之后，Transmitter会发送Stop Code&#x2F;ULPS Code，后续需要发送Post2序列，来通知Reciever需要立即进入ALP-Pause Stop&#x2F;ULPS状态。</p><ul><li>在PHY层，从ALP-Pause ULPS 状态唤醒时间比从 ALP-Pause Stop 状态唤醒时间要更长，这样具有更低的功耗。</li></ul><p><img src="/2024/04/18/MIPI-CPHY-2/image-20240411145600757.png" alt="image-20240411145600757"></p></li></ul></li><li><p>ALP传输种的Code</p><ul><li><p>Trigger Code</p><ul><li>与DPHY相同，Trigger被包含在Escape模式下，在Trans端，LLP通过PPI发送 Trig Code 给 PHY层；在Recie端，PHY层接收，并通过PPI传输给LLP层，作为一个标志，进行操作。</li><li>在ALP模式下，Trigger Code包含Trig 1 Code、Trig 2 Code、Reset Trig、Trig 3 Code、Trig 4 Code 和 Trig 5 Code。</li></ul></li><li><p>Spacer Code（间隔码）</p><ul><li>间隔码可以在前导码之后，Stop&#x2F;ULPS Code之前的任何时间传输。</li><li>间隔码期间并不执行任何操作。</li><li>插入间隔码目的是为了在其它码之间插入间隔，或暂时暂停Lane中的传输。</li></ul></li><li><p>LPDT Start&#x2F;Nibble Code  </p><ul><li>低功耗模式 - Escape Mode - Mode - LPDT（低功耗传输模式）</li><li>LPDT传输格式如 Fig.33 所示，前导码之后是LPDT Start Code，标识着LPDT传输的开始。</li><li>两个LPDT Nibble以1Byte为传输单位，第1个LPDT Nibble是字节LSB 4bit数据编码得到的，第二个LPDT Nibble是字节MSB 4bit数据编码得到的。</li><li>LP Data 被编码为LPDT Nibble序列：S<sub>1</sub>04444S<sub>0</sub>，其中S<sub>0</sub>是LSB Symbol，S1是MSB Symbol。对应表格可以在Spec P56查找。<ul><li>LPDT Nibble 序列是7bit的5进制数据。</li></ul></li></ul></li><li><p>Post1&#x2F;2 Code</p><ul><li>在高速数据传输模式下，协议要求TX端在发送高速数据之后，发送Stop&#x2F;ULPS Code之前，需要发送<strong>Post1</strong>序列。<ul><li>Post1序列的作用在于保证高速数据传输状态与Stop&#x2F;ULPS状态之间存在一个间隔，确保接收端可以准确的识别高速数据突发传输的结束。</li></ul></li><li>在发送Stop&#x2F;ULPS Code之后发送<strong>Post2</strong>序列。<ul><li>Post2序列的作用在于为RX提供足够的时间来确保可以切换到ALP-Pause Stop&#x2F;ULPS状态。</li><li>TX端发送的Post2序列长度取决于RX端的电路设计。</li></ul></li></ul></li></ul></li></ul><h2 id="4-Bi-Directional-Lane-Turnaround"><a href="#4-Bi-Directional-Lane-Turnaround" class="headerlink" title="4. Bi-Directional Lane Turnaround"></a>4. Bi-Directional Lane Turnaround</h2><ul><li>对于双向Lane，它的传输方向可以通过Lane Turnaround操作进行改变。<ul><li>注意，传输方向可以被改变，但是Primary和Secondary不应该改变。</li></ul></li><li>Turnaround可以在两种模式下进行：<ul><li>在低功耗模式下，Control Mode下进行。</li><li>Fast Lane Turnaround.</li></ul></li></ul><h3 id="4-1-Control-Mode-Lane-Turnaround"><a href="#4-1-Control-Mode-Lane-Turnaround" class="headerlink" title="4.1 Control Mode Lane Turnaround"></a>4.1 Control Mode Lane Turnaround</h3><ul><li><p>控制模式下，Lane Turnaround 过程如下。</p></li><li><p>Fig.36 </p><ul><li><p>Primary和Secondary两侧的低功耗时钟周期t<sub>LPX</sub>可能不同，因此协议约束了两侧时钟周期的ratio范围。</p></li><li><p>如果Lane还没有进入TX-LP-Yield状态，可以通过驱动Stop状态来终止Turnaround，Lane将返回Stop状态。</p></li><li><p>如果Lane已进入TX-LP-Yield状态，不可以终止Turnaround。</p><img src="image-20240417222531178.png" alt="image-20240417222531178" style="zoom:67%;" /><img src="image-20240417222555775.png" alt="image-20240417222555775" style="zoom:67%;" /></li></ul></li></ul><h3 id="4-2-Fast-Lane-Turnaround"><a href="#4-2-Fast-Lane-Turnaround" class="headerlink" title="4.2 Fast Lane Turnaround"></a>4.2 Fast Lane Turnaround</h3><ul><li><p>不需要返回低功耗模式，减小了双向通信延迟。</p></li><li><p>传输过程如下图所示。</p><ul><li><p>在高速传输模式下，转向代码(TAC)在Post1 Code 和 Post2 Code之间发送，以此通知RX端将要进行Turnaround。</p></li><li><p>在Post2传输完成之后存在一个转向间隙(TGAP)，完成Primary和Secondary之间传输的转向，并禁用两侧的驱动输出，防止出现争用情况。</p></li><li><p>TGAP之后，反向数据传输开始。</p><p><img src="/2024/04/18/MIPI-CPHY-2/image-20240417225252197.png" alt="image-20240417225252197"></p></li></ul></li><li><p>下图为Control Mode与Fast Lane Mode下传输的比较，可以明显看到两者时间差。</p><p><img src="/2024/04/18/MIPI-CPHY-2/image-20240417230318303.png" alt="image-20240417230318303"></p></li><li><p>下图为Fast Lane Turnaround 详细的事件序列。</p><ul><li><p>其中TAC符号序列为: ‘2144441’，其中LSB：1被先传输，MSB：2被最后传输。</p><ul><li>为了保证传输准确性，可以发送多个TAC序列。</li></ul></li><li><p>当Second Transmitting Devices接收到TAC序列，它开启一个计数器决定TGAP的终止时刻。</p><ul><li>因为TGAP期间没有传输进行，Second Tx 无法确定何时可以开始前导码的传输。</li><li>同时，First Tx端也在发送TAC之后开始计数，以此判断何时终止传输Post2.</li></ul></li></ul><p><img src="/2024/04/18/MIPI-CPHY-2/image-20240417231257190.png" alt="image-20240417231257190"></p></li><li><p>中断Turnaround</p><ul><li>如果Lane还未传输TAC，可以中断Fast Lane Turnaround，此时LLP层可以通过PPI发送一个Stop&#x2F;ULPS码给PHY层，此时Lane将返回到ALP-Pause-Stop&#x2F;ALP-Pause-ULPS状态。</li><li>如果Lane发送了TAC，那么Fast Lane Turnaround无法被终止。</li></ul></li></ul><h2 id="5-Escape-Mode"><a href="#5-Escape-Mode" class="headerlink" title="5. Escape Mode"></a>5. Escape Mode</h2><ul><li><p>下图是以进入Escape Mode下的 Reset Trigger为例。</p><ul><li><p>Lane 通过(LP-111, LP-100, LP-000, LP-001, LP-000)进入Escape Mode。</p><ul><li>如果在最终状态LP-000之前观察到了有LP-111状态，则逃逸模式将被终止。</li></ul></li><li><p>当进入Escape Mode，需要发送一个8bit的Entry Command指定进入具体的某个mode&#x2F;trig。</p></li><li><p>与DPHY一样，CPHY在Escape mode下也是使用Spaced-One-Hot的 encoding 的方式做数据的异步传输。</p><ul><li>Spaced-One-Hot 是由one-hot bit (LP-001&#x2F;LP-010&#x2F;LP-100)和 spaced bit(LP-000)组成.</li><li>CLK可以通过Data Lane解析得到。</li></ul></li><li><p>可以通过Stop状态退出 Escape 模式，但不可以在Escape操作进行时退出。</p><img src="image-20240418105643856.png" alt="image-20240418105643856" style="zoom:67%;" /></li></ul></li><li><p>LPDT</p><ul><li><p>下图为Entry Command指定为LPDT模式，数据将在低功耗模式下进行传输。</p><ul><li>其可以在传输字节之间插入Pause状态。</li><li>使用LPDT，解析出的时钟频率一般小于20MHz。</li></ul><p><img src="/2024/04/18/MIPI-CPHY-2/image-20240418162032041.png" alt="image-20240418162032041"></p></li></ul></li><li><p>ULPS</p><ul><li>当Entry Command指定为ULPS模式，Lane将处于space state(LP-000)。</li></ul></li></ul><h2 id="6-Calibration"><a href="#6-Calibration" class="headerlink" title="6. Calibration"></a>6. Calibration</h2><ul><li>对于工作速率超过3Gbps的数据传输，需要添加校准电路。</li></ul><h3 id="6-1-Calibration-Format"><a href="#6-1-Calibration-Format" class="headerlink" title="6.1 Calibration Format"></a>6.1 Calibration Format</h3><ul><li><p>下图为添加了校准序列与未添加校准序列的对比。</p><ul><li>带校准序列的包是由全’1’组成的，接收机很容易区分于普通传输的前导序列，后者为全’3’序列组成，共有三种格式。</li><li>对于能够根据接收序列进行校准的接收机，可以无需带有校准序列的数据格式，普通格式即可。</li></ul><p><img src="/2024/04/18/MIPI-CPHY-2/image-20240418164207591.png" alt="image-20240418164207591"></p></li><li><p>三种格式具体传输序列如下图所示。</p><ul><li>Format 1<ul><li>仅将前导序列更改为校准序列，校准序列由多组7个’1‘组成，TX端可控校准序列长度。</li></ul></li><li>Format 2<ul><li>将前导序列更改为三部分<ul><li>t<sub>3-CALPREAMBLE</sub>：由全’1’序列组成，其长度范围：1*7-256*7 UI.</li><li>t<sub>3-ASID</sub>：备用序列标识符，由7个UI的3组成，长度固定为7UI，用于告知RX端，备用序列字段即将到来。</li><li>t<sub>3-CALALTSEQ</sub>：备用序列字段，是一组由 PRBS9（Pseudorandom Binary Sequence 9）伪随机序列组成（具体如何生成，可参考协议P86），之后按照CPHY的encoding和mapping，生成Lane上传输的序列。<ul><li>其作用在于在传输过程中提供一种备用的数据模式，用于RX端的校准和自适应。</li><li>其长度范围：1*7-2048*7 UI.</li></ul></li></ul></li></ul></li><li>Format 3<ul><li>将前导序列更改为三部分<ul><li>t<sub>3-CALPREAMBLE</sub>：由全’1’序列组成，其长度范围：1*7-256*7 UI.</li><li>t<sub>3-UDID</sub>：用户定义序列标识符，MSB-LSB：3333313，长度固定为7UI，用于告知RX端，用户定义序列字段即将到来。</li><li>t<sub>3-CALUDEFSEQ</sub>：用户定义序列字段，由用户定义的一系列符号组成。<ul><li>其长度范围：1*7-2048*7 UI.</li></ul></li></ul></li></ul></li></ul><p><img src="/2024/04/18/MIPI-CPHY-2/image-20240418165354247.png" alt="image-20240418165354247"></p></li></ul><h3 id="6-2-Calibration-operation"><a href="#6-2-Calibration-operation" class="headerlink" title="6.2 Calibration operation"></a>6.2 Calibration operation</h3><ul><li>当检测到前导校准序列，校准开始。</li><li>具体校准流程参考协议P89.</li></ul>]]></content>
    
    
    <categories>
      
      <category>高速串行总线</category>
      
      <category>MIPI 接口协议</category>
      
      <category>PHY</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIPI-CPHY-1</title>
    <link href="/2024/04/08/MIPI-CPHY-1/"/>
    <url>/2024/04/08/MIPI-CPHY-1/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li>C-PHY 2.1 Spec</li><li><a href="https://blog.csdn.net/xianghbo/article/details/128992304">https://blog.csdn.net/xianghbo/article/details/128992304</a></li><li><a href="https://blog.csdn.net/cy413026/article/details/133130068">https://blog.csdn.net/cy413026/article/details/133130068</a></li></ul></li></ul><hr><h2 id="1-C-PHY-概述"><a href="#1-C-PHY-概述" class="headerlink" title="1. C-PHY 概述"></a>1. C-PHY 概述</h2><ul><li><p>C-PHY 通过使用一种称为”三相符号编码”技术，三根线A\B\C被称为一个Lane，每根传输2.28bit数据。</p></li><li><p>与DPHY相同，存在两个模式：High-Speed Mode 和 Low Power Mode.</p><ul><li>HS模式用于高速数据传输，电压摆幅较小，如250mV。</li><li>LP模式用于传输控制信号，以及在Escape模式中，可以进行LPDT(低速数据传输)；电压摆幅较大，如1.2V.</li></ul></li><li><p>Lane Signal States</p><ul><li><p>Lane的三根线ABC，假设每根线的电压可以有1&#x2F;4V、3&#x2F;4V、1&#x2F;2V三种情况，那么三根线组合输出有6种情况：+x、-x、+y、-y、+z、-z，如下表所示。</p><p><img src="/2024/04/08/MIPI-CPHY-1/image-20240410161404176.png" alt="image-20240410161404176"></p></li><li><p>从其中一种导线状态到另一导线状态共有五种转换方式，如下图所示。</p><ul><li><p>在C-PHY种，符号值是从一个UI(Unit Interval,equal to the duration of any HS state)到下一个UI导线状态变化的编码。即有5种编码方式，分别是000、001、010、011、100.</p><ul><li>变化规律<ul><li>bit[2]:表示只有线态正负之间的跳变，其他不变，+x与-x之间，+y与-y之间。此时bit[1:0]&#x3D;2’b00，<strong>Flip</strong></li><li>bit[1]: 0表示线态跳变是逆时针，1表示顺时针，<strong>Rotation</strong></li><li>bit[0]: 1表示线态之间极性发生变化，且线态xyz符号也发生了变化，<strong>Polarity</strong></li></ul></li></ul></li><li><p>C-PHY的HS模式下，数据传输的最小单元是两个字节即16bit，而16bit至少需要7个5进制符号进行传输。因此每个符号可传输2.28bit数据。<br>$$<br>log_25&#x3D;2.3219… \<br>7*log_25&#x3D;16.2533\ bit \<br>16&#x2F;7 &#x3D; 2.28…<br>$$<br>​<img src="image-20240410162114755.png" alt="image-20240410162114755" style="zoom:67%;" /></p></li></ul></li></ul></li><li><p>数据传输流程如下图</p><ul><li><p><strong>TX端</strong>，将16bit数据通过Mapper映射为7个5进制的Symbol，共21bit。</p></li><li><p>之后通过并-串转换器，将7个Symbol转化为串行的，输出为3bit。</p></li><li><p>符号编码器根据当前的3bit符号值以及上一个UI Wire State的值，将符号转换为这个UI的Wire State。</p></li><li><p><strong>RX端</strong>，符号解码器根据当前UI的Wire State和上一个UI Wire State，计算出接收到的符号值。</p></li><li><p>之后通过串-并转换器，及Demapper，最后得到16bit数据。</p><p><img src="/2024/04/08/MIPI-CPHY-1/image-20240410165247393.png" alt="image-20240410165247393"></p></li></ul></li></ul><h2 id="2-C-PHY-架构"><a href="#2-C-PHY-架构" class="headerlink" title="2. C-PHY 架构"></a>2. C-PHY 架构</h2><h3 id="2-1-Lane-Module"><a href="#2-1-Lane-Module" class="headerlink" title="2.1 Lane Module"></a>2.1 Lane Module</h3><ul><li><p>通用Lane结构如下图所示，与D-PHY相同，集成了5个功能<code>LP-TX、LP-RX、HS-TX、HS-RX、LP-CD</code>。</p><img src="image-20240410171202996.png" alt="image-20240410171202996" style="zoom:67%;" /></li><li><p>传输方向</p><ul><li><p>C-PHY中定义Primary和Secondary</p><ul><li>对于单向Lane，Primary是数据源那侧，Secondary是接收数据一侧。</li><li>对于双向Lane，数据不仅可以从Primary到Secondary侧，还可以从Secondary接收数据。</li></ul></li><li><p>双向Lane</p><ul><li>Bi-Directional 双向Lane主要有以下两种情况<ul><li>高速模式</li><li>低功耗Escape模式</li></ul></li><li>如果双向Lane模块中HS模式下没有反向功能，那么应该添加LP Escape模式下的反向功能。(似懂非懂)</li><li>如果双向Lane模块中HS模式下有反向功能，那么也应该添加LP Escape模式下的反向功能。</li></ul></li><li><p>几种传输方向配置</p><ul><li><p>（1）下图为多条Lane，正方向数据传输实例。注意，C-PHY规范并不要求所有的Lane都处于活动状态。</p><p><img src="/2024/04/08/MIPI-CPHY-1/image-20240410221053580.png" alt="image-20240410221053580"></p></li><li><p>（2）下图为两条单向通信的Lane，但通信方向相反。</p><ul><li>与双向Lane不同，两个相反方向的Primary和Secondary侧不同。</li><li>可以认为两个Lane是独立的，因此两条Lane之间的比特率不必匹配；但在实际实现中，为方便共享一些信号，最好匹配。</li></ul><p><img src="/2024/04/08/MIPI-CPHY-1/image-20240410221405508.png" alt="image-20240410221405508"></p></li><li><p>（3）下图为多条双向通信的Lane，C-PHY规范并不要求所有的Lane都是相同方向。</p><p><img src="/2024/04/08/MIPI-CPHY-1/image-20240410221724178.png" alt="image-20240410221724178"></p></li><li><p>（4）下图为多条混合模式，混合单向和双向Lane。</p><p><img src="/2024/04/08/MIPI-CPHY-1/image-20240410222027061.png" alt="image-20240410222027061"></p></li></ul></li></ul></li><li><p>下图是具有Control and Interface Logic (CIL)功能的通用Lane模块图。</p><ul><li><p>具体实现可以根据设计要求进行裁剪，具体可参考协议P19.</p><img src="image-20240410203458625.png" alt="image-20240410203458625" style="zoom:80%;" /></li></ul></li></ul><h3 id="2-2-物理层协议接口"><a href="#2-2-物理层协议接口" class="headerlink" title="2.2 物理层协议接口"></a>2.2 物理层协议接口</h3><ul><li><p>一个完整的链路除了Lane Module外，PHY适配层，它将所有的Lane、时钟单元以及协议接口连接在一起。</p><ul><li>其中PPI是每个Lane与PHY适配层的协议接口，APPI是抽象出的物理层协议接口，它包含了所有Lane的接口。</li></ul><p><img src="/2024/04/08/MIPI-CPHY-1/image-20240410201854749.png" alt="image-20240410201854749"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>高速串行总线</category>
      
      <category>MIPI 接口协议</category>
      
      <category>PHY</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIPI-DPHY</title>
    <link href="/2024/04/08/MIPI-DPHY/"/>
    <url>/2024/04/08/MIPI-DPHY/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/caokaiqiang123/article/details/130830837">https://blog.csdn.net/caokaiqiang123/article/details/130830837</a></li><li><a href="https://blog.csdn.net/justlxy/article/details/115453776">https://blog.csdn.net/justlxy/article/details/115453776</a></li></ul></li></ul><hr><h2 id="1-D-PHY-Lane"><a href="#1-D-PHY-Lane" class="headerlink" title="1.D-PHY Lane"></a>1.D-PHY Lane</h2><ul><li><p>可适用于Camera及Display场景。</p></li><li><p>管脚连接</p><ul><li><p>下图为一个Lane的管脚示意图，其包括功能<code>LP-TX、LP-RX、HS-TX、HS-RX、LP-CD</code>。</p><ul><li>其中LP：Low Power，HS：High Speed，CD：Contention-Detectors。</li><li>可以对上面介绍的接口进行剪裁，根据设计选定。</li></ul></li><li><p>最终输出接口为<code>Dp、Dn</code>，为传输的一组差分&#x2F;单端信号，根据LP&#x2F;HS决定。</p><p>​<img src="image-20240408144759780.png" alt="image-20240408144759780" style="zoom:47%;" /></p><p><img src="/2024/04/08/MIPI-DPHY/image-20240408150657333.png" alt="image-20240408150657333"></p></li></ul></li><li><p>D-PHY 时钟</p><ul><li>其时钟为DDR(Double Data Rate)，双边沿采样，采用源同步的传输方式，时钟信号始终由Master提供给Slave。</li></ul></li><li><p>D-PHY Lane 主要由 Clock Lane 和 Data Lane组成，两者有部分特性是相同的，有部分特性是不同的，将在1.1小节介绍。</p></li></ul><h3 id="1-1-相同特性"><a href="#1-1-相同特性" class="headerlink" title="1.1 相同特性"></a>1.1 相同特性</h3><ul><li><p>D-PHY Lane 的模式分为了 2 种：High-Speed &#x2F; Low-Power.</p><ul><li>High-Speed: 用于高速的数据传输，如图像数据传输。</li><li>Low-Power: 用于一些控制信息，如一些指令。</li><li>无论是哪种模式，数据传输都是LSB First、MSB Last.</li></ul></li><li><p>两种模式信号摆幅如下。</p><ul><li>其中HS模式下，Lane上传输的是差分信号，摆幅更小；</li><li>LP模式下，Lane上两根线传输的是<strong>两个独立的信号</strong>，是单端信号，摆幅更大。</li></ul><p><img src="/2024/04/08/MIPI-DPHY/image-20240408152044541.png" alt="image-20240408152044541"></p></li><li><p>传输特性和方向</p><ul><li>对于差分时钟信号，是单向的，Master -&gt; Slave。</li><li>对于数据信号，在HS模式下，均为<strong>单向传输</strong>(Unidirectional)；在LP模式下，允许半双工的<strong>双向传输</strong>(Bi-directional)，反向传输速度只有正向传输的1&#x2F;4.</li><li>在LP模式下(包括Control Mode和Escape Mode)，采用<strong>Spaced-One-Hot Coding</strong>机制。<ul><li>在该机制下，时钟可以在传输的数据中被体现，因此不需要传输时钟，用户可以据此关闭Clock Lane来降低功耗。</li></ul></li></ul></li><li><p>状态码</p><ul><li><p>将Lane两个模式下的两根线不同信号值组合表示不同的状态，后续介绍的模式转变、双向传输均需要组合不同的状态码实现不同的事件。</p><p><img src="/2024/04/08/MIPI-DPHY/image-20240408171404738.png" alt="image-20240408171404738"></p></li></ul></li></ul><h3 id="1-2-D-PHY-Data-Lane-特性"><a href="#1-2-D-PHY-Data-Lane-特性" class="headerlink" title="1.2 D-PHY Data Lane 特性"></a>1.2 D-PHY Data Lane 特性</h3><ul><li><p>LP-HS 模式转变</p><ul><li><p>Data Lane 从LP模式进入HS模式，需要按照协议发送一个 Start-of-Transmission (SOT) Sequence。具体内容可参考D-PHY协议。</p><ul><li>LP Stop state -  HS-Rqst state - Bridge state - HS0 - Inserts HS Sync-Sequence - 继续传数据</li></ul></li><li><p>同样，协议定义了一个End-of-Transmission (EoT) Sequence，推出HS模式，进入LP的Stop模式。</p></li><li><p>可以看到无论是SOT还是EOT序列，除了设置一些状态，对持续时间也有一定要求，防止切换错误。</p><p><img src="/2024/04/08/MIPI-DPHY/image-20240408164142862.png" alt="image-20240408164142862"></p></li></ul></li><li><p>双向传输 (Data Lane Turnaround)</p><ul><li><p>这个操作可以让从机返回数据给主机，同样需要一些状态码进行组合。</p><p><img src="/2024/04/08/MIPI-DPHY/image-20240408170328069.png" alt="image-20240408170328069"></p></li></ul></li><li><p>Escape模式</p><ul><li><p>低功耗模式下主要包含Control Mode和Escape Mode。若将Escape Mode再划分，可以划分为Mode和Trigger。</p><ul><li><p>Mode可以划分为</p><ul><li><p>Low-Power Data Transmission ：简称为 LPDT，意味在 LP 模式下进行数据传输，数据可以在低速情况下进行传输，也可以暂停发送，如下图所示；</p><p><img src="/2024/04/08/MIPI-DPHY/image-20240408185229301.png" alt="image-20240408185229301"></p></li><li><p>Ultra-Low Power State：简称为 ULPS，超低功耗状态；进入该状态后将暂停数据发送，可通过设置LP-10，并等待<code>T_wakeup</code>时间后，即可唤醒。</p></li></ul></li><li><p>Trigger 主要用来触发 Reset。</p></li></ul></li><li><p>进入Escape模式，依然是组合状态码，但若具体到哪个mode&#x2F;trigger，需要添加协议规定的Entry Command。</p></li><li><p>还需注意，由于Escape mode 下使用的是 Spaced-One-Hot bit 的 encoding 的方式做数据的异步传输，因此只需要 Data Lane 就行了，不需要 Clock Lane。</p></li></ul></li></ul><h3 id="1-3-D-PHY-Clock-Lane-特性"><a href="#1-3-D-PHY-Clock-Lane-特性" class="headerlink" title="1.3 D-PHY Clock Lane 特性"></a>1.3 D-PHY Clock Lane 特性</h3><ul><li><p>下图为Clock Lane 和 Data Lane 进入和退出 Low-Power 的时序。</p><ul><li>进入Low-Power：<ul><li>在 Data Lane 进入 Stop State 的时候，再经过 <code>T_clk-post</code> 后，Clock Lane 才进入 HS-0 的状态，然后在 HS-0 持续 Tclk-trail后，进入到 LP-11 状态。</li></ul></li><li>退出Low-Power：<ul><li>Clock Lane 先进入 LP-11，然后进入 LP-01 并位处 Tlpx，然后进入 LP-00 并维持一些时间 Tclk-prepare，然后维持 HS-0 ，时间为 Tclk-zero，之后 Clock Lane 就可以正常工作了；对于Data Lane，在经过 Tclk-pre 后再工作。</li></ul></li></ul><p><img src="/2024/04/08/MIPI-DPHY/image-20240408191224843.png" alt="image-20240408191224843"></p></li><li><p>Clock Lane 没有 Escape 模式，但是 Clock Lane 有 ULPS 模式。</p><ul><li>状态码组合为：<code>LP-11、LP-10、LP-00</code>.</li></ul></li></ul><h2 id="2-错误检测"><a href="#2-错误检测" class="headerlink" title="2. 错误检测"></a>2. 错误检测</h2><ul><li>有些错误可以在D-PHY层就检测出来，而有的错误只能在协议层检测出来。</li></ul><h3 id="2-1-争用检测-Contention-Detection"><a href="#2-1-争用检测-Contention-Detection" class="headerlink" title="2.1 争用检测(Contention Detection)"></a>2.1 争用检测(Contention Detection)</h3><ul><li>如果一个双向的Lane和一个单向模块组合到一起作为一条Lane使用，那么只有单向功能可用，此时需要将双向模块的双向特性禁用掉，否则可能导致死锁的发生。</li><li>对于双向通信的Lane，可能会出现争用。正常情况，连接的两端只能有一端去驱动，但由于故障可能导致两端同时驱动同一个Lane。<ul><li>可能出现下面两种情况<ul><li>(1) Lane的两侧在相互驱动相反的LP电平。</li><li>(2) Lane的一侧在驱动LP-High，一侧则在驱动HS-Low。</li></ul></li><li>对于(1)，可以通过LP-CD和LP-RX组合检测；对于(2)，可以通过LP-RX检测。检测原理与电气规范相关。</li><li>低功耗模式下，当信号稳定后，每个bit周期都需要进行争用检测。</li><li>在ULPS模式下，不需要进行争用检测，因为可能没有可用的时钟，无法判断可检测的周期。</li></ul></li><li>在冲突被检测到之后，协议层要采取适当的措施解决问题。</li></ul><h3 id="2-2-序列错误检测-Sequence-Error-Detection"><a href="#2-2-序列错误检测-Sequence-Error-Detection" class="headerlink" title="2.2 序列错误检测(Sequence Error Detection)"></a>2.2 序列错误检测(Sequence Error Detection)</h3><ul><li>某些原因可能导致Lane信号损坏，接收处的PHY可以检测到signal sequence错误，并通过PPI与协议层进行通信。</li><li>下面是 D-PHY 层可以监测到的 Sequence Error Detection：<ul><li>SoT Error</li><li>SoT Sync Error</li><li>EoT Sync Error</li><li>Escape Mode Entry Command Error</li><li>LP Transmission Sync Error</li><li>False Control Error</li></ul></li></ul><h3 id="2-3-协议层看门狗定时器"><a href="#2-3-协议层看门狗定时器" class="headerlink" title="2.3 协议层看门狗定时器"></a>2.3 协议层看门狗定时器</h3><ul><li>有些错误无法在PHY层被检测出来，因此需要额外的超时机制来限制特定模式和状态的最大持续时间，如果超出该时间，则认为出现问题。</li><li>使用场景如下：<ul><li>HS RX Timeout：HS RX模式下，如果特定时间没有收到 EoT，认为超时</li><li>HS TX Timeout：HS TX模式下，发送时间是有限制的（比如用什么样的速率传输多少个数据），超过特定时间，认为超时。</li><li>Escape Mode Timeout：</li><li>Escape Mode Silence Timeout：</li><li>Turnaround Error：在Turnaround实现过程中，存在一个关键的Turn State转换驱动关系；而看门狗检测的是指定时间内是否出现该状态，若没有，协议层则需要相关操作。</li></ul></li></ul><h2 id="3-Skew-Calibration"><a href="#3-Skew-Calibration" class="headerlink" title="3. Skew Calibration"></a>3. Skew Calibration</h2><ul><li><p>为什么需要Deskew</p><ul><li><p>当传输速度大于1.5Gbps时，CLK Lane 和 Data Lane之间以及Data Lane 和 Data Lane之间可能存在相位偏差，导致容易采样到错误数据。</p></li><li><p>Spec规定当速率大于1.5Gbps时，RX端需要根据TX端发送的特殊的去偏斜(deskew) burst序列完成初始化，之后才能进行数据接收。</p></li><li><p>当速度小于1.5Gbps时，HS-Deskew是可选的，周期性deskew也是可选的。一旦链路速率发生变化，大于1.5Gbps之后，需要重新进行HS-Deskew操作。</p><p><img src="/2024/04/08/MIPI-DPHY/image-20240409142931436.png" alt="image-20240409142931436"></p></li></ul></li><li><p>如何操作</p><ul><li><p>TX端发送一个16bit全部由1组成的同步帧，之后发送序列<code>01010101...0101</code>数据至少持续2<sup>15</sup>个Unit Interval（初始化deskew），或是2<sup>10</sup>（周期化deskew）。</p><ul><li><p>Unit Interval：equal to the duration of any HS state on the Clock Lane.</p><p><img src="/2024/04/08/MIPI-DPHY/image-20240409143248207.png" alt="image-20240409143248207"></p></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高速串行总线</category>
      
      <category>MIPI 接口协议</category>
      
      <category>PHY</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIPI-CCI</title>
    <link href="/2024/04/08/MIPI-CCI/"/>
    <url>/2024/04/08/MIPI-CCI/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li>CSI-2 2.0 Spec</li></ul></li></ul><hr><h2 id="1-CCI（Camera-Control-Interface）"><a href="#1-CCI（Camera-Control-Interface）" class="headerlink" title="1.CCI（Camera Control Interface）"></a>1.CCI（Camera Control Interface）</h2><h3 id="1-1-CCI-主从机定义"><a href="#1-1-CCI-主从机定义" class="headerlink" title="1.1 CCI 主从机定义"></a>1.1 CCI 主从机定义</h3><ul><li>I2C支持多主机多从机传输，但CCI只支持一个主机的传输。</li><li>CCI将CSI的Transmitter配置为Slave，而将Reciever配置为Master。</li></ul><h3 id="1-2-CCI-Message-Types"><a href="#1-2-CCI-Message-Types" class="headerlink" title="1.2 CCI Message Types"></a>1.2 CCI Message Types</h3><ul><li>CCI 传输信息类型包括：Start信号、ACK信号、Stop信号以及从机地址、从机内部寄存器子地址。<ul><li><p>CCI的从机地址位为7bit，8bit DATA传输，以及8bit&#x2F;16bit INDEX传输。   </p><img src="3201119-20230903161249778-1539658959.png" width = 50%/></li></ul></li></ul><h3 id="1-3-读写操作"><a href="#1-3-读写操作" class="headerlink" title="1.3 读写操作"></a>1.3 读写操作</h3><ul><li><p>CCI支持四种读操作和两种写操作，下面展开介绍。</p></li><li><p>（1）随机位置单次读</p><ul><li><p>如下图所示，主机先会发起一个虚拟的写操作，指定好从机地址以及INDEX值后，再发起读操作。至于为什么需要Dummy Write可以看<a href="https://www.cnblogs.com/qianbinbin/p/17489279.html">这篇博客</a>。</p></li><li><p>和I2C一样，更改数据传输方向需要再次发起开始信号Sr，并且主机需要再次给从机的地址，但不需要给INDEX值。</p></li><li><p>完成一次数据读操作之后，将SDA信号拉高表示主机不应答，结束传输。</p><img src="3201119-20230903163440137-201009953.png" width = 50%/></li></ul></li><li><p>（2）随机位置连续读</p><p>​<img src="3201119-20230903224825560-1446970425.png" width = 50%/></p></li><li><p>（3）当前位置单次读</p><ul><li><p>使用的是Previous_index + 1，不需要Dummy Write。 </p><img src="3201119-20230903223348145-837229902.png" width = 50%/></li></ul></li><li><p>（4）当前位置连续读</p><p>​<img src="3201119-20230903224946740-1858592558.png" width = 50%/></p></li><li><p>（5）随机位置单次写 </p><p>​<img src="3201119-20230903225103926-1703203642.png" width = 50%/></p></li><li><p>（6）随机位置连续写</p><ul><li><p>下图中，我认为最后一个Data对应的Index值应为M+L-1。   </p><img src="3201119-20230903225324858-1566777564.png" width = 50%/></li></ul></li></ul><h3 id="1-4-CCI-Multi-Byte-Registers"><a href="#1-4-CCI-Multi-Byte-Registers" class="headerlink" title="1.4 CCI Multi-Byte Registers"></a>1.4 CCI Multi-Byte Registers</h3><ul><li>CSI-2 协议支持以下寄存器宽度<ul><li>8-bits - 常用寄存器宽度</li><li>16bits - parameters like line-length, frame-length and exposure values（曝光值）</li><li>32bits - 用于高精度的寄存器宽度</li><li>64bits - for needs of future sensors</li></ul></li><li>对于寄存器位宽大于8bits，CCI协议传输情况如下图所示。<ul><li>最高数据有效字节(MS Data Byte)对应着Register Index最小值，最低数据有效字节(LS Data Byte)对应着Register Index最大值。</li><li>寄存器第一个字节地址可能与寄存器大小并为对齐，如下第一张图，这是被允许的，但读出数据并不一定正确。<ul><li>寄存器是否需要对齐取决于系统对数据处理效率优化及数据传输带宽优化的权衡。</li></ul></li><li><strong>不允许</strong>对多字节寄存器进行<strong>部分字节访问</strong>，需要按照字节MS-LS之间的顺序访问，如下第二张图。</li><li>读&#x2F;写指令格式与前面介绍的CCI读写相似，区别在于对读&#x2F;写的数据拼接处理。</li></ul></li></ul><p>​<img src="image-20240407201522861.png"  width =67% /></p><p>​<img src="image-20240407202456249.png"  width =67% /></p><p>​<img src="image-20240407205012507.png"  width =67% /></p><ul><li><p>Multi-Byte Read</p><ul><li><p>下面内容并无明确规范要求，可以根据设计更改。</p></li><li><p>为保证读取数据为同一Multi-Byte寄存器中的值，需要插入缓冲区，之后再从缓冲区加载字节序列输出到SDA线上。</p><ul><li><p>如下图所示，在更新到新的Multi-Byte 寄存器(0x01020304)后，缓冲区被刷新。</p><p><img src="/2024/04/08/MIPI-CCI/image-20240407210621957.png" alt="16bit-read"></p></li><li><p>对于更大位宽的寄存器，若仍采用上述缓冲更新策略，可能会出现数据被覆盖的问题，需更改缓冲区更新策略，如下图所示。</p><ul><li>当开始读数据MS Byte时，将Multi-Byte 寄存器中的值全部加载到缓冲区，直到主机发出Start&#x2F;Stop信号之后再重置缓冲区。</li><li>这样可以保证数据读取正确，不会在读取过程中数据被覆盖。</li></ul><p><img src="/2024/04/08/MIPI-CCI/image-20240407211621328.png" alt="2"></p></li></ul></li></ul></li><li><p>Multi-Byte Write</p><ul><li><p>如下图所示，为保证Multi-Byte 寄存器的数据被同时写入，仍需要增加缓冲区。</p></li><li><p>在寄存器LS Data 字节被写入后，完整的多字节值会被传输到对应地址的寄存器中。</p><p><img src="/2024/04/08/MIPI-CCI/image-20240407220514369.png" alt="image-20240407220514369"></p><p><img src="/2024/04/08/MIPI-CCI/image-20240407221313225.png" alt="image-20240407221313225"></p></li></ul></li></ul><h3 id="1-5-CCI-Timing"><a href="#1-5-CCI-Timing" class="headerlink" title="1.5 CCI Timing"></a>1.5 CCI Timing</h3><ul><li><p>CCI 需要考虑的时序约束变量如下图所示。</p><ul><li><p><code>t_R/t_F</code>: Rise time &#x2F; Fall time of both SDA and SCL  signals </p></li><li><p><code>t_BUF</code>: Bus free time between a STOP  and START condition </p></li><li><p><code>t_HD,STA</code>: 检测到SDA从高到低变化(START)时，SCL应需要额外保持高电平这些时间，之后开始产生时钟(SCL)脉冲。</p></li><li><p><code>t_SU,STA</code>: 在Repeated-START信号前，SCL信号应保持为高电平的建立时间。</p></li><li><p><code>t_LOW/t_HIGH</code>: SCL 保持低电平和高电平的周期时间。</p></li><li><p><code>t_SU,DAT/t_HD,DAT</code>: 数据在时钟(SCL)高电平到来之前应保持稳定的建立时间&#x2F;数据在SCL变为低电平之前应保持稳定的保持时间。</p><ul><li>CCI与I2C一样，在SCL为高电平时，接收器从SDA上采样1bit数据，SDA需要保持稳定。关于I2C相关内容可以看<a href="https://binbinqian.cn/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/">这篇博客</a>。</li></ul></li><li><p><code>t_SU,STO</code>: 在SDA从低电平拉高(产生STOP信号），SCL需要保持为高电平的时间。</p><p><img src="/2024/04/08/MIPI-CCI/image-20240408103247979.png" alt="image-20240408103247979"></p></li></ul></li><li><p>总结：建立保持时间与常见的同步时序电路中上升沿采样的一致，关键需要清楚SDA及SCL的<code>开始、停止、采样条件</code>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>高速串行总线</category>
      
      <category>MIPI 接口协议</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Shell - 基础</title>
    <link href="/2024/04/01/Shell-%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/04/01/Shell-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Shell"><a href="#1-Shell" class="headerlink" title="1. Shell"></a>1. Shell</h2><ul><li>shell可认为是一个开机自启动的命令行程序，连接了用户和Linux内核，让用户更加高效的使用Linux内核。<ul><li>shell 中每执行一个指令可以认为是执行一个子程序。</li></ul></li><li>重定向<ul><li><code>&lt;file</code>和<code>&gt;file</code>，分别将程序的输入和输出流重定向到文件。</li><li><code>&gt;&gt;file</code>向一个文件追加内容。</li><li><code>|</code>允许将一个程序的输出和另一个程序的输入连接起来。</li></ul></li></ul><h2 id="2-Bash"><a href="#2-Bash" class="headerlink" title="2. Bash"></a>2. Bash</h2><h3 id="2-1-工具与脚本"><a href="#2-1-工具与脚本" class="headerlink" title="2.1 工具与脚本"></a>2.1 工具与脚本</h3><ul><li><p>为变量赋值，<code>foo=bar</code>，但注意不能是<code>foo = bar</code>，空格的存在让解释器误将<code>=</code>和<code>bar</code>作为参数。</p><ul><li>因此在shell脚本中，空格会起到分割参数的作用，使用时需要注意。</li></ul></li><li><p><code>&#39;</code>和<code>&quot;</code></p><ul><li><p>以<code>&#39;</code>定义的字符串为原义字符串，其中的变量不会被转义</p></li><li><p>而 <code>&quot;</code>定义的字符串会将变量值进行替换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">foo=bar<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$foo</span>&quot;</span><br><span class="hljs-comment"># 打印 bar</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$foo&#x27;</span><br><span class="hljs-comment"># 打印 $foo</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>$</code></p><ul><li><p>访问变量中存储的数值使用的语法是<code>$</code>，如<code>$foo</code>。</p></li><li><p>还可以通过命令替换实现，即以变量的形式获取一个命令的输出。</p><ul><li><code>for file in $(ls)</code>，shell首先调用ls，遍历得到ls的返回值。</li></ul></li><li><p>进程替换</p><ul><li><p><code>&lt;(CMD)</code> 会执行指令CMD，并将结果输出到一个临时的文件中，并将<code>&lt;(CMD)</code>替换成临时文件名。</p></li><li><p>举例：<code>diff &lt;(ls foo) &lt;(ls bar)</code>，会显示文件夹foo与bar中文件的区别，注意只会比对文件名称，不会比对文件内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> foo/x bar/y<br><span class="hljs-comment"># 比较文件夹 foo 和 bar 中包含文件的不同</span><br>diff &lt;(<span class="hljs-built_in">ls</span> foo) &lt;(<span class="hljs-built_in">ls</span> bar)<br><span class="hljs-comment"># 输出</span><br><span class="hljs-comment"># &lt; x</span><br><span class="hljs-comment"># ---</span><br><span class="hljs-comment"># &gt; y</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>shell 的通配</p><ul><li><p>？与 *</p><ul><li>举例：foo,foo1,foo2,foo10,bar.</li><li>rm foo? 会删除掉foo1,foo2。</li><li>rm foo* 则会只留下bar。</li></ul></li><li><p>{}</p><ul><li><p>当有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">convert image.&#123;png,jpg&#125;<br><span class="hljs-comment"># 会展开为</span><br>convert image.png image.jpg<br><br><span class="hljs-built_in">cp</span> /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath<br><span class="hljs-comment"># 会展开为</span><br><span class="hljs-built_in">cp</span> /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath<br><br><span class="hljs-comment"># 也可以结合通配使用</span><br><span class="hljs-built_in">mv</span> *&#123;.py,.sh&#125; folder<br><span class="hljs-comment"># 会移动所有 *.py 和 *.sh 文件</span><br><br><span class="hljs-built_in">mkdir</span> foo bar<br><span class="hljs-comment"># 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件</span><br><span class="hljs-built_in">touch</span> &#123;foo,bar&#125;/&#123;a..h&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>在终端，可以运行的脚本并不一定必须是bash</p><ul><li><p>例如，可以用python脚本，在脚本第一行Shebang，告知了内核应用python解释器而不是shell命令。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/local/bin/python</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(sys.argv[<span class="hljs-number">1</span>:]):<br>    <span class="hljs-built_in">print</span>(arg)<br></code></pre></td></tr></table></figure><ul><li><p>使用env命令，也可编写Shebang行，如<code>#!/usr/bin/env python</code>，告诉内核应去环境变量$PATH包含的路径中寻找，选择最先找到的使用。</p></li><li><p>两种写法的优缺点可以参考<a href="https://blog.csdn.net/qq_37164975/article/details/106181500">这篇文章</a>.</p></li></ul></li></ul></li><li><p>查找文件</p><ul><li><p><code>find</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找所有名称为src的文件夹</span><br>find . -name src -<span class="hljs-built_in">type</span> d<br><span class="hljs-comment"># 查找所有文件夹路径中包含test的python文件</span><br>find . -path <span class="hljs-string">&#x27;*/test/*.py&#x27;</span> -<span class="hljs-built_in">type</span> f<br><span class="hljs-comment"># 查找前一天修改的所有文件</span><br>find . -mtime -1<br><span class="hljs-comment"># 查找所有大小在500k至10M的tar.gz文件</span><br>find . -size +500k -size -10M -name <span class="hljs-string">&#x27;*.tar.gz&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>fd&#x2F;locate</p></li></ul></li><li><p>查找代码</p><ul><li><p>grep</p><ul><li><code>-C</code> ：获取查找结果的上下文（Context）；<code>grep -C 5</code> 会输出匹配结果前后五行。</li><li><code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。</li><li>当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。</li></ul></li><li><p>ack&#x2F;ag&#x2F;rg</p><ul><li><p>rg(ripgrep)，相较于grep更快，举例如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找所有使用了 requests 库的文件</span><br>rg -t py <span class="hljs-string">&#x27;import requests&#x27;</span><br><span class="hljs-comment"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span><br>rg -u --files-without-match <span class="hljs-string">&quot;^#!&quot;</span><br><span class="hljs-comment"># 查找所有的foo字符串，并打印其之后的5行</span><br>rg foo -A 5<br><span class="hljs-comment"># 打印匹配的统计信息（匹配的行和文件的数量）</span><br>rg --stats PATTERN<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>查找shell命令</p><ul><li>可以组合使用history以及grep来寻找之前输入的指令。<ul><li>history |grep find 会打印包含find字串的指令。</li></ul></li><li>或使用Ctrl+R来对历史记录进行回溯搜索。</li></ul></li></ul><h3 id="2-2-任务控制"><a href="#2-2-任务控制" class="headerlink" title="2.2 任务控制"></a>2.2 任务控制</h3><ul><li>结束进程<ul><li>当我们输入Ctrl-C时，shell会发送一个SIGINT信号到进程。但可能会被忽略，无法让程序停止。</li><li>当我们输入Ctrl-\时，shell会发送一个SIGQUIT信号到进程。</li><li>SIGTERM是一个更加通用的退出信号，我们需要使用kill命令，语法是<code>kill -TERM &lt;PID&gt;</code>.<ul><li>查看PID可以通过指令<code>ps aux |grep &lt;进程名&gt;</code>，其中aux参数表示列出所有用户的所有进程。</li></ul></li></ul></li><li>暂停后台执行进程<ul><li>输入Ctrl-Z，会让shell发送SIGTSTP信号，Terminal Stop缩写。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>命名 - 未命名语句块</title>
    <link href="/2024/01/06/%E5%91%BD%E5%90%8D&amp;%E6%9C%AA%E5%91%BD%E5%90%8D%E8%AF%AD%E5%8F%A5%E5%9D%97/"/>
    <url>/2024/01/06/%E5%91%BD%E5%90%8D&amp;%E6%9C%AA%E5%91%BD%E5%90%8D%E8%AF%AD%E5%8F%A5%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="1-命名块中的局部变量"><a href="#1-命名块中的局部变量" class="headerlink" title="1. 命名块中的局部变量"></a>1. 命名块中的局部变量</h2><ul><li><p>Verilog 允许在命名的 <code>begin...end</code> 或 <code>fork...join</code> 块中声明局部变量。</p><ul><li><p>该局部变量一般可用作循环控制。</p></li><li><p>该局部变量即使和模块级声明的变量同名，但是互不影响，举例如下。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> chip(<span class="hljs-keyword">input</span> clk);<br>    <span class="hljs-keyword">integer</span> i;<span class="hljs-comment">//模块级声明</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <br>    <span class="hljs-keyword">begin</span>: loop<span class="hljs-comment">//命名块</span><br>        <span class="hljs-keyword">integer</span> i;<span class="hljs-comment">//局部变量</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">127</span>;i=i+<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>           ... <br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>在命名块中声明的局部变量可以使用层次路径引用出来，用在测试&#x2F;验证程序中。</p><ul><li><p>举例如下</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;chip.i=%0d&quot;</span>,chip<span class="hljs-variable">.i</span>);<br><span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;chip.loop.i=%0d&quot;</span>,chip<span class="hljs-variable">.loop</span><span class="hljs-variable">.i</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2-未命名块中的局部变量"><a href="#2-未命名块中的局部变量" class="headerlink" title="2. 未命名块中的局部变量"></a>2. 未命名块中的局部变量</h2><ul><li><p>System Verilog 扩展了 Verilog，允许在未命名块中声明变量，举例如下。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> chip(<span class="hljs-keyword">input</span> clk);<br>    <span class="hljs-keyword">integer</span> i;<span class="hljs-comment">//模块级声明</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <br>    <span class="hljs-keyword">begin</span>     <span class="hljs-comment">//未命名块</span><br>        <span class="hljs-keyword">integer</span> i;<span class="hljs-comment">//局部变量</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">127</span>;i=i+<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>           ... <br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></li><li><p>由于块没有名字，不能被层次化引用。</p></li><li><p>但在未命名块中声明局部变量，可以保护局部变量不被外部引用。</p></li><li><p>Verilog 中不允许在未命名块中声明局部变量，如下图。</p><ul><li>但是对于UDP，允许未命名域声明变量。</li></ul><img src="image-20240106113937416.png" alt="image-20240106113937416" style="zoom:67%;" /></li></ul>]]></content>
    
    
    <categories>
      
      <category>System Verilog</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>param-相关用法</title>
    <link href="/2024/01/05/param-%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95/"/>
    <url>/2024/01/05/param-%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://worktile.com/kb/ask/19107.html">https://worktile.com/kb/ask/19107.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/420873197">https://zhuanlan.zhihu.com/p/420873197</a></li></ul></li></ul><hr><h2 id="1-Verilog"><a href="#1-Verilog" class="headerlink" title="1. Verilog"></a>1. Verilog</h2><h3 id="1-1-parameter"><a href="#1-1-parameter" class="headerlink" title="1.1 parameter"></a>1.1 parameter</h3><ul><li><p>声明</p><ul><li>可以被声明为integer、real、realtime、time四种类型。</li><li>可以声明parameter的位宽。</li><li>可以使用表达式来计算它的值，注：这部分的计算应是在预编译就完成的，不会被综合成实际的电路资源。</li></ul></li><li><p>修改方式</p><ul><li><p>在例化模块端口时，可以在例化层修改传递参数的值。</p></li><li><p>使用defparam修改其它层次例化模块的参数值。举例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">parameter</span> [ <span class="hljs-keyword">signed</span> ] [ range ] list_of_param_assignments <br><br><span class="hljs-comment">//模块实体中声明的参数</span><br><span class="hljs-keyword">module</span> module_name();<br><span class="hljs-keyword">parameter</span> A1 = <span class="hljs-number">2&#x27;d1</span>;<span class="hljs-comment">//一般用大写字母,defparam可以修改，#(.A1(4))可以修改</span><br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-comment">//或者</span><br><span class="hljs-comment">//模块在端口声明时声明的参数 </span><br><span class="hljs-keyword">module</span> module_name<br>#(<span class="hljs-keyword">parameter</span> A2 = <span class="hljs-number">2&#x27;d1</span>)<span class="hljs-comment">// #(.A2(4))可以修改，defparam也可以修改</span><br>(<br>   <br>);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><ul><li><p>格式：<code>defparam inst.param1 = const</code>，该语句一般情况下不可综合，可以在测试时使用。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">defparam</span> f1<span class="hljs-variable">.A</span> = <span class="hljs-number">3</span><span class="hljs-variable">.1415</span>;<br><span class="hljs-keyword">defparam</span> f1<span class="hljs-variable">.B</span> = <span class="hljs-number">3</span><span class="hljs-variable">.1415</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="1-2-localparam"><a href="#1-2-localparam" class="headerlink" title="1.2 localparam"></a>1.2 localparam</h3><ul><li><p>声明与parameter相同。</p></li><li><p>修改方式</p><ul><li>localparam指定的参数不可以通过defparam进行修改。</li><li>由于localparam只可以在module内部使用，不可以进行参数传递，因此其也不可以通过例化时修改参数的值。</li><li>但是localparam指定的参数可以通过parameter赋值修改，这样可以利用parameter的修改方式修改localparam。</li></ul></li><li><p>除了上面介绍的两种，还有<strong>specparam</strong>，其只能在 <strong>specify</strong> 块内部使用，可以用于定义延迟数值常量。具体可以见<a href="https://www.runoob.com/w3cnote/verilog2-specify.html">这篇文章</a>。</p></li></ul><h2 id="2-System-Verilog"><a href="#2-System-Verilog" class="headerlink" title="2. System Verilog"></a>2. System Verilog</h2><ul><li>在包中，parameter 不能被重新定义，因为他不是模块的一部分。<ul><li>不同于上面介绍的 Verilog 模块中的parameter。 </li><li>在包中，parameter和localparam是相同的。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>硬件设计基础</category>
      
      <category>语法补记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>包</title>
    <link href="/2024/01/05/%E5%8C%85/"/>
    <url>/2024/01/05/%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li>Verilog 中，模块内声明的对象相对于模块是<strong>局部</strong>的。<ul><li>虽然在验证时，允许层次引用其它模块的对象，但是这并不代表硬件行为，是不可综合的。</li><li>如果一个声明在多个模块中都被用到，那么必须要在每个块中都进行声明。</li></ul></li><li>为了使多个模块共享用户定义类型的定义，System Verilog 增加了包的概念。</li><li>包中可以包含的<strong>可综合的结构</strong>有<ul><li>parameter&#x2F;localparam常量定义</li><li>const 变量定义</li><li>typedef 用户定义类型</li><li>task&#x2F;function 定义</li><li>其它包的import语句</li><li>操作符重载定义</li></ul></li><li>包是一个独立的声明空间，不需要包含在Verilog模块中。</li></ul><h2 id="2-unit-编译单元声明"><a href="#2-unit-编译单元声明" class="headerlink" title="2. $unit 编译单元声明"></a>2. $unit 编译单元声明</h2><ul><li><p>编译单元</p><ul><li><p>SystemVerilog 添加了编译单元的概念，为软件工具提供了针对设计中各个子块单独编译的方法。</p><ul><li>一个子块可能包含了一个&#x2F;多个module，还可能包含接口块和测试程序块。</li></ul></li><li><p>SystemVerilog 允许在包、模块、接口和程序块的外部进行声明，扩展了Verilog的声明域。</p><ul><li>这些外部声明都在编译单元域中，对所有同时编译的模块都是可见的。</li></ul></li><li><p>编译单元域可以包含下面内容</p><ul><li>时间单位和精度声明</li><li>包导入（可综合）</li><li>变量声明</li><li>net声明</li><li>常量声明（parameter和localparam可综合，最好不要放在编译单元域，因为常量声明文件和模块文件是分开编译的，这些常量对模块是不可见的）</li><li>用户定义数据类型，使用typedef&#x2F;enum&#x2F;class 等（可综合，但最好将定义放到包内，降低风险）</li><li>任务和函数定义（自动函数、自动任务可综合）</li></ul></li></ul></li><li><p>编译单元域声明 &amp; 全局声明</p><ul><li>全局声明：无论源文件是单独&#x2F;同时编译，都会被设计的所有模块共享。</li><li>编译单元域声明：只作用于<strong>同时编译的源文件</strong>，每次编译源文件，就创建一个唯一仅针对此次编译的编译单元域。<ul><li>举例：两个模块都想引用外部声明的A变量，如果两者同时编译，那么A变量，两者共用；如果两者不同时编译，那么A变量只会被其中一个编译单元域使用，另一个可能会出错。但这两个模块的A信号不是相连的。</li></ul></li></ul></li><li><p>编码指导</p><ul><li>不要在$unit空间进行任何声明，所有的声明都要在包内进行。</li><li>必要时，例如第3节中提到的第（4）种方法，可以将包中的子项<strong>导入</strong>到$unit域中。<ul><li>注意，这里是导入，而不是声明。</li><li>如果说模块&#x2F;接口的<strong>多个</strong>端口 都是 使用的包中用户自定义类型，这个用户自定义类型又十分有用，那么可以实现。</li></ul></li></ul></li><li><p>System Verilog 标识符搜索规则</p><ul><li><p>软件工具先搜索模块&#x2F;接口内的局部定义和声明。</p></li><li><p>之后搜索包中指定子项名称的导入。</p></li><li><p>之后在通配符导入的包中搜索。</p></li><li><p>搜索编译单元域中的声明。</p></li><li><p>搜索设计层次中的声明。</p></li></ul></li><li><p>数据标识符和类型标识符必须在引用前声明，如果未声明，那么会遵循Verilog的隐式类型(net&#x2F;wire)规则。</p></li></ul><h2 id="3-引用包的内容"><a href="#3-引用包的内容" class="headerlink" title="3. 引用包的内容"></a>3. 引用包的内容</h2><ul><li>模块和接口可以用四种方式引用包中的定义和声明，如下。</li></ul><h3 id="3-1-使用作用域解析操作符"><a href="#3-1-使用作用域解析操作符" class="headerlink" title="3.1 使用作用域解析操作符(::)"></a>3.1 使用作用域解析操作符(::)</h3><ul><li><p>举例，下面的代码实现引用 <code>definitions</code> 包 中定义的ADD子项。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">definitions::ADD<br></code></pre></td></tr></table></figure></li><li><p>不足：当包中的一项或多项需要在模块中多次引用时，每次都使用::引用太过麻烦。</p></li></ul><h3 id="3-2-导入包中的特定子项"><a href="#3-2-导入包中的特定子项" class="headerlink" title="3.2 导入包中的特定子项"></a>3.2 导入包中的特定子项</h3><ul><li><p>使用import语句将包中特定的子项导入到模块&#x2F;接口中。</p><ul><li><p>导入后，该子项为模块&#x2F;接口内可见的，引用时可以直接使用子项名，而不用加包名。</p></li><li><p>举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> ALU();<br>    <span class="hljs-keyword">import</span> definitions::ADD;<br>    <span class="hljs-keyword">always_comb</span> <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">case</span>(IW<span class="hljs-variable">.opcode</span>)<br>            ADD:<br>        <span class="hljs-keyword">endcase</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>不足：导入枚举类型定义时，并不导入那个定义所使用的元素。其中的枚举元素需要一个一个import。</p><ul><li><p>举例如下：</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;ADD,SUB,MUL&#125; opcodes_t;<br><br><span class="hljs-keyword">import</span> definitions::opcodes_t;<br><span class="hljs-comment">//导入枚举类型定义时，只会让这个类型在模块中可见，不会让其中的枚举元素可见。</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-3-包中子项的通配符导入"><a href="#3-3-包中子项的通配符导入" class="headerlink" title="3.3 包中子项的通配符导入"></a>3.3 包中子项的通配符导入</h3><ul><li><p>为了避免（2）中一个一个导入，System Verilog 允许包中的子项使用通配符导入，而不需要特意指定包中子项的名称。</p><ul><li><p>举例</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> definitions::*; <span class="hljs-comment">//通配符导入</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>通配符导入也并不是自动导入包中所有的内容，只有在模块或接口中被实际使用到的子项才会被真正导入。</p></li><li><p>不足：举例如下，对于模块端口的定义，仍需要显示引用，因为在端口定义前，不能在模块内部加入import语句。但是可以使用$unit声明域来避免这个问题。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> ALU(<br><span class="hljs-keyword">input</span> definitions::instruction_t IW,<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span> clk,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] result<br>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-4-将包中子项导入到-unit声明域中"><a href="#3-4-将包中子项导入到-unit声明域中" class="headerlink" title="3.4 将包中子项导入到$unit声明域中"></a>3.4 将包中子项导入到$unit声明域中</h3><ul><li><p>见第2节内容介绍。</p></li><li><p>举例如下</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//使用特定子项导入</span><br><span class="hljs-keyword">import</span> definitions::instruction_t;<br><span class="hljs-comment">//或是使用通配符导入</span><br><span class="hljs-keyword">import</span> definitions::*;<br><span class="hljs-keyword">module</span> ALU(<br><span class="hljs-keyword">input</span> instruction_t IW,<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span> clk,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] result<br>);<br></code></pre></td></tr></table></figure></li><li><p>文件顺序编译依赖性</p><ul><li>import语句必须出现在包中子项被引用之前。</li><li>如果import语句和引用的模块&#x2F;接口不在同一个文件中，那么需要保证import语句所在文件要在文件编译顺序首先被列出。</li></ul></li><li><p>多文件编译和单文件编译</p><ul><li><p>当多个文件同时进行编译时，只有一个unit域，此时包导入到unit域中使得包中子项对文件中的所有模块和接口都可见。</p></li><li><p>但是若这些文件单独编译，那么会产生多个不同的unit编译单元，此时一个unit中导入的包对其它unit是不可见的。解决方法如下：</p><ul><li><p>将import语句放到每个文件模块或接口定义之前。</p><ul><li><p>注意：对于每个文件单独编译时很奏效，但是当多个文件同时编译时，如果出现将同样的包中子项多次导入到一个$unit域中是非法的。</p></li><li><p>因此，对于多个文件同时编译时，可以利用条件编译：第一次遇到导入语句时，将其编译到$unit中；后面再出现时，检查包的编译标志设置，如果已经被编译，则忽略。下面举例为带条件编译的包：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">ifndef</span> DFF_DONE  </span><span class="hljs-comment">//如果没设置已编译标志</span><br>  <span class="hljs-meta">`<span class="hljs-keyword">define</span> DFF_DONE </span><span class="hljs-comment">//设置该标志</span><br>  <span class="hljs-keyword">package</span> definitions;<br>        ...<br>    <span class="hljs-keyword">endpackage</span><br>  <span class="hljs-keyword">import</span> definitions::*; <span class="hljs-comment">//将包导入到$unit中</span><br><span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>每个需要包中子项的设计或测试平台都应该将&#96;&#96;include “definitions.pkg”&#96;放在文件的开始。</p><ul><li>这样包和导入语句会被编译到设计或测试平台块正在使用的$unit域中。</li><li>进行每个文件单独编译时，包被编译并导入到每个$unit编译单元中，之间也不会出现名称冲突。</li><li>进行多文件编译时，条件编译可以保证包只进行一次编译和导入，并且进入共享的公共$unit编译域。</li></ul></li></ul></li></ul><h3 id="3-5-如何使其可综合"><a href="#3-5-如何使其可综合" class="headerlink" title="3.5 如何使其可综合"></a>3.5 如何使其可综合</h3><ul><li>为了能综合，包中定义的<strong>任务&#x2F;函数</strong>必须声明为 <code>automatic</code>。<ul><li>因为只有自动任务&#x2F;函数的存储区在每次调用时才会分配。因此，当A模块引用包中的自动任务&#x2F;函数时，可以看到其对应的存储区的唯一副本，而其它模块看不到。</li><li>这样可以保证综合前的仿真行为和综合后的一致。</li></ul></li><li>包中<strong>变量</strong>的声明不可以综合<ul><li>对于多文件编译<ul><li>包被导入到同一个$unit编译域中，每个设计快&#x2F;测试块都将看到相同的包中变量，一个块修改变量将传递给所有的设计块&#x2F;测试块。</li><li>这类不通过模块端口就实现模块间的数据通信是不可综合的。</li></ul></li><li>对于单文件编译<ul><li>每个unit域都有一个唯一的变量，恰好与其它unit域的变量同名。一个设计块&#x2F;测试块对包中变量写入的值，其它的模块不可见。</li></ul></li></ul></li><li>包中若有静态任务和函数或者含静态存储的自动任务和函数，也是不可综合的。与上面问题一致。<ul><li>多文件编译中，只有一个$unit域，因此任务&#x2F;函数中的静态存储对所有设计和验证块都是可见的。</li><li>单文件编译中，每一个独立的$unit域导入的任务&#x2F;函数实例不同，任务和函数的静态存储也不会在设计和测试块中共享。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>System Verilog</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SerDes_PCS</title>
    <link href="/2023/12/20/SerDes_PCS/"/>
    <url>/2023/12/20/SerDes_PCS/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/166179584">https://zhuanlan.zhihu.com/p/166179584</a></li><li><a href="https://zhuanlan.zhihu.com/p/446246685">https://zhuanlan.zhihu.com/p/446246685</a></li><li><a href="https://blog.csdn.net/Pieces_thinking/article/details/88849228">https://blog.csdn.net/Pieces_thinking/article/details/88849228</a></li><li><a href="https://blog.csdn.net/Pieces_thinking/article/details/119881292">https://blog.csdn.net/Pieces_thinking/article/details/119881292</a></li><li><a href="https://www.mindshare.com/files/resources/mindshare_pcie_elastic_buffer.pdf">https://www.mindshare.com/files/resources/mindshare_pcie_elastic_buffer.pdf</a></li><li><a href="https://zhuanlan.zhihu.com/p/159452714">https://zhuanlan.zhihu.com/p/159452714</a></li></ul></li></ul><h2 id="1-8B-10B-编解码电路"><a href="#1-8B-10B-编解码电路" class="headerlink" title="1. 8B&#x2F;10B 编解码电路"></a>1. 8B&#x2F;10B 编解码电路</h2><ul><li>对于大部分高速串行接口，在串行链路上会加入一个AC耦合电容，除了耦合电容，交流耦合器还需一个RC组成的高通滤波器，如下图所示。<ul><li>当输入信号多个周期布发生变化时，信号电平值可能会发生衰减，发生误码。</li><li>对于输入信号变化较快的情况，衰减不明显，不会发生误码的情况。</li></ul></li></ul><p><img src="/2023/12/20/SerDes_PCS/v2-d8dbd57f3a7e57623d3ae961e6db53d5_b.webp"></p><ul><li><p>高速串行接口为什么需要AC 耦合电容？</p><ul><li>如果两个通信系统的供电电压不一致，那么插入AC 耦合电容，可以隔直流，使交流信号归到DC&#x3D;0轴。</li><li>AC耦合电容可以提供 直流偏压以及过流保护。</li><li>信号传输时，可能会有直流分量被串扰进去，经过AC 耦合电容，眼图更好。</li></ul></li><li><p>编码方式详解</p><ul><li>8B&#x2F;10B 编码 实现 所有的1&#x2F;0的个数不会超过6个，连续的1&#x2F;0的个数不会超过4个。<ul><li>有256个数据码以及12个K码控制码，这样数据码和控制码不会重合。</li></ul></li></ul><p><img src="/2023/12/20/SerDes_PCS/1.png"></p><ul><li><p>编码前的数据以字节为单位，数据从高位到低位，分别用HGFEDCBA表示.</p><ul><li>将该8bit数据分为两部分，其中低5bit进行5B&#x2F;6B编码，高3bit进行3B&#x2F;4B编码。</li><li>下面Table2 为5B&#x2F;6B 编码表格<ul><li>D命名方式与下面介绍的K码相同。</li><li>表中的RD为 Running Disparity，是对编码后数据Disparity的统计。<ul><li>当为+1时，表示1比0多，当为-1时，表示0比1多。</li><li>RD的两个值对应着两种编码方式，选择哪种编码方式由当前RD值决定，举例如下。<ul><li>当前RD值为负，那么此时输入按照RD&#x3D;-1方式编码；同时检验当前编码是否为完美编码（0和1的个数相同），如果是完美编码，那么保持RD的极性不变。</li><li>对于RD值为正数的，编码方式与上面一致。</li></ul></li></ul></li><li>根据表中的编码结果，可以看到<code>1</code> 的个数和<code>0</code> 的个数的差值Disparity只有三种：<code>+2/-2/0</code>.<ul><li><code>Disparity=0</code> 时即是完美编码，此时保持RD不变就可以。</li></ul></li></ul></li></ul><p><img src="/2023/12/20/SerDes_PCS/format,png-1702620133181-8.png"></p><p><img src="/2023/12/20/SerDes_PCS/format,png-1702625018878-11.png"></p><p><img src="/2023/12/20/SerDes_PCS/format,png-1702625037907-14.png"></p></li><li><p>Comma (K) 码</p><ul><li>接收到的串行数据流需要经过串并转换器进行转换，K码中有些就是用来判断每个字节数据边界的。举例：K28.5(0xBC).<ul><li>接收器在输入的数据流中搜寻特定的比特序列，如果找到该序列，那么解串器根据Comma码调整字节边界。</li><li>考虑到正常传输的数据中可能也有K码的数值（例如0xBC），一般通过一根额外的控制线来进行区分当前传输的是K码还是数据，再分别按照各自的编码方式进行编码。</li></ul></li><li>K码 (Comma)字符 Kx.y 的命名规则如下:<ul><li>x：低 5bit 数据十进制数值。</li><li>y：高 3bit 数据十进制数值。</li><li>举例 K28.5：<code>8&#39;b101_11100</code>.</li></ul></li></ul><p><img src="/2023/12/20/SerDes_PCS/format,png-1702630961651-17.png"></p></li></ul></li></ul><h2 id="2-扰码-Scrambing"><a href="#2-扰码-Scrambing" class="headerlink" title="2. 扰码 (Scrambing)"></a>2. 扰码 (Scrambing)</h2><h3 id="2-1-关于扰码"><a href="#2-1-关于扰码" class="headerlink" title="2.1 关于扰码"></a>2.1 关于扰码</h3><ul><li><p>扰码的作用</p><ul><li><p>一些重复出现的序列，频域上为高频离散频谱，会产生较强的EMI。但当经过扰码后，数据被随机化，EMI噪声会被大大减弱。</p></li><li><p>由于扰码可以让功率谱分布更为平滑和均匀，因此可以一定程度上减少高频串扰。</p></li><li><p>加扰也可以解决上面提到的直流平衡问题，并且不需要像8B&#x2F;10B编码技术一样，增加带宽的开销。</p><ul><li><p>例如，8B时，需要2.5Gb的带宽，那么编码成10B时，就需要3.125Gbps ((2.5&#x2F;8)*10) 的线速率。</p></li><li><p>但是8B&#x2F;10B等线路编码方案可以提供其他任务是扰码无法实现的。</p><ul><li>字对齐</li><li>时钟校正机制</li><li>通道绑定机制</li><li>子通道创建</li></ul></li><li><p>尽管上面后三种任务某些情况并不需要，但是肯定会需要字对齐。扰码也有自己的字对齐方式。</p><ul><li><p>如下图，可以在划分一些数据边界值用于字对齐等控制，该部分控制字不可用于数据传输。</p><img src="64489034a35d664589.png" style="zoom:75%;" /></li></ul></li></ul></li></ul></li><li><p>具体实现可以用LFSR电路实现，用于产生伪随机序列x(n)，并与串行输入的数据y(n)进行异或操作得到z(n)，从而实现输入数据的随机化。</p></li><li><p>解扰电路：使用扰码后的数据z(n)与LFSR产生的随机序列x(n)进行异或之后得到原数据y(n).</p></li></ul><h3 id="2-2-LFSR"><a href="#2-2-LFSR" class="headerlink" title="2.2 LFSR"></a>2.2 LFSR</h3><ul><li><p>LFSR有三个可配置的参数</p><ul><li>寄存器中的位数 n</li><li>寄存器初始值 seed</li><li>异或抽头 taps 的位置</li></ul></li><li><p>举例如下图所示。</p><p><img src="/2023/12/20/SerDes_PCS/image-20240425144454556.png" alt="image-20240425144454556"></p><ul><li>对于不同的seed值以及taps位置，输出值周期会不同。</li></ul></li></ul><h2 id="3-弹性缓存-Elastic-Buffer"><a href="#3-弹性缓存-Elastic-Buffer" class="headerlink" title="3. 弹性缓存(Elastic Buffer)"></a>3. 弹性缓存(Elastic Buffer)</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><ul><li>异步FIFO &amp;  Elastic Buffer<ul><li>异步FIFO有空满信号，当满信号有效时，会反压前级逻辑，不让其继续向FIFO中写入数据。当空信号有效时，会通知后级逻辑，不让继续进行读操作。</li><li>Elastic Buffer 要求数据不断流入不断流出，不能发生前面的反压前级或通知后级阻塞数据的写入&#x2F;读出。</li></ul></li><li>对于SerDes RX端，存在两个时钟域<ul><li>一个是通过CDR从数据流中解析出来的时钟，该时钟一般用于数据采样，使用该时钟向Buffer中写入数据。</li><li>另一个是RX端本地的时钟信号，用于RX其它逻辑，并用于从Buffer中读取数据。</li></ul></li><li>在第1节中，有提到SerDes TX&#x2F;RX 两个时钟之间可以有几百个ppm的频差，频率相近，数据会不断从写时钟域流向读时钟域。<ul><li>可以通过Elastic Buffer，其自身会丢弃或插入数据 来补偿读写时钟之间的频率&#x2F;相位差。</li><li>应用Elastic Buffer 的总线协议会定义特定的 Symbol 用来丢弃或者插入，比如 PCIe协议的SKP &#x2F; Ethernet协议的IDLE。</li></ul></li></ul><h3 id="3-2-具体设计"><a href="#3-2-具体设计" class="headerlink" title="3.2 具体设计"></a>3.2 具体设计</h3><ul><li>假设条件<ul><li>Ethernet协议中，使用 Symbol：IDLE 来做时钟频率&#x2F;相位的补偿。</li><li>数据位宽：10bit</li><li>采样时钟：125M</li><li>读写时钟之间频率差最高限制在：±300ppm</li></ul></li><li>Buffer的深度计算<ul><li>计算最差时钟周期差<ul><li>根据上面的假设条件，可以计算得到频率范围：124.9625M~125.0375M。以最差情况看，写时钟为124.9625MHz (8.0024ns)，读时钟为125.0375MHz (7.9976ns)。</li><li>两者之间的时钟周期差为0.0048ns。即：每7.9976&#x2F;0.0048&#x3D;1666 个Cycle 就会有一次时钟周期漂移。</li></ul></li><li>计算每次发送一个包内会发生时钟周期漂移的次数来确定FIFO的深度。<ul><li>按照Ethernet最长的包长1500Bytes计算，一个包会跨越 (1500*8)bit&#x2F;10bit&#x3D;1200个Cycle。所以一个Ethernet包至多有一次时钟周期的漂移。</li><li>如果我们想在每次漂移之后都做时钟补偿，那么FIFO的深度为4即可，想留一些裕量则可以考虑更大的深度，如8，16。</li></ul></li></ul></li><li>何时丢弃&#x2F;插入Symbol<ul><li>以FIFO深度为4为例，在FIFO正常的工作状态，我们会让FIFO处于半满状态。即FIFO内存有2个数据。</li><li>基于此，我们可以设置两个阈值：1和3.<ul><li>当FIFO中的数据个数 ≥ 3时，我们认为写时钟过快，需要丢弃IDLE字符。</li><li>当FIFO中的数据个数 ≤ 1时，我们认为读时钟过快，需要插入IDLE字符。</li></ul></li><li>考虑到Ethernet协议要求在两个包间隔处，发送IDLE字符，因此前面介绍的丢弃&#x2F;插入可以在间隔处实现。</li></ul></li><li>总体实现流程<ul><li>（1）FIFO上电后达到半满状态。</li><li>（2）一个新的Ethernet数据包到来，在传输这个数据包期间，FIFO的读写时钟发生了一次漂移，写时钟更快，导致FIFO内存放的数据个数变为3.</li><li>（3）这个包传输结束后，TX端开始发送IDLE字符。RX端检测到IDLE字符后，同时查看FIFO中数据的个数，发现是3.</li><li>（4）此时认为写时钟快了，丢弃当前收到的IDLE字符，让FIFO先将数据个数由3变成2.</li><li>（5）之后恢复正常工作。</li><li>插入与上面类似，也是在间隔时进行操作。</li></ul></li></ul><h2 id="4-时钟纠正"><a href="#4-时钟纠正" class="headerlink" title="4. 时钟纠正"></a>4. 时钟纠正</h2><ul><li><a href="https://blog.csdn.net/piracymonk/article/details/113944411">这篇文章</a> 中有介绍时钟纠正电路的用途以及实现方式。个人理解起来觉得与2.3.3节介绍的弹性缓存相同原理。</li></ul><h2 id="5-通道绑定"><a href="#5-通道绑定" class="headerlink" title="5. 通道绑定"></a>5. 通道绑定</h2><ul><li>在第1节中有介绍，SerDes 可能会将多个Channel绑定成一个Group，共享一个PLL资源。</li><li>如果需要移动的数据量很多，需要一个组内多个Channel一起传输。但是通道之间的偏斜可能会导致同一时刻发送的数据在不同时刻到达，导致采样不到正确的对齐数据。</li><li>通过通道绑定的方法可以调整，来保证采样到正确的对齐数据。实现方式如下：<ul><li>需要设置特殊的有序集(Order Set)来进行标识。</li><li>每个通道都会传输这个特定的通道绑定字符，当接收到该序列之后，不同通道可以确认它们之间的偏移大小。利用FIFO来消除通道之间的偏移。</li></ul></li></ul><p>​<img src="2bbf07afedd841cc9d7cb269f7d19605.png" style="zoom:75%;" /></p><h2 id="6-数据传输格式-数据包"><a href="#6-数据传输格式-数据包" class="headerlink" title="6. 数据传输格式 - 数据包"></a>6. 数据传输格式 - 数据包</h2><ul><li>将千兆串行链路上传输的数据嵌入在数据包中，那么这个数据包中需要包含以下内容。<ul><li>2.3.1节中有介绍，部分K码可以用作判断一个字节的开始&#x2F;结尾的标记。</li><li>对于时钟纠正电路，需要插入&#x2F;丢弃特殊的有序集(Order Set) 来进行时钟纠正。<ul><li>这里特殊的有序集与2.3.3.1节中的Symbol相同含义，PCIE中指定为SKP。</li></ul></li><li>空闲Symbol，当没有信息需要发送时，会继续发送空闲Symbol。<ul><li>目的：连续传输可以确保CDR时钟和接收端PLL锁定在CDR时钟频率附近；链路保持对齐。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高速串行总线</category>
      
      <category>SerDes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SerDes_PMA</title>
    <link href="/2023/12/20/SerDes_PMA/"/>
    <url>/2023/12/20/SerDes_PMA/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/33565230">https://zhuanlan.zhihu.com/p/33565230</a></li><li><a href="https://zhuanlan.zhihu.com/p/512185065">https://zhuanlan.zhihu.com/p/512185065</a></li></ul></li></ul><h2 id="1-预加重电路"><a href="#1-预加重电路" class="headerlink" title="1. 预加重电路"></a>1. 预加重电路</h2><ul><li>预加重是一种在发射端对信号的<strong>高频分量进行补偿</strong>的信号处理方式。<ul><li>信号传输线表现出来的是低通滤波特性，随着信号传输速率提高，高频信号在传输过程中受损很大，为了接收端能够采样到正确的信号，需要TX端在信号发送前进行预加重处理。<ul><li>至于为什么信号传输线表现出来是低通滤波特性，可以看<a href="http://www.360doc.com/content/16/0615/15/32066980_567987512.shtml">这篇文章</a>。主要是介质损耗和趋肤效应导致的。</li></ul></li></ul></li><li>方波信号是多个不同频率下的正弦&#x2F;余弦信号叠加的结果，高频的正弦&#x2F;余弦信号主要体现在方波信号的上升&#x2F;下降的transition上。<ul><li>如下图所示，预加重补偿实际上就是在信号的上升&#x2F;下降沿处增加幅度，其它幅度保持不变。</li><li>可以在发送端增加一个高通滤波器，放大信号高频成分的幅值。</li></ul></li><li>预加重电路会导致功耗增加以及电磁兼容 (EMC) 增加。</li></ul><img src="image-20231216205202374.png" style="zoom:67%;" /><ul><li>去加重电路<ul><li>与预加重有些相似，区别在于：其保持信号上升和下降沿处的幅度不变，其它位置信号幅值减小。<ul><li>相当于加了一个低通滤波效果，并减小低频部分的幅值，高频部分不变。</li></ul></li><li>去加重补偿后的信号摆幅 较 预加重电路的要小，眼图高度低，信号更容易收到噪声的影响；但功耗以及EMC更低。</li></ul></li></ul><img src="v2-3a40b889e3d4c0ece9dca008b7dc155e_720w.png" style="zoom:87%;" /><h2 id="2-均衡电路"><a href="#2-均衡电路" class="headerlink" title="2. 均衡电路"></a>2. 均衡电路</h2><ul><li><p>均衡电路主要是为了补偿信道的非理想性，消除码间干扰(ISI)。</p></li><li><p>均衡电路 表现为高通滤波器。</p><ul><li>从频域上理解，均衡是通过高通滤波器补偿信道的低通特性；使得频谱尽可能平坦。如下图。</li><li>从时域上理解，均衡是对脉冲信号重新塑形，使其上升下降沿transition尽可能小。</li></ul><p><img src="/2023/12/20/SerDes_PMA/5045fig03.gif"></p></li><li><p>均衡器主要有以下几种</p><ul><li>（1）连续时间线性均衡（CTLE）</li><li>（2）前向反馈均衡（FFE）</li><li>（3）判决反馈均衡（DFE）</li></ul></li><li><p>对于Tx，一般采用 FFE 结构。</p><ul><li>因为发射端处理的是离散信号，可以采用 数字FIR 滤波器实现。</li><li>若考虑到低功耗，那么可以采用上面的去加重电路实现；否则采用预加重电路实现。</li></ul></li><li><p>对于Rx，一般采用 CTLE&#x2F;DFE。</p><ul><li><p>对于RX，也可以采用 <strong>数字FIR滤波器</strong> 实现，但是考虑到发射出的离散信号经过有损信号后出现扭曲，需要使用采样保持放大器(SHA)对信号进行重新采样，之后再ADC转换为数字信号。再过数字FIR滤波器。</p><ul><li>但是其存在瓶颈，如下。<ul><li>SHA以及ADC所在的关键路径限制了滤波器的工作速度；即使移相技术和并行技术可以减轻速度的瓶颈，但波特率也被限制在1Gbps内。</li><li>ADC若想达到GHz量级，那么ADC将消耗大量的功耗和面积。</li></ul></li></ul><p><img src="/2023/12/20/SerDes_PMA/73973711_9.png"></p></li><li><p>如果使用 <strong>模拟FIR滤波器</strong>，因为相较于数字FIR滤波器少了ADC模块，因此可能做到低功耗高速度。</p><ul><li>但是其亦存在瓶颈，如下。<ul><li>速度同样被SHA所在的关键路径限制。</li><li>延迟线的传输速率与带宽有关，在传输速率十分高时，信号衰减严重。</li><li>其中延迟线路可以由DLL&#x2F;PLL实现，但是对于很高速率的数据传输，这个延时要求十分精确，对DLL&#x2F;PLL也是一个挑战。</li></ul></li></ul><p><img src="/2023/12/20/SerDes_PMA/73973711_10.png"></p></li><li><p>CTLE（连续时间线性均衡）</p><ul><li>根据 <a href="https://zhuanlan.zhihu.com/p/83228356">这篇文章</a> 对CTLE频率响应曲线的分析，可以看到，低频时增益衰减值几乎为常数，随着频率不断升高，增益衰减逐渐变小，但是过了某个频率点后，衰减值又开始慢慢变大。<ul><li>我们利用的频端是前面这部分，因此在起作用的频端中，可以看到CTLE是一个高通滤波器。</li></ul></li><li>CTLE 可以通过有源&#x2F;无源两种方式实现，实现的效果都是降低信号低频幅值&#x2F;提升信号高频幅值，从而提高通道的带宽。</li></ul></li><li><p>DFE（判决反馈均衡）</p><ul><li>包括两个延迟滤波器：前向滤波器以及反向滤波器。<ul><li>其中反向滤波器的输入是前向滤波器+判决器输出后的结果。反向滤波器的系数可以通过调整来抵消ISI。</li></ul></li></ul><p><img src="/2023/12/20/SerDes_PMA/1-1702884279165-30.png"></p><ul><li>缺点<ul><li>太依赖于之前信号的判决，可能导致误差传播，处理速度变慢。</li></ul></li></ul></li></ul></li></ul><h2 id="3-串并转换电路"><a href="#3-串并转换电路" class="headerlink" title="3. 串并转换电路"></a>3. 串并转换电路</h2><h2 id="4-时钟恢复电路-CDR"><a href="#4-时钟恢复电路-CDR" class="headerlink" title="4. 时钟恢复电路(CDR)"></a>4. 时钟恢复电路(CDR)</h2>]]></content>
    
    
    <categories>
      
      <category>高速串行总线</category>
      
      <category>SerDes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SerDes_电路结构</title>
    <link href="/2023/12/20/SerDes_%E7%94%B5%E8%B7%AF%E7%BB%93%E6%9E%84/"/>
    <url>/2023/12/20/SerDes_%E7%94%B5%E8%B7%AF%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://mp.weixin.qq.com/s/JY0Tt31KBoE83XKBwcQTMw">https://mp.weixin.qq.com/s/JY0Tt31KBoE83XKBwcQTMw</a></li><li><a href="https://www.eet-china.com/mp/a134063.html">https://www.eet-china.com/mp/a134063.html</a></li><li><a href="https://blog.csdn.net/zhouxianjin123/article/details/108480044">https://blog.csdn.net/zhouxianjin123/article/details/108480044</a></li></ul></li></ul><hr><h3 id="1-1-数据流向"><a href="#1-1-数据流向" class="headerlink" title="1.1 数据流向"></a>1.1 数据流向</h3><ul><li>SerDes 经典结构如下图所示，主要包括PLL模块、Tx模块以及Rx模块。<ul><li>其中绿色为PCS层，是标准的可综合CMOS数字逻辑。黄色是PMA层，是数模混合CML&#x2F;CMOS电路。</li><li>Tx Block<ul><li>从其他电路接收到并行数据Ch0_TxData，通过接口FIFO（Interface FIFO），送到8B&#x2F;10B 编码器&#x2F;扰码器。</li><li>之后送到Serializer进行 并 -&gt; 串 转换。串行数据经过均衡器（Equalizer）调理后，再由Driver发送出去。</li></ul></li><li>Rx Block<ul><li>Receiver 接收到外部传入的串行差分信号后，由线性均衡器（Linear Equalizer）或 DFE（Decision Feedback Equalizer）结构的均衡器调理，来去掉一部分确定性抖动（Deterministic jitter）。</li><li>CDR从数据中恢复出时钟信号，之后数据送入De-Serializer后，得到对齐的并行数据。</li><li>解串器得到的并行数据经过 8B&#x2F;10B解码器(8B&#x2F;10B decoder)或解扰器(de-scambler)完成解码或者解扰。如果是异步时钟系统，那么数据还需要经过Elastic Buffer(FIFO) 来解决跨时钟域问题，补偿频差。</li><li>最后经过接口FIFO，将并行数据输出。</li></ul></li></ul></li></ul><p><img src="/2023/12/20/SerDes_%E7%94%B5%E8%B7%AF%E7%BB%93%E6%9E%84/MBXY-CR-932a5a0b2658d23432f6bdff1ef3b15e.png"></p><h3 id="1-2-电路结构"><a href="#1-2-电路结构" class="headerlink" title="1.2 电路结构"></a>1.2 电路结构</h3><ul><li>下图为Virtex-II Pro RocketIO SERDES结构框图，其它家的Serdes架构可以看<a href="https://www.ebaina.com/articles/140000005076">这篇博客</a>。<ul><li><p>物理编码子层（Physical Coding Sublayer，PCS）：主要包含了 <strong>8B&#x2F;10B 编解码电路、弹性缓存(Elastic Buffer)、通道绑定电路以及时钟修正电路。</strong></p></li><li><p>物理媒介适配层（Physical Media Attachment，PMA）：主要包含 <strong>高速串并转换电路、预加重电路、接收均衡电路、时钟发生电路以及时钟恢复电路</strong>。</p></li></ul></li></ul><p><img src="/2023/12/20/SerDes_%E7%94%B5%E8%B7%AF%E7%BB%93%E6%9E%84/6448902cd749949898.png"></p>]]></content>
    
    
    <categories>
      
      <category>高速串行总线</category>
      
      <category>SerDes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SerDes_简介</title>
    <link href="/2023/12/20/SerDes_%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/12/20/SerDes_%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://mp.weixin.qq.com/s/JY0Tt31KBoE83XKBwcQTMw">https://mp.weixin.qq.com/s/JY0Tt31KBoE83XKBwcQTMw</a></li><li><a href="https://www.eet-china.com/mp/a134063.html">https://www.eet-china.com/mp/a134063.html</a></li><li><a href="https://blog.csdn.net/zhouxianjin123/article/details/108480044">https://blog.csdn.net/zhouxianjin123/article/details/108480044</a></li></ul></li></ul><hr><h2 id="1-SerDes-简介"><a href="#1-SerDes-简介" class="headerlink" title="1. SerDes 简介"></a>1. SerDes 简介</h2><ul><li><p>SerDes 是 Serializer&#x2F;Deserializer 的缩写，主要完成以下两部分任务：</p><ul><li>在发送端，将多路<strong>低速并行</strong>的信号转换为<strong>高速串行</strong>的信号。</li><li>经过传输媒体（光缆或者铜线等），最后在接收端，将<strong>高速串行信号</strong>转换为<strong>低速并行</strong>信号。</li></ul></li><li><p>为什么需要 Serdes</p><img src="MBXY-CR-9711473e4ddba4ce8af2d1e62a6038c0-1702391561321-1.png" style="zoom:67%;" /><ul><li><p>系统同步接口</p><ul><li>对于系统同步接口，随着接口频率的不断增加，下面几个因素影响着数据传输的准确性。<ul><li>（1）时钟到达两个chip的传播延时不相等（clock skew）。<ul><li>即使可以在<code>chip #2</code> 中使用PLL补偿时钟延时差，但是由于PVT变化，数据的延时和时钟的延时无法保证变化一致。</li></ul></li><li>（2）对于并行接口通信，并行数据的每个bit的传播延时不相等（data skew）。</li><li>（3）时钟的传播延时和数据的传播延时不一致。</li></ul></li></ul></li><li><p>源同步接口</p><ul><li><p>对于源同步接口，其特点在于：<code>chip #1</code> 会将数据和时钟一起发送出去。</p><ul><li>需要保证在TX端两者时序是正确的，保证数据和时钟信号完全匹配，这样RX端接收到的时序也是正确的。</li><li>当PVT发生变化时，两者的变化趋势一致，利于同步。</li></ul></li><li><p>以一些合理的数据做假设。</p><ul><li><p>（1）TX端的数据skew：50ps</p></li><li><p>（2）PCB走线引入的skew：50ps</p></li><li><p>（3）时钟抖动 jitter：±50ps</p></li><li><p>（4）接收端触发器采样<code>t_c2q</code> &#x3D; 250ps</p></li><li><p>可以大致估计并行接口最高时钟频率<br>$$<br>f_{max} &#x3D; \frac{1}{(50+50+100+250)*10^{-12}} &#x3D; 2.2GHz<br>$$</p><ul><li>对于双边采样（时钟上升&amp;下降都采样，DDR），其最大时钟频率可到2.2GHz。</li><li>对于单边采样（单时钟上升沿&#x2F;下降沿采样，SDR），其最大时钟频率可到1.1GHz。</li></ul></li></ul></li><li><p>根据上面的计算，源同步接口的频率一般都被限制在1GHz以下。</p></li><li><p>增加接口传输带宽，除了增加时钟频率，还可以加大数据位宽。</p><ul><li><p>但是数据位宽的增加会导致<strong>同步开关噪声（SSN）</strong>的恶化。</p></li><li><p>SSN：芯片中I&#x2F;O口发生大量同步的电平切换 产生的瞬态电路在电源&#x2F;地产生的噪声现象，更详细的介绍可以看<a href="https://blog.csdn.net/weixin_41808082/article/details/117459420">这篇文章</a>。SSN产生的噪声能够降低噪声容限，导致错误的切换。</p></li><li><p>其计算公式如下。</p><ul><li>其中N为同步开关的I&#x2F;O数量，这里可以考虑成数据位宽。</li><li>其中L为电流回路等效的电感值。</li><li><code>di/dt</code> 代表I&#x2F;O输出电流的变化速率。</li></ul><p>$$<br>SSN &#x3D; L<em>N</em>\frac{d_i}{d_t}<br>$$</p></li></ul></li></ul></li><li><p>SerDes 接口</p><img src="MBXY-CR-250cc530111fb2819dc9124853b84513.png" style="zoom:67%;" /><ul><li><p>如上图所示，SerDes 不传输时钟信号，因为，在RX端集成了CDR（Clock Data Recovery）电路，可以利用CDR从数据的边沿信息中抽取时钟，找到最优的采样位置。</p></li><li><p>上图中，一共有N个Channel，每个Channel包含一组差分的双向的数据通路；每个通道之间的工作是相互独立的。一般会划分多个Channel为一个Group，共享PLL资源。</p></li><li><p>另外，TX和RX端使用各自的参考时钟，两个时钟之间可以有几百个ppm的频差，也可以是同频时钟，对相位差也没有要求。</p><ul><li>PPM 计算公式<br>$$<br>PPM &#x3D; \frac{实际频率-设定频率}{设定频率} * 1000000<br>$$</li></ul></li></ul></li><li><p>SerDes 相较于 源同步 的主要特点</p><ul><li>SerDes不需要将时钟和数据一起传输，也就不需要做两者的匹配。</li><li>SerDes可以通过预加重和均衡技术可以实现高速长距离传输。</li><li>Serdes相较于源同步，在实现差不多速率传输的同时，使用更少的引脚。</li></ul></li><li><p>中间类型</p><ul><li>存在一些接口类型，他们既采用了串行器和解串器，也像源同步一样，在传输数据的同时还传输用于同步的时钟信号。</li><li>例如： 7:1 LVDS 视频接口</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高速串行总线</category>
      
      <category>SerDes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>形式验证-概述</title>
    <link href="/2023/11/13/%E5%BD%A2%E5%BC%8F%E9%AA%8C%E8%AF%81/"/>
    <url>/2023/11/13/%E5%BD%A2%E5%BC%8F%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://www.cnblogs.com/IClearner/">https://www.cnblogs.com/IClearner/</a></li><li><a href="https://blog.csdn.net/qq_36480087/article/details/112891856">https://blog.csdn.net/qq_36480087/article/details/112891856</a></li></ul></li></ul><hr><h2 id="1-关于形式验证"><a href="#1-关于形式验证" class="headerlink" title="1. 关于形式验证"></a>1. 关于形式验证</h2><ul><li>形式验证在流程中的位置<ul><li>在DC综合后，将综合后的网表和RTL进行对比，验证综合过程是否出错，保证逻辑正确。</li><li>在自动布局布线之后，将综合网表和布局布线得到的网表进行比较，验证是否出错。</li></ul></li><li>常用工具<ul><li>Synopsys: Formality</li><li>Candence: LEC（推荐使用）</li></ul></li></ul><h2 id="2-形式验证流程"><a href="#2-形式验证流程" class="headerlink" title="2. 形式验证流程"></a>2. 形式验证流程</h2><ul><li>这里以Synopsys的Formality为例。</li><li>文件准备<ul><li>准备RTL代码，以及DC给出的svf文件，ddc门级网表文件，库文件等。<ul><li>svf(Setup Verification for Formality)文件，记录优化过程中的各项逻辑操作，比如replace, merge, uniquify, retime, reg_constant等等，用于辅助formality verification的。</li></ul></li></ul></li><li>编写相应的流程fm.tcl脚本如下。</li></ul><p><img src="/2023/11/13/%E5%BD%A2%E5%BC%8F%E9%AA%8C%E8%AF%81/3201119-20230802173725308-2069923994.png"></p><ul><li>启动Formality，并将终端的信息输出到fm_run.log上。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fm_shell -f ./scripts/fm.tcl |<span class="hljs-built_in">tee</span> -i fm_run.log<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>形式验证</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RC_Extraction</title>
    <link href="/2023/11/13/RC-Extraction/"/>
    <url>/2023/11/13/RC-Extraction/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Flow-中的-RC计算"><a href="#1-Flow-中的-RC计算" class="headerlink" title="1. Flow 中的 RC计算"></a>1. Flow 中的 RC计算</h2><ul><li>逻辑综合<ul><li>使用的是WLM模型，或者使用DCT进行估计。</li></ul></li><li>PreRoute之前<ul><li>使用的是virtual route，并使用tlu+进行估计。</li></ul></li><li>在Route 阶段<ul><li>使用真实的走线形状和tlu+进行估计。</li></ul></li><li>在Signoff阶段<ul><li>在<a href="https://www.cnblogs.com/qianbinbin/p/17477246.html">这篇博客</a>中也有介绍，在Signoff时，可以使用STARRC抽取的nxtgrd文件（该文件比tluplus有更详细的信息），导入pt中。   </li><li>这阶段提取的RC是最为准确的，不仅nxtgrd文件较tluplus文件更准确，这阶段使用工具的rc extract engine也较ICC中的更精准。</li></ul></li></ul><h2 id="2-Signoff-阶段-RC的提取"><a href="#2-Signoff-阶段-RC的提取" class="headerlink" title="2. Signoff 阶段 RC的提取"></a>2. Signoff 阶段 RC的提取</h2><ul><li>使用PR结束后的database（Milkyway）。<ul><li>database导出阶段可以是Route&#x2F;DFM&#x2F;做完PV（Physical Verification），他们之间存在一个不断迭代的过程。<ul><li>因为考虑到route之后的一些过程可能还会影响时序，例如metal filler等，可能会出现金属线之间的couple，影响时序。</li><li>但是route之后的一些操作，可能导致在做Timing ECO的时候不方便，所以可以在route之后先提取一下，查看一下时序，进行Timing ECO的操作。都修完了之后再进行后续的操作，并继续需要提取寄生参数，查看Timing；不断迭代。</li></ul></li></ul></li><li>使用StarRC提取流程如下<ul><li>StarRC工具除了Milkyway，还需要nxtgrd、mapfile以及command file文件。提取结果以网表形式呈现，常见的网表有spef、spbf。 </li><li>其中mapfile是nxtgrd和.tf映射关系的文件，与<a href="https://www.cnblogs.com/qianbinbin/p/17638107.html">这篇博客</a>中tluplus的map文件一样。   </li><li>其中nxtgrd文件也是分为多个RC Corner。编写的脚本需要根据signoff标准组合PVT Corner和RC Corner，抽取得到多个spef文件。</li><li>command file 中大部分参数设置建议使用EDA厂商给的参考脚本，后缀为.cmd而不是.tcl。<ul><li>这里介绍一条指令：skip_cells；可以指定忽略哪些cell内部的net，不提取rc。例如可以指定不提取std、Mem、Sub-Block内部net的RC。</li></ul></li></ul></li></ul><img src="3201119-20230827202136812-1425830345.png" width = 40%/> ]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>STA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>静态时序分析-DMSA</title>
    <link href="/2023/11/13/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90-DMSA/"/>
    <url>/2023/11/13/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90-DMSA/</url>
    
    <content type="html"><![CDATA[<h2 id="1-DMSA-概述"><a href="#1-DMSA-概述" class="headerlink" title="1. DMSA 概述"></a>1. DMSA 概述</h2><ul><li>为什么需要DMSA，在<a href="https://www.cnblogs.com/qianbinbin/p/17603907.html">这篇博客</a>中有详细介绍。</li><li>DMSA(Distributed Multi-Scenario Analysis) Master根据多少个scenario分配多少个线程，每个线程有一个PT slave做一个scenario的分析。<ul><li><p>DMSA Master可以对这些进行统一管理。并向每个slave pt分配任务&#x2F;指令。</p><img src="3201119-20230828135724894-1670397998.png" width = 70%/></li></ul></li></ul><h2 id="2-使用DMSA-进行管理"><a href="#2-使用DMSA-进行管理" class="headerlink" title="2. 使用DMSA 进行管理"></a>2. 使用DMSA 进行管理</h2><ul><li>启动指令如下<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">pt_shell -multi_scenario -f run_dmsa.pt<br></code></pre></td></tr></table></figure></li><li>在DMSA Master中定义scenario的两种方法<ul><li>（1）加载已经写好的每个scenario的脚本。</li><li>（2）加载之前已经保存好的session，使用-image选项。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>STA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>静态时序分析-IR_Drop</title>
    <link href="/2023/11/13/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90-IR-Drop/"/>
    <url>/2023/11/13/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90-IR-Drop/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li>微信公众号：老秦谈芯</li></ul></li></ul><hr><h2 id="1-IR-Drop-概述"><a href="#1-IR-Drop-概述" class="headerlink" title="1. IR-Drop 概述"></a>1. IR-Drop 概述</h2><ul><li>什么是IR-Drop<ul><li>考虑当芯片各种功能的电路同时工作，稳压电源模块无法实时响应demand current的快速增大（I*R,I增大，分压大，VDD会减小），导致芯片的电源电压发生跌落，从而产生<strong>电源噪声</strong>。</li><li>另外，考虑到电源和地之间存在一定的耦合效应，相应的VSS也会太高一些。</li><li>随着制程工艺不断进步，金属连线的宽度越来越窄，导致电阻值越来越高，<strong>如果一个器件离供电点很远（电阻长度大），其等效电阻值必然也会很大</strong>。那么电阻上消耗掉的压降也很大，导致VDD会有偏差，出现电源噪声。</li></ul></li><li>IR-Drop 引起的问题<ul><li>考虑芯片上的时钟之间存在skew，导致晶体管的转换过程并不是严格同步的。那么会出现，一些晶体管完成了电压状态转换，而一些晶体管还在电压转换的不确定态区域的情况，那么电源噪声可能会被放大，引起电路的逻辑错误。</li><li>如果电压降太大，会导致gate延时增大：gate的电压减小，电流减小，电容充放电速度变慢，延时增加。如果IR-Drop发生在时序紧张的路径，会导致其出现时序违例。</li></ul></li></ul><h2 id="2-IR-Drop-分类"><a href="#2-IR-Drop-分类" class="headerlink" title="2. IR-Drop 分类"></a>2. IR-Drop 分类</h2><ul><li><p>主要分为两种：静态IR-Drop，动态IR-Drop。</p></li><li><p>静态IR-Drop</p><ul><li>产生的主要原因是电源网络的金属连线自身电阻的分压，所以静态IR-Drop和电源网络的结构以及连线细节有关。</li></ul><img src="3201119-20230807105300118-790769418.png" width = 60%/></li><li><p>动态IR-Drop</p><ul><li>在电路开关切换时，由于电流波动引起的电压压降。</li><li>同时开关的晶体管数量越多，越容易出现动态IR-Drop现象。因此这种现象常见于时钟的触发沿。<ul><li>时钟触发沿不仅有时序电路还有组合电路出现大量的晶体管开关切换，会导致短时间在芯片上产生很大电流，引起了IR-Drop现象。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>STA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>静态时序分析-OCV</title>
    <link href="/2023/11/13/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90-OCV/"/>
    <url>/2023/11/13/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90-OCV/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://mp.weixin.qq.com/s/o0ijKcl07LbPjdF6uRrAXw">https://mp.weixin.qq.com/s/o0ijKcl07LbPjdF6uRrAXw</a>（公众号：全栈芯片工程师）</li><li><a href="https://cloud.tencent.com/developer/article/1500279">https://cloud.tencent.com/developer/article/1500279</a></li><li><a href="https://cloud.tencent.com/developer/article/1611170">https://cloud.tencent.com/developer/article/1611170</a></li><li><a href="https://www.cnblogs.com/lelin/p/11397497.html">https://www.cnblogs.com/lelin/p/11397497.html</a></li><li><a href="https://aijishu.com/a/1060000000194153">https://aijishu.com/a/1060000000194153</a></li></ul></li></ul><hr><h2 id="1-OCV"><a href="#1-OCV" class="headerlink" title="1. OCV"></a>1. OCV</h2><ul><li><p>OCV的全称是On Chip Variation，用于描述在一块芯片上不同管子间由于工艺偏差、电压降以及温度变化等引起的delay变化。</p></li><li><p>可以通过derate 特定单元&#x2F;走线的延迟来对OCV的影响进行建模。</p><ul><li>使用指令如下，对延迟进行derate处理。下面的指令是指定所有的网络延迟和单元延迟，也可以使用tcl脚本单独指定cell delay 或 net delay。<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 降低延迟20%</span><br><span class="hljs-attribute">set_timing_derate</span> -early <span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><span class="hljs-comment"># 增加延迟10%</span><br><span class="hljs-attribute">set_timing_derate</span> -late <span class="hljs-number">1</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>拒绝过于悲观</p><img src="3201119-20230803191724445-1155297483.png" width = 60%/><ul><li><p>注意对于上图这种 Launch clock 和 Capture clock 存在一段公共的时钟路径，这部分不应该对其进行derate处理，因为这部分物理实现上为处在同一个PVT条件下。Synopsys 称为CRPR &#x3D; Clock Reconvergence Pessimism Removal。</p><ul><li>CRPR 是基于时序弧分析的，而不是gate分析的。<ul><li>如下图所示，Innovus的分析行为是：如果Launch clock 和 Capture clock在时钟源的边沿相同，且到达common point时边沿时亦相同，那么CRPR的值就是从时钟源到common point的延时。如果不满足前面两个情况，那么CRPR的值就为两个时序弧延时的最小值。</li></ul></li></ul><img src="3201119-20230820121229237-1301147191.png" width = 40%/></li><li><p>考虑time derate需要在某个单一条件下，比如说BC或者WC条件下，但是不要把多个Corner(例如：BC和WC)混在一起，再OCV，那样太过于悲观。</p></li></ul></li><li><p>OCV 的分析与计算</p><ul><li>以上面的电路为例，不考虑OCV影响，计算最小周期T需要满足<br>$$<br>1.2+0.8+5.2+0.35 &lt;&#x3D; T+1.2+0.86<br>$$ </li><li>考虑OCV影响，使用tcl指令针对setup检查和hold检查分别加以约束。<ul><li>setup检查<ul><li>对于Launch clock path 和 data path 使用 -late 选项；对Capture clock path 使用 -early 选项。</li><li>但是考虑到setup check 一般在WC PVT下，因此不需要在Launch clock path 和 data path上加time derate了，因为在WC下，其delay已经是所有corner中最大的了；但是在WC下，Capture clock path上的delay一定不是最小的，所以可以加derate指令。<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_timing_derate</span> -early <span class="hljs-number">0</span>.<span class="hljs-number">9</span><br><span class="hljs-attribute">set_timing_derate</span> -late <span class="hljs-number">1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li>此时最小周期T计算满足（进行共同路径悲观去除，CPPR）<br>$$<br>0.8 + 5.2 + 0.35 &lt;&#x3D; 0.86*0.9 + T<br>$$</li></ul></li><li>hold检查<ul><li>对于Launch clock path 和 data path 使用 -early 选项；对Capture clock path 使用 -late 选项。</li><li>但是考虑到hold check 一般在BC PVT下，因此不需要在Launch clock path 和 data path上加time derate了，因为在BC下，其delay已经是所有corner中最小的了；但是在BC下，Capture clock path上的delay一定不是最大的，所以可以加derate指令。<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_timing_derate</span> -early <span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">set_timing_derate</span> -late <span class="hljs-number">1</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>OCV &amp; BC-WC</p><ul><li><p>静态时序分析工具给出了3种分析模式</p><ul><li>Single mode</li><li>BC-WC</li><li>OCV mode（AOCV,POCV）</li></ul></li><li><p>OCV的原始定义如下，可以看到与BC-WC混合模式十分相似。只是在计算setup和hold中都混用了max库和min库。</p><ul><li>但是前面也有介绍，为了不要太悲观，我们一般不会采用这种BC,WC混用。</li></ul><img src="3201119-20230803195057197-90816743.png" width = 60%/></li><li><p>BC-WC模式如下。</p><img src="3201119-20230803195404688-289302780.png" width = 60%/></li></ul></li></ul><h2 id="2-AOCV"><a href="#2-AOCV" class="headerlink" title="2. AOCV"></a>2. AOCV</h2><ul><li><p>为什么需要AOCV</p><ul><li>在40nm之前，简单的OCV derate模型基本可以覆盖大部分情况，且不会悲观到不能接收。</li><li>如下图所示，OCV模式设置的derate值与path depth无关，导致其既不能cover最悲观的部分，但又对另一部分过于悲观。在40nm之后，随着设计的频率不断提升，OCV所引入的不准确性已经无法承受。</li></ul><img src="3201119-20230804155310498-1374743247.png" width = 60%/></li><li><p>Distance based AOCV</p><ul><li>距离越远的cell之间的variation越大，所以AOCV的分析策略可以是Distance Based，距离越大，derate越大。  </li><li>这个距离是指timing path所在物理范围矩形对角线的长度。<strong>timing path的位置信息可以由SPEF提供，</strong>要求抽SPEF时需要将坐标信息也抽出，而在STA读SPEF时，将坐标信息读入。</li></ul><img src="3201119-20230804161057166-1944056894.png" width = 60%/></li><li><p>Depth based AOCV</p><ul><li>考虑到不可能一条path上的所有cell的variation都是悲观的，会存在一些cell的variation是相互抵消的，所以在Depth based AOCV模型中，depth越大，derate值越小。</li></ul><img src="3201119-20230804163036323-1431424864.png" width = 60%/></li><li><p>AOCV Table</p><ul><li>有一维和二维两种。<ul><li>一维：坐标为 depth。</li><li>二维：坐标为 distance 和 depth。虽然较一维更为准确，但是runtime也更大。</li></ul></li></ul></li></ul><h2 id="3-POCV"><a href="#3-POCV" class="headerlink" title="3. POCV"></a>3. POCV</h2><ul><li><p>为什么需要POCV</p><ul><li><p>AOCV 如果是基于GBA进行分析，那么精度不够，过于悲观；如果基于PBA进行分析，runtime又无法接受。</p><ul><li>GBA和PBA的相关解释可见<a href="https://www.cnblogs.com/qianbinbin/p/17603907.html">这篇博客</a>。</li></ul></li><li><p>AOCV没有考虑input transition和output load对variation的影响，以及variation对input transition的影响。</p></li><li><p>使用一种新的计算模型：Synopsys 叫 POCV(Parametric OCV)，Cadence 叫 SOCV(Statistical OCV)。</p></li><li><p>POCV 将delay模拟成一个正态分布进行计算。如下图可知，POCV(SOCV)计算的值更精准。</p><img src="3201119-20230804225141761-1300833462.png" width = 60%/></li></ul></li><li><p>POCV derate计算</p><ul><li><p>对每个cell分别建模，cell 的 derate 是一个基于μ和σ的高斯随机变量函数，如下所示。</p><img src="3201119-20230805095523646-525721250.png" width = 60%/></li><li><p>根据读入的LVF文件（LVF一般由foundry提供），可以根据input transition 和 output load 查找到平均延时和Sigma值。根据下表完成计算。其中n一般为3.</p><table><thead><tr><th></th><th>setup check</th><th>hold check</th></tr></thead><tbody><tr><td>Capture clock path</td><td>M-n*S</td><td>M+n*S</td></tr><tr><td>Launch clock path</td><td>M+n*S</td><td>M-n*S</td></tr></tbody></table></li><li><p>以计算delay variation为例，cell rise中的值为M，而ocv_sigma_cell_rise中的值为S。</p><img src="3201119-20230805100647964-1480707496.png" width = 60%/></li></ul></li><li><p>LVF (Liberty Variation Format) </p><ul><li><p>传统的LVF文件中有输出为cell delay、output transition 以及timing check的LUT，LUT的index与NLDM&#x2F;CCS一样都为 input transition 和 output load。</p></li><li><p><strong>从文件中可以根据高斯分布delay的计算公式以及分析场景分别计算出正确的delay和transition。</strong></p><ul><li>这里可以看到LVF 查找表中考虑到了variation对transition的影响，并将该transition的值一级一级通过查找表传递。</li></ul><img src="3201119-20230805101530725-2068503571.png" width = 60%/></li><li><p>考虑进入16nm，先进工艺结点和超低电压都会导致cell的delay为一个<strong>强非高斯分布</strong>，会出现均值偏移(mean-shift)以及偏斜效应(skewness effects)。</p><ul><li>为了解决，引入3个moment-based模型。详细解释见<a href="https://www.cnblogs.com/lelin/p/11397497.html">这篇文章</a>。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>STA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>静态时序分析-基础</title>
    <link href="/2023/11/13/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/11/13/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li>《集成电路静态时序分析与建模》 </li><li>公众号：陌上风骑驴看IC</li><li>公众号：全栈芯片工程师</li><li><a href="https://blog.csdn.net/weixin_37584728/article/details/116974681">https://blog.csdn.net/weixin_37584728/article/details/116974681</a></li></ul></li></ul><hr><h2 id="1-STA-相关基础知识"><a href="#1-STA-相关基础知识" class="headerlink" title="1. STA 相关基础知识"></a>1. STA 相关基础知识</h2><ul><li>DC 和 ICC工具中也嵌入了STA分析工具，timing engine类似于STA，但是为了run time，精度降低了。<ul><li>像后面介绍的STA的两种分析模式：GBA和PBA，DC和ICC中只支持GBA的分析。</li></ul></li><li>时序分析<ul><li>可分为静态时序分析和动态时序分析。</li><li>动态时序分析<ul><li>通过网表和sdf文件，sdf将单元延迟和连线延迟反标到网表上；并给入大量的测试激励来验证电路的功能。</li><li>需要特殊注意几个验证点<ul><li>典型应用场景的功能验证</li><li>频率的动态切换</li><li>跨时钟域信号是否正确同步</li><li>PMU上电以及断电的顺序是否正确以及是否满足相应的时序要求</li><li>Multi-Cycle等特别逻辑的功能是否正确</li></ul></li></ul></li><li>静态时序分析<ul><li>将电路分割成大量的时序弧，根据CCS&#x2F;NLDM模型计算器件延时，以及根据StarRC提取出的SPEF等将R&#x2F;C反标到net上，并根据net delay计算连线延时。</li><li>获得timing_path的delay之后，与用户定义的sdc比较，给出是否满足需求。</li></ul></li></ul></li><li>Signoff 阶段 STA需要做的分析<ul><li>时序单元的相关约束：建立时间、保持时间、恢复时间、移除时间以及时钟信号最小脉冲宽度。<ul><li>其中时钟信号脉宽必须要大于最小脉冲宽度，否则无法保证时序单元实现正常的逻辑功能。</li><li>恢复、移除时间的分析可以看<a href="https://www.cnblogs.com/qianbinbin/p/17559415.html">这篇博客</a>。</li></ul></li><li>DRC相关检查<ul><li>max&#x2F;min transition</li><li>max&#x2F;min capacitance</li><li>max_fanout</li></ul></li><li>SI（信号完整性）分析<ul><li>Bump&#x2F;Glitch&#x2F;Noise分析。</li></ul></li></ul></li><li>时序弧<ul><li>静态时序分析是基于时序弧进行时序分析的，用来描述两个节点之间延时信息的数据。</li><li>一般分为连线延时和单元延时。器件延迟和连线延迟模型可见<a href="https://www.cnblogs.com/qianbinbin/p/17459189.html">这篇博客</a>。</li><li>更为详细的单元延迟时序弧分析可见《集成电路静态时序分析与建模》P21。</li></ul></li><li>MCMM &amp; DMSA<ul><li>Signoff阶段STA也需要MCMM分析，MCMM相关知识可见<a href="https://www.cnblogs.com/qianbinbin/p/17638107.html">这篇博客</a>。</li><li>依次跑完每个scenario，这种方法的不便之处在于：<ul><li>scenario之间可能会有violation重合的部分，也有不重合的部分。需要比较violation在哪个scenario下最严重。</li><li>在某个scenario下clean timing时，其它scenario可能没有clean掉，甚至可能在其它scenario下产生新的violation的点。</li></ul></li><li>可以使用<strong>DMSA</strong>机制管理不同scenario。根据所有scenario的信息进行timing eco。DMSA相关内容可以看<a href="https://www.cnblogs.com/qianbinbin/p/17662024.html">这篇博客</a>。</li></ul></li></ul><h2 id="2-RC网络"><a href="#2-RC网络" class="headerlink" title="2. RC网络"></a>2. RC网络</h2><ul><li>一个cell可以被模拟成<strong>输入电容、输出电容、上拉电阻和下拉电阻。</strong><ul><li>输入电容为前一级驱动的负载，输出电容为本级自身的负载。</li><li>上拉电阻&#x2F;下拉电阻的大小决定了cell对负载电容充放电电流的大小，即驱动能力。</li></ul></li><li><a href="https://www.cnblogs.com/qianbinbin/p/17459189.html">这篇博客</a>中有介绍NLDM&#x2F;CCS模型都是通过input transition和output load可以在查找表中找到cell delay以及output transition。<ul><li><p>对于cell delay的计算，除了查找表之外，还有表头定义的四个attribute；这四个attribute决定了cell delay的定义方式。更为详细的介绍可见《集成电路静态时序分析与建模》P11。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">input_threshold_pct_fall :<span class="hljs-number">60</span>;<br>output_threshold_pct_fall :<span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><img src="3201119-20230803132859974-1629355947.png" width = 40%/></li><li><p>transition的计算是逐级递进的，output transition是根据input_transition和output_load查找得到的。与cell_delay一样，也需要定义四个attribute，决定了rise&#x2F;fall transition time的定义方式。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">slew_lower_threshold_pct_fall</span> :<span class="hljs-number">20</span>.<span class="hljs-number">0</span>;<br><span class="hljs-attribute">slew_upper_threshold_pct_fall</span> :<span class="hljs-number">80</span>.<span class="hljs-number">0</span>;<br><span class="hljs-attribute">slew_lower_threshold_pct_rise</span> :<span class="hljs-number">10</span>.<span class="hljs-number">0</span>;<br><span class="hljs-attribute">slew_upper_threshold_pct_rise</span> :<span class="hljs-number">90</span>.<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><img src="3201119-20230803134043009-702555882.png" width = 60%/></li></ul></li></ul><h2 id="3-PVT"><a href="#3-PVT" class="headerlink" title="3. PVT"></a>3. PVT</h2><ul><li><p>芯片的健壮性要求我们需要在物理实现过程中额外考虑温度、电压以及工艺偏差的影响。</p></li><li><p>可以使用PVT、RC Corner以及OCV来模拟这些不可控的随机因素。</p></li><li><p>根据不同的工艺，foundary会提供一张SignOff的表格。这里首先介绍PVT。</p><img src="3201119-20230803143433098-462607844.png" width = 60%/><ul><li>下图中ss和ff分别为slow nmos,slow pmos 以及fast nmos,fast pmos。为五种不同工艺角中的两种极限。 <ul><li>其中有一些温度为-40°，因为需要考虑温度翻转效应，也需要signoff。</li></ul></li></ul><img src="3201119-20230803162739913-1519710470.jpg" width = 60%/></li><li><p>PVT的不理想性</p><ul><li>P：在制造过程中可能会出现偏差，导致管子的电阻和阈值电压以及宽长比可能会出现偏差。</li><li>V：cell的延迟和电压有很大的关系，以单电压芯片为例，电池的供电电压本就在一个范围内变化，而且考虑片外&#x2F;片上的voltage regulator的误差，以及IR的影响，导致芯片上的每个管子都可能工作在不同的电压下。<ul><li>必须保证IR Drop不能过大，否则芯片可能会因为得不到所需的电压而发生逻辑错误或停止工作。</li></ul></li><li>T：温度升高，一方面降低了Vt，使延迟更小；另一方面，降低了空穴和电子的迁移率，使延迟更大；而后者的影响比前者更大，所以温度升高会导致管子的延时增加。<ul><li><p>但是一味的降低温度，并不能一直减小延时；因为晶体管存在温度翻转效应，当温度低到一个阈值之后，温度的降低会导致延时的增加。</p><img src="3201119-20230803153453247-516127716.png" width = 60%/></li></ul></li></ul></li></ul><h2 id="4-RC-Corner"><a href="#4-RC-Corner" class="headerlink" title="4. RC Corner"></a>4. RC Corner</h2><ul><li>STA中主要包括五个RC Corner：Cbest、Cworst、RCbest、RCworst 和 RCtypical。<ul><li>Cbest：电容最小，电阻最大；Cworst：电容最大，电阻最小。</li><li>RCbest：耦合电容最大，(对地电容*电阻)最小；RCworst：耦合电容最小，(对地电容*电阻)最大。</li></ul></li><li>Setup sign-off 的RC corner是: Cworst &#x2F; RCworst<ul><li>RC corner的产生是考虑到对于90nm往下的工艺，network的电容占比越来越大。90nm往上的工艺，cell电容占主导。</li><li>对于短线，电容占主导，C corner就可以cover；但是对于长导线，电阻占主导地位，需要RC corner来cover。</li></ul></li><li>Hold time sign-off 的RC corner是: Cbest &#x2F; RCbest &#x2F; Cworst &#x2F; RCworst。<ul><li>为什么对于hold，需要best和worst都考虑？<ul><li>个人理解：不同RC corner以及PVT的组合，对于Hold path delay值较小的部分，四个角都存在，所以signoff需要覆盖所有的corner。</li></ul></li></ul></li><li>如果引入DPT(Double Patterning Technology)，即在同一层layer要做两次mask，两次mask之间可能存在偏差，导致线间距发生变化，从而影响耦合电容值。<ul><li>需要将这一因素考虑到RC Corner中，用于signoff需要额外加corner：Cworst_CCworst, RCworst_CCworst, Cbest_CCbest, RCbest_CCbest.</li></ul></li></ul><h2 id="5-GBA-PBA"><a href="#5-GBA-PBA" class="headerlink" title="5. GBA &amp; PBA"></a>5. GBA &amp; PBA</h2><ul><li>这两种是STA的两种timing分析模式。以下图为例。</li></ul><img src="3201119-20230804172606732-306455573.jpg" width = 60%/><ul><li>GBA (Graph Base Analysis)<ul><li><p>下表为在setup&#x2F;hold分析时，input transition的端口选择。</p><table><thead><tr><th>Gate</th><th>setup 分析</th><th>hold 分析</th></tr></thead><tbody><tr><td>OR</td><td>B</td><td>A</td></tr><tr><td>NAND</td><td>A</td><td>B</td></tr><tr><td>XOR</td><td>A&#x2F;B</td><td>A&#x2F;B</td></tr><tr><td>NAN</td><td>B</td><td>A</td></tr></tbody></table></li><li><p>从上表可以看到，对于setup&#x2F;hold的分析都是选择的最悲观的input transition端口情况进行分析。</p></li></ul></li><li>PBA (Path Base Analysis)<ul><li><p>与GBA分析相同的电路，其端口选择如下表。</p><table><thead><tr><th>Gate</th><th>setup 分析</th><th>hold 分析</th></tr></thead><tbody><tr><td>OR</td><td>A</td><td>A</td></tr><tr><td>NAND</td><td>B</td><td>B</td></tr><tr><td>XOR</td><td>B</td><td>B</td></tr><tr><td>NAN</td><td>A</td><td>A</td></tr></tbody></table></li><li><p>从上表可以看到，分析端口的选择是基于实际的时序路径。</p></li></ul></li><li>PBA &amp; GBA<ul><li>优缺点分析   <ul><li>GBA计算比较悲观，而PBA计算更为真实。</li><li>但是考虑到PBA的计算方式相对复杂，所以 runtime 会比较久。</li></ul></li><li>何时用PBA<ul><li>默认情况下，PT都是使用GBA去进行分析的，如果在signoff时发现有较小（如&lt;5ps）的violation，且已经优化到极致，可以用PBA模式分析，是否可以meet。 </li><li>PBA 模式还分为两种计算模式：Path和Exhaustive<ul><li>Path：基于GBA分析的结果，选择最差的路径重新用PBA计算同样的path.</li><li>Exhaustive：基于每个endpoint，会重新计算这个终点上所有的timing path（最多25000条），然后选择其中最差的path再重新用PBA计算slack。</li><li>可以看到path计算方式并不能保证得到的时真正最差slack的path。但是通常这种方式速度较快，适用于我们想看下pba能带来多少timing的improvement。 </li><li>而exhaustive是最真实的pba计算方式，但是它的runtime非常慢，适合于接近signoff最后阶段，violation的timing path较少时的情况。</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>STA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HLS-循环优化</title>
    <link href="/2023/11/13/HLS-%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96/"/>
    <url>/2023/11/13/HLS-%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/pc153262603/article/details/106385483">https://blog.csdn.net/pc153262603/article/details/106385483</a></li><li><a href="https://www.xilinx.com/htmldocs/xilinx2017_4/sdaccel_doc/fde1504034360078.html">https://www.xilinx.com/htmldocs/xilinx2017_4/sdaccel_doc/fde1504034360078.html</a></li><li><a href="https://hitsz-cslab.oschina.io/dla/lab2/theory/#3">https://hitsz-cslab.oschina.io/dla/lab2/theory/#3</a></li></ul></li></ul><hr><h2 id="1-单个循环延迟优化"><a href="#1-单个循环延迟优化" class="headerlink" title="1. 单个循环延迟优化"></a>1. 单个循环延迟优化</h2><h3 id="1-1-循环展开（Unroll）"><a href="#1-1-循环展开（Unroll）" class="headerlink" title="1.1 循环展开（Unroll）"></a>1.1 循环展开（Unroll）</h3><ul><li>将一个循环展开成多个循环，复制多个循环电路，并行执行；消耗更多的资源换取加速效果。</li><li>例子如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;  <br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> HLS unroll factor=2  </span><br>    a[i] = b[i] + c[i];  <br>&#125;<br>\\等效于<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i=i+<span class="hljs-number">2</span>)<br>&#123;    <br>    a[i] = b[i] + c[i];  <br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i=i+<span class="hljs-number">2</span>)<br>&#123;  <br>    a[i] = b[i] + c[i];  <br>&#125;<br></code></pre></td></tr></table></figure></li><li>这个优化要求循环边界为常数，才可以确定unroll factor设置为多少。</li><li>对于循环次数较大的，展开后可能资源不足，导致unroll 失败；此时需要根据芯片实际资源数量，以及报错信息对factor进行调整。</li></ul><h3 id="1-2-循环展平（Flatten）"><a href="#1-2-循环展平（Flatten）" class="headerlink" title="1.2 循环展平（Flatten）"></a>1.2 循环展平（Flatten）</h3><ul><li>相当于将内层循环合并到外层循环上，节省从内层循环过渡到外层循环时条件判断的延迟。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M; i++)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; N; j++)<br>    &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> HLS loop_flatten</span><br>        <span class="hljs-comment">// Loop body</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//等效于</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M*N; i++)<br>    <span class="hljs-comment">// Loop body</span><br></code></pre></td></tr></table></figure></li><li>Flatten要求循环是完美循环&#x2F;半完美循环。<ul><li>完美循环：循环的边界是常数，且循环体只出现在最内层循环。</li><li>半完美循环：外循环的边界可以是变量，但内循环边界必须是常数；且循环体只能出现在最内层循环。</li></ul></li></ul><h2 id="2-多个循环的并行优化"><a href="#2-多个循环的并行优化" class="headerlink" title="2. 多个循环的并行优化"></a>2. 多个循环的并行优化</h2><h3 id="2-1-循环合并"><a href="#2-1-循环合并" class="headerlink" title="2.1 循环合并"></a>2.1 循环合并</h3><ul><li>即使多个循环之间<strong>完全独立</strong>，Vivado HLS默认是顺序执行，共要消耗A+B个周期。但是若将两种循环合并，那么只需要消耗max(A,B)个周期。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span> <span class="hljs-params">(...)</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> HLS loop_merge</span><br>    L1: <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        <span class="hljs-comment">// Loop body of L1</span><br><br>    L2: <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        L3: <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++)<br>            <span class="hljs-comment">// Loop body of L3</span><br><br>    L4: <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">13</span>; i++)<br>        <span class="hljs-comment">// Loop body of L4</span><br>&#125;<br><span class="hljs-comment">//等效于</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span> <span class="hljs-params">(...)</span> </span>&#123;<br>    MERGED: <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* condition1 */</span>)<br>            <span class="hljs-comment">// Loop body of L1</span><br><br>        <span class="hljs-comment">// Flattened loop body of L3</span><br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* condition4 */</span>)<br>            <span class="hljs-comment">// Loop body of L4</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>合并时应注意<ul><li>如果合并前，所有循环边界为常数，那么合并后的循环边界应该为常数间最大值。</li><li>如果合并前，所有循环边界为变量，则循环边界必须相同。</li><li>如果合并前，部分循环边界为变量，部分为常数，那么不能合并。</li></ul></li></ul><h3 id="2-2-循环函数化"><a href="#2-2-循环函数化" class="headerlink" title="2.2 循环函数化"></a>2.2 循环函数化</h3><ul><li>如果两个循环的边界不同，则不能合并。但是可以将循环封装成子函数，实现并行。</li><li>注意需要使用#pragma HLS inline off来防止内联。<ul><li>HLS inline：去除子函数层次结构，使用内联操作使自身逻辑融入调用函数中。内联后的函数不能共享或重用。</li></ul></li></ul><h3 id="2-3-数据流-Dataflow"><a href="#2-3-数据流-Dataflow" class="headerlink" title="2.3 数据流 Dataflow"></a>2.3 数据流 Dataflow</h3><ul><li>对于2个循环存在数据依赖关系时，不管循环合并或是循环函数化，都没有办法实现循环之间的并行；但是可以通过数据流实现。  </li><li>举例如下<ul><li>如果是非数据流执行方式，那么LOOP_2需要等待LOOP_1执行完成之后才能执行。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span> <span class="hljs-params">(<span class="hljs-type">int</span> A[N], <span class="hljs-type">int</span> C[N], <span class="hljs-type">int</span> num)</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> HLS dataflow</span><br>    <span class="hljs-type">int</span> acc = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> B[N];<br><br>    LOOP_1: <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> HLS PIPELINE II=1</span><br>        acc += A[i];<br>        B[i] = acc;<br>    &#125;<br><br>    LOOP_2: <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> HLS PIPELINE II=1</span><br>        C[i] = B[i] * num;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>Dataflow一般会在循环之间插入缓存，如果循环之间依靠变量传递数据，那么HLS会插入FIFO缓存；如果循环间依靠数组传数据，那么HLS会插入Ping-Pong RAM。</li><li>由于存在循环到循环之间的缓存通路，所以只要LOOP_1中的数据输出就可以用于LOOP_2中的运算。多个任务间可以有交叠，降低延迟，提高数据吞吐率。</li><li>注意<ul><li>循环之间数据只能顺序流动，不能有反馈回路。</li><li>数据流只能从一个循环流出到另一个循环，single-producer,single-consumer.</li><li>循环不能在条件语句内。</li></ul></li></ul><h2 id="3-吞吐量优化：循环-pipeline"><a href="#3-吞吐量优化：循环-pipeline" class="headerlink" title="3. 吞吐量优化：循环 - pipeline"></a>3. 吞吐量优化：循环 - pipeline</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> HLS pipeline II=<span class="hljs-string">&lt;int&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>对于下面左图中，RD距离下次RD间隔3个周期，即II&#x3D;3；而右图II&#x3D;1.若不指定，则默认为1.<ul><li>很明显，II &#x3D; 1时，性能最好。但是代码中可能会因为数据依赖关系&#x2F;存储器读写出现的冒险情况（具体可看流水线相关知识），而导致不满足设定的II；此时需要进行相应的优化，如消除依赖关系，数组划分等；后面有介绍。</li></ul></li></ul><p><img src="/2023/11/13/HLS-%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96/3201119-20230629132733357-648986508.png"></p><ul><li>如果#pragma HLS pipeline 语句作用于嵌套循环的外层循环，那么需要将pragma下面所有的内层循环完全unroll。此时，如果循环边界为变量或展开后资源不够，那么展开会失败。<ul><li>若作用于函数，那么函数内所有循环都会被展开，同样存在导致展开失败的情况。</li></ul></li></ul><h2 id="4-吞吐量优化：循环-dataflow"><a href="#4-吞吐量优化：循环-dataflow" class="headerlink" title="4. 吞吐量优化：循环 - dataflow"></a>4. 吞吐量优化：循环 - dataflow</h2><ul><li>“3”中介绍的是细粒度的流水线架构，而数据流可以实现粗粒度的流水线，具体实现与”2.3”相同。</li></ul><hr><ul><li>与循环优化无关的语句<ul><li>pragma HLS loop_tripcount<ul><li>手动指定循环执行总的迭代次数，仅用于分析，不影响综合结果。</li><li>可以指定max，min，average。<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">loop_1: for(i=<span class="hljs-number">0</span>;i&lt; num_samples;i++) &#123;<br>#pragma HLS loop_tripcount <span class="hljs-keyword">min</span>=<span class="hljs-number">12</span> <span class="hljs-keyword">max</span>=<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure></li></ul></li><li>pragma HLS allocation limit &#x3D; <code>&lt;value&gt;</code><ul><li>限制实例化硬件电路的个数，如果实例超过limit值，那么会多次复用。有助于减少使用资源。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
      <category>HLS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HLS-数组优化</title>
    <link href="/2023/11/13/HLS-%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96/"/>
    <url>/2023/11/13/HLS-%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/zhangningning1996/article/details/107444387">https://blog.csdn.net/zhangningning1996/article/details/107444387</a></li><li><a href="https://blog.csdn.net/pc153262603/article/details/106385483">https://blog.csdn.net/pc153262603/article/details/106385483</a></li><li><a href="https://www.xilinx.com/htmldocs/xilinx2017_4/sdaccel_doc/eil1504034361560.html">https://www.xilinx.com/htmldocs/xilinx2017_4/sdaccel_doc/eil1504034361560.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/50479555">https://zhuanlan.zhihu.com/p/50479555</a></li></ul></li></ul><hr><h2 id="1-复杂度"><a href="#1-复杂度" class="headerlink" title="1. 复杂度"></a>1. 复杂度</h2><ul><li>程序的两个衡量指标：时间复杂度和空间复杂度。<ul><li>衡量一个算法的时间复杂度和空间复杂度可以使用大O标识法。  </li><li>时间复杂度<ul><li>对于没有循环等复杂结构，时间复杂度为O(1)；</li><li>主要计算何时才可以跳出循环，所以循环结构越复杂的，时间复杂度越大。</li></ul></li><li>空间复杂度<ul><li>是对一个算法在运行过程中临时占用存储空间大小的一个量度。</li><li>对于所需要的临时空间都不随算法处理数据量变化，空间复杂度为1.</li><li>观察算法在运行过程中是否申请了新的空间，空间的大小为空间复杂度，很多情况下与数组的大小相关。</li></ul></li><li>时间和空间复杂度是相互影响的，想要较好的时间复杂度，可能会牺牲空间复杂度，反之一样。</li></ul></li></ul><h2 id="2-Partition展开操作"><a href="#2-Partition展开操作" class="headerlink" title="2. Partition展开操作"></a>2. Partition展开操作</h2><ul><li><p>为什么Partition可以提升性能</p><ul><li>HLS将数组映射到Memory中。如果数组是作为顶层函数的形参，那么就会被综合成memory的接口；如果数组在设计内部，会根据数组大小及优化方式被综合成移位寄存器（大小&lt;1024）&#x2F;BRAM,LUTRAM,UltraRAM（大小&gt;1024）。</li><li>存在的问题<ul><li><p>当数组作为存储器来实现时，存储器端口的数量会限制对数据的访问，可能导致流水线失败。</p></li><li><p>假设一数组用单端口RAM实现，功能：扫描数组，依次访问连续三个地址的数据求和；此时每个周期只能进行一次读&#x2F;写，无法实现流水线。</p><ul><li>若想实现吞吐量为1，需要预读取数据，并手动对数据访问流水打拍。</li></ul><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs smali"> dout_t array_mem_perform(din_t mem[N]) &#123; <br> <br> din_t tmp0, tmp1, tmp2;<br> dout_t sum=0;<br><span class="hljs-built_in"> int </span>i;<br> <br> tmp0 = mem[0];<br> tmp1 = mem[1];<br> SUM_LOOP:for (i = 2; i &lt; N; i++) &#123;<br> tmp2 = mem[i];<br> sum += tmp2 + tmp1 + tmp0;<br> tmp0 = tmp1;<br> tmp1 = tmp2;<br> &#125;<br>     <br><span class="hljs-built_in"> return </span>sum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>即使使用双端口的RAM，每个时钟周期可进行两次访问，计算一个和，打一拍可以与第三次访问的值再次求和，组成一流水。（我的理解是这样，不太清楚是不是正确的。）</p></li></ul></li><li>可以不用更改设计，HLS可以使用优化指令：<strong>Array Partition、Array Reshape.</strong></li></ul></li><li><p>Array Partition </p><ul><li>将原先一个大的memory拆分成多个小的memory&#x2F;registers，增加了存储器的读写端口。提高了设计的吞吐量，但是需要更多的内存&#x2F;寄存器资源。</li><li>有3个type可选：block、cyclic和complete<ul><li>factor为n，将原数组等分成n个小的数组，每个数组的长度 &#x3D; 原长度&#x2F;n。</li><li>以一维数组为例，如下图<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso">#param HLS ARRAY_PARTITION <span class="hljs-built_in">variable</span>=weight_group block factor = <span class="hljs-number">4</span> dim = <span class="hljs-number">1</span><br>#param HLS ARRAY_PARTITION <span class="hljs-built_in">variable</span>=weight_group cyclic factor = <span class="hljs-number">4</span> dim = <span class="hljs-number">1</span><br>#param HLS ARRAY_PARTITION <span class="hljs-built_in">variable</span>=weight_group complete dim = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><img src="3201119-20230614163220222-364963959.png" width = 50%/><ul><li>对多维数组采用Partition展开。当dim&#x3D;0时，数组所有维度都被拆开。</li></ul></li></ul><img src="3201119-20230614163729467-1143607101.png" width = 50%/><h2 id="3-数组的映射和重组"><a href="#3-数组的映射和重组" class="headerlink" title="3. 数组的映射和重组"></a>3. 数组的映射和重组</h2><h3 id="3-1-ARRAY-MAP"><a href="#3-1-ARRAY-MAP" class="headerlink" title="3.1 ARRAY_MAP"></a>3.1 ARRAY_MAP</h3><ul><li>将多个较小的数组映射成一个数组，以减少RAM资源。FPGA中提供的最小RAM单元大小为18KB，如果很多小数组没有很好的使用完整的18K，可以使用MAP指令，将许多小数组映射到一个更大的数组中。</li><li>Horizontal：直接将多个数组拼接在一起，数组的长度等于N+M，数组的宽度为N和M的最大数组宽度。</li></ul><img src= "3201119-20230614164743438-1243927523.png" width = 50%/>  <ul><li>Vertical：对于数组的每一个元素进行拼接，数组的长度等于N&#x2F;M中最大的长度。</li></ul><img src= "3201119-20230614165614445-1380595643.png" width = 40%/>  <ul><li>命令介绍：其中variable是被map的数组；instance是map后的数组；mode可选horizontal&#x2F;vertical；offset仅horizontal可选，int为合并的数组相较于0的偏移量。<ul><li>注：命令相关例子和用法可以查看<a href="https://www.xilinx.com/htmldocs/xilinx2017_4/sdaccel_doc/eil1504034361560.html">Xilinx官网</a>，有较为全面的解释。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> HLS array_map variable=<span class="hljs-string">&lt;name&gt;</span> instance=<span class="hljs-string">&lt;instance&gt;</span> <span class="hljs-string">&lt;mode&gt;</span> offset=<span class="hljs-string">&lt;int&gt;</span></span><br><span class="hljs-comment">//example 将C和D合并成CD</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> HLS array_map variable=C instance=CD vertical</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> HLS array_map variable=D instance=CD vertical</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-2-ARRAY-RESHAPE"><a href="#3-2-ARRAY-RESHAPE" class="headerlink" title="3.2 ARRAY_RESHAPE"></a>3.2 ARRAY_RESHAPE</h3><ul><li>两步：将数组进行Partition + vertical MAP。</li><li>减少了RAM的数量，组成新的数组，元素更少，但位宽更大，允许在单个时钟周期内访问更多的数据。<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> HLS ARRAY_RESHAPE variable=array1 block factor=2 dim=1</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> HLS ARRAY_RESHAPE variable=array2 cycle factor=2 dim=1</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> HLS ARRAY_RESHAPE variable=array3 complete dim=1</span><br></code></pre></td></tr></table></figure>  <img src="/2023/11/13/HLS-%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96/3201119-20230614215724114-908302541.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
      <category>HLS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Vivado-HLS</title>
    <link href="/2023/11/13/%E5%85%B3%E4%BA%8EVivado-HLS/"/>
    <url>/2023/11/13/%E5%85%B3%E4%BA%8EVivado-HLS/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/qq_39507748/article/details/114411155">https://blog.csdn.net/qq_39507748/article/details/114411155</a></li><li><a href="https://www.cnblogs.com/dadaozhijian22/p/9523510.html">https://www.cnblogs.com/dadaozhijian22/p/9523510.html</a></li></ul></li></ul><hr><h2 id="1-用来作什么"><a href="#1-用来作什么" class="headerlink" title="1. 用来作什么"></a>1. 用来作什么</h2><ul><li>HLS(High Level Synthesis)</li><li>Xilinx推出的可以直接使用C&#x2F;C++&#x2F;SystemC对Xilinx系列的FPGA进行编程，提高抽象等级，减少开发时间。</li><li>数字IC设计过程中不同的抽象等级：</li></ul><img src="3201119-20230614143018239-1102110734.png"><ul><li>这里引申一下行为级和RTL级的区别<ul><li>RTL级：寄存器传输级，使用寄存器这一级别的描述方式来描述，要求可综合，</li><li>行为级：通过行为语句描述电路要实现的功能，而不涉及具体结构，不考虑电路实现。</li></ul></li><li>HLS在系统级对电路算法进行描述，然后由Vivado HLS编译器将C代码综合成HDL描述，之后再进行逻辑综合，得到的网表可以直接映射到FPGA的器件上。</li></ul><h2 id="2-HLS-综合过程"><a href="#2-HLS-综合过程" class="headerlink" title="2. HLS 综合过程"></a>2. HLS 综合过程</h2><ul><li>分析，处理基于C的代码，加上用户所给出的指令和约束，来创建RTL描述，综合结束后得到Verilog&#x2F;VHDL编写的RTL设计文档。</li><li>综合得到的RTL模型，可以放到HLS中进行C&#x2F;RTL的协同仿真，Vivado HLS会自动产生一个测试集，进一步验证RTL设计的正确性。</li></ul><h2 id="3-验证之后的打包"><a href="#3-验证之后的打包" class="headerlink" title="3. 验证之后的打包"></a>3. 验证之后的打包</h2><ul><li>使用Vivado HLS的IP打包功能，那么HLS设计可以以IP核的形式被用到其它Xilinx工具中。</li></ul><h2 id="4-接口综合-算法综合"><a href="#4-接口综合-算法综合" class="headerlink" title="4. 接口综合 &amp; 算法综合"></a>4. 接口综合 &amp; 算法综合</h2><ul><li>做HLS时，设计者需要注意 接口综合以及算法综合。</li></ul><img src="3201119-20230614150224724-608335972.png" width = 50%/><ul><li>接口综合<ul><li>指接口类型及接口使用的协议，通过工具接口综合获取代码中参数、返回值（类型、位宽、方向）以及端口行为（协议）得到，也可以自己为接口选择协议。</li></ul></li><li>算法综合<ul><li>从代码中推断出各种运算操作，转换成RTL语句。主要包括以下三个阶段<ul><li>（1）解析出数据通路和控制元件</li><li>（2）调度和绑定<ul><li>调度是把由 C 代码解释得到的 RTL 语句翻译成一组运算。</li><li>绑定是调度好了的运算和目标芯片上的实际资源联系起来的过程。资源的功能和时序特性可能会影响调度，所以绑定得到的信息还会反馈给调度。</li></ul></li><li>（3）优化<ul><li>设计者对设计的某些指标以及资源的利用情况加以限制（如时钟），对设计进行优化。</li><li>施加指令，映射到代码的某些特征上，比如可以指定HLS如何处理C识别出来的循环或数组。</li></ul></li></ul></li></ul></li></ul><h2 id="5-HLS库"><a href="#5-HLS库" class="headerlink" title="5. HLS库"></a>5. HLS库</h2><ul><li>包含了一系列的库，可以更方便的建模和综合。</li></ul>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
      <category>HLS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于DMA（三）</title>
    <link href="/2023/11/10/%E5%85%B3%E4%BA%8EDMA%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2023/11/10/%E5%85%B3%E4%BA%8EDMA%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://www.st.com/resource/zh/application_note/an4031-using-the-stm32f2-stm32f4-and-stm32f7-series-dma-controller-stmicroelectronics.pdf">https://www.st.com/resource/zh/application_note/an4031-using-the-stm32f2-stm32f4-and-stm32f7-series-dma-controller-stmicroelectronics.pdf</a></li></ul></li></ul><hr><h2 id="1-DMA-中断"><a href="#1-DMA-中断" class="headerlink" title="1. DMA 中断"></a>1. DMA 中断</h2><ul><li>半传输中断；</li><li>传输完成；</li><li>传输错误；</li><li>FIFO下溢或上溢；</li></ul><h2 id="2-DMA-传输状态"><a href="#2-DMA-传输状态" class="headerlink" title="2. DMA 传输状态"></a>2. DMA 传输状态</h2><ul><li>外设到存储器<ul><li>外设首先发起请求，送入DMAC的仲裁模块，决定哪个外设可以进行数据传输。</li><li>外设地址计算。</li><li>DMA接收到数据，并将数据送入FIFO中（直接模式下没有FIFO）。</li><li>存储器端口的访问可以由FIFO达到阈值后触发（突发传输，使用FIFO模式）或DMA拿到数据之后立即触发（使用直接模式）。 </li><li>存储器端口仲裁，决定向哪个存储器写入数据。</li><li>存储器地址计算。</li><li>向存储器写入数据。</li></ul></li><li>存储器到外设<ul><li>存储器端口仲裁，决定从哪个存储器读出数据。</li><li>存储器地址计算。</li><li>从存储器中取出数据存在FIFO中，以保证DMA获得总线使用权后可以立即进行数据传输。 </li><li>外设端口仲裁。</li><li>外设地址计算。</li><li>向外设地址写入数据。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
      <category>DMA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于DMA（二）</title>
    <link href="/2023/11/10/%E5%85%B3%E4%BA%8EDMA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/11/10/%E5%85%B3%E4%BA%8EDMA%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://www.st.com/resource/zh/application_note/an4031-using-the-stm32f2-stm32f4-and-stm32f7-series-dma-controller-stmicroelectronics.pdf">https://www.st.com/resource/zh/application_note/an4031-using-the-stm32f2-stm32f4-and-stm32f7-series-dma-controller-stmicroelectronics.pdf</a></li></ul></li></ul><hr><h2 id="1-DMA-数据流-通道"><a href="#1-DMA-数据流-通道" class="headerlink" title="1. DMA 数据流&#x2F;通道"></a>1. DMA 数据流&#x2F;通道</h2><ul><li>以STM32F2为例介绍数据流和通道的概念。<ul><li>一个DMA控制器可以提供8个数据流，每个数据流有8个可选通道。 </li><li>在一个数据流中，同一时刻，只有一个通道&#x2F;请求是有效的，是一个多选1的MUX结构。</li><li>8个数据流有8个请求，根据DMA内部的仲裁算法得到响应哪个请求。请求间的优先级可以通过软件编程配置，一共有4个等级。软件优先级一致时，可由硬件优先级决定（数据0比数据1优先级高）。<ul><li>DMA优先级设定建议<ul><li>高速&#x2F;大带宽外设分配最高的DMA优先级，避免过载&#x2F;欠载状态。</li><li>带宽需求相同情况下，工作在从模式（不可控制数据传输速度）的外设 比 工作在主模式（可以控制数据流量）下的外设分配更高的优先级。</li><li>对于总线矩阵，两个DMA可以并行工作，可以将多个高速外设的请求在两个DMA之间平均分配。</li></ul></li></ul></li></ul></li></ul><img src="3201119-20230619144428520-1969438541.png" width = 70%/><h2 id="2-DMAC主从端口"><a href="#2-DMAC主从端口" class="headerlink" title="2. DMAC主从端口"></a>2. DMAC主从端口</h2><ul><li>DMA有两个AHB的主端口，存储器端口和外设端口。<ul><li>存储器端口，用于连接到存储器；</li><li>外设端口，用于连接到外设；但是考虑到DMA有存储器到存储器的传输方向，所以外设端口好要求能够访问存储器。</li></ul></li><li>DMA有一个AHB的从端口，用于对DMAC的寄存器进行编程。 </li><li>观察下图，可以看到DMA1的AHB外设端口不像DMA2的外设端口连接到AHB Matrix中，所以只有DMA2可以实现存储器到存储器的数据传输。</li></ul><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8EDMA%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230619160106844-274562361.png"></p><h2 id="3-DMA传输参数"><a href="#3-DMA传输参数" class="headerlink" title="3. DMA传输参数"></a>3. DMA传输参数</h2><ul><li>源和目标地址；</li><li>传输数据量大小：由数据量寄存器 DMA_SxNDTR 配置值决定；</li><li>源和目标数据宽度：可选，字节、半字以及字。</li><li>传输类型<ul><li>正常模式：数据量寄存器 DMA_SxNDTR 自减到0，传输停止。</li><li>循环模式：数据量寄存器 DMA_SxNDTR 自减到0后会自动重载预先设置的值。进行下一轮的传输。</li></ul></li></ul><h2 id="4-DMA-FIFO"><a href="#4-DMA-FIFO" class="headerlink" title="4. DMA FIFO"></a>4. DMA FIFO</h2><ul><li><p>每个数据流都有自己独立的4字FIFO，深度为4；位宽为32bit，4个字节。FIFO的阈值可以调节为1&#x2F;4，1&#x2F;2，3&#x2F;4或满。 </p></li><li><p>从上面图中可以看到，FIFO主要用于缓存DMA输入到输出传输的数据。可通过软件配置FIFO的使能，禁用时，为直接模式。</p></li><li><p>FIFO的作用</p><ul><li>FIFO可以对数据进行打包或拆包，以适应源和目标数据位宽不一致。</li></ul><img src="3201119-20230619163616971-1743897772.png" width = 70%/><ul><li>FIFO和突发传输一起使用，使用FIFO缓存一次突发传输所需要的数据量，相较于单次传输，提高了CPU的效率。<ul><li><p>FIFO深度的阈值一定要是突发传输beat的整数倍。</p>  <img src="3201119-20230619164046301-1790504661.png" width = 70%/></li></ul></li></ul></li></ul><h2 id="5-双缓冲区模式"><a href="#5-双缓冲区模式" class="headerlink" title="5. 双缓冲区模式"></a>5. 双缓冲区模式</h2><ul><li>DMA中有寄存器指定源地址和目标地址，对于外设到存储器方向，考虑循环模式下，DMA不断向存储器目标地址写数据，当传输数据量减少至0时，产生一次中断；数据量会自动重载预先的值，进行下一轮的传输，那么这个地址区间的数据可能还来不及被处理就又被新的数据覆盖。</li><li>为了解决上面的问题，增加了一个新的目标地址DMA_SxM1AR的存储区域，在第一轮传输结束后，寄存器CT(Current Target)位指向1，存储器指针也从存储器区域0跳到存储器区域1。</li></ul><img src="3201119-20230619172004771-1769734483.png" width = 70%/><ul><li>当DMA传输的存储目标是存储区域0时，存储区域1的基地址可以被更新；反之一样。</li><li>存储器到外设也可以实现双缓冲区模式，DMA先读完地址1的数据之后，因为是循环，所以马上又开始传输数据，此时变更读地址为2。就不会出现反复读一个地址区间的数据。</li><li>考虑到存储器到存储器方向不支持循环模式，所以该方向也没有双缓冲区模式。（为什么不支持我也不太清楚，st论坛中提到实际测试时可以同时使用😢）</li><li>这里可以引申<strong>半传输中断的概念</strong>，如果MCU不支持DMA双缓冲，可以使用半传输中断来实现同样的乒乓操作。<ul><li>可以将一个缓冲区划分为两部分，完成一半的传输之后，发起半传输中断，并继续接收数据，直到数据量减至0，产生满中断，这样可以实现处理一半缓冲区域数据，同时接收另一半的数据。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
      <category>DMA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于DMA（一）</title>
    <link href="/2023/11/10/%E5%85%B3%E4%BA%8EDMA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/11/10/%E5%85%B3%E4%BA%8EDMA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/zhejfl/article/details/82555634">https://blog.csdn.net/zhejfl/article/details/82555634</a></li><li><a href="https://blog.csdn.net/qq_25814297/article/details/109256809">https://blog.csdn.net/qq_25814297/article/details/109256809</a></li></ul></li></ul><hr><h2 id="1-CPU与外设数据传送方式"><a href="#1-CPU与外设数据传送方式" class="headerlink" title="1. CPU与外设数据传送方式"></a>1. CPU与外设数据传送方式</h2><ul><li>主要有程序传送方式和中断传送方式。</li><li>程序传送方式<ul><li>在程序控制下进行数据输入&#x2F;输出操作，分为无条件（无需考虑外设状态，直接IN&#x2F;OUT指令输出）和查询（在IN&#x2F;OUT指令前，需要查询设备状态）两种。</li></ul></li><li>中断传送方式<ul><li>外设向CPU发起请求，CPU暂停正在执行的程序，去传输数据给外设，传输结束后。CPU再继续被暂停的程序。</li></ul></li><li>程序传送方式和中断传送方式的区别<ul><li>前者为CPU主动发起，轮询外设，效率低。</li><li>后者为外设主动发起，等待CPU处理，但是<strong>需要进行断点和现场的保护和恢复，浪费CPU时间，适合少量数据的传输。</strong></li></ul></li><li>下图列出了CPU程序传送方式、中断传送方式以及DMA传送方式的CPU使用情况。（图源不知道是哪里，有点糊。）</li></ul><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8EDMA%EF%BC%88%E4%B8%80%EF%BC%89/3201119-20230619103536811-196767221.png"> </p><h2 id="2-DMA-批量数据传输"><a href="#2-DMA-批量数据传输" class="headerlink" title="2. DMA 批量数据传输"></a>2. DMA 批量数据传输</h2><h3 id="2-1-传输方向"><a href="#2-1-传输方向" class="headerlink" title="2.1 传输方向"></a>2.1 传输方向</h3><ul><li>存储器到外设</li></ul><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8EDMA%EF%BC%88%E4%B8%80%EF%BC%89/3201119-20230619142642039-262400331.png"></p><ul><li>外设到存储器</li></ul><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8EDMA%EF%BC%88%E4%B8%80%EF%BC%89/3201119-20230619142617331-2035675790.png"></p><ul><li>存储器到存储器</li></ul><p><img src="/2023/11/10/%E5%85%B3%E4%BA%8EDMA%EF%BC%88%E4%B8%80%EF%BC%89/3201119-20230619142711559-810710251.png"></p><h3 id="2-2-传输过程"><a href="#2-2-传输过程" class="headerlink" title="2.2 传输过程"></a>2.2 传输过程</h3><ul><li>（1）请求<ul><li>CPU配置DMA相关寄存器：<ul><li>控制命令寄存器，配置传输数据的发起方式、数据大小、通道。</li><li>初始地址寄存器，DMAC根据该地址寄存器的值，进行寻址传输数据。</li></ul></li><li>之后向I&#x2F;O接口发出操作命令；外设向DMA控制器发出请求，有单独请求信号线，而不是走AHB总线。</li></ul></li><li>（2）响应<ul><li>DMA控制器对 多个DMA请求 判断优先级以及是否屏蔽请求，之后向总线仲裁模块提出总线请求。</li><li>当CPU执行完当前任务即可释放总线控制权。DMA控制器获得总线控制权后便开始传输。</li></ul></li><li>（3）传输<ul><li>DMA拿到总线控制权后，CPU无法使用总线，所以它挂起或只执行内部操作；DMA控制器直接控制内部存储器与外设之间的数据交互。</li></ul></li><li>（4）结束<ul><li>完成数据传送后，DMA控制器释放总线控制权，并向外设发出结束信号，外设需要结束数据传输工作，并向CPU提出中断请求。</li><li>CPU执行中断服务程序，检验DMA传输过程是否出错，以及是否要继续使用DMA传送其它数据块。</li></ul></li></ul><h2 id="3-DMA-CPU-内存分配"><a href="#3-DMA-CPU-内存分配" class="headerlink" title="3. DMA &amp; CPU 内存分配"></a>3. DMA &amp; CPU 内存分配</h2><ul><li>DMA传输需要对内存进行操作，而CPU在DMA传输过程中仍可以继续工作，可能也会对内存进行操作，这就涉及到DMA和CPU怎么分时使用内存。通常有3种传送方式：<ul><li>（1）停止CPU访问内存<ul><li>DMA控制器向仲裁器申请总线控制权时，CPU交出控制权，处于不工作状态或者保持状态。</li><li>优点：控制简单；</li><li>缺点：考虑到外设传送两个数据之间的间隔一般大于内存的存储周期，例如，外设读出两个数据之间的间隔大概32us，内存的存储周期大概为0.5us，那么内存就有31.5us（63个内存周期）的空闲。</li></ul></li><li>（2）周期挪用（较为常用）<ul><li>DMA访问内存和CPU访问内存没有冲突。<ul><li>例如，CPU正在执行乘法操作，从内存取出数据之后可能还要消耗一些周期，此时DMA挪用一两个内存周期也不会影响CPU的程序执行。</li></ul></li><li>DMA访问内存和CPU访问内存有冲突。<ul><li>需要优先DMA（I&#x2F;O）访内，因为I&#x2F;O访问内存有时间要求，这个数据必须在下一个I&#x2F;O访问请求之前存取&#x2F;读出完毕。</li><li>此时可以在CPU访问内存过程中插入DMA请求，挪用一两个CPU的内存周期，用于DMA的数据存取；延缓了CPU对内存空间的操作。</li><li>但是DMA每次挪用需要有申请总线控制权、归还总线控制权的过程，所以每次读取一个字对于内存来说可能只要一个周期，但是对于DMA控制器却要2-5个内存周期。但是好在大部分的外设读写周期都要大于内存存储周期。</li></ul></li></ul></li><li>（3）DMA和CPU交替访问内存<ul><li>主要适用于CPU工作周期比内存存取周期长的多情况。<ul><li>例如CPU周期为1.2us，内存存取小于0.6us，这样就可以将一个CPU周期分为C1和C2两个周期，其中C1为DMA访问内存，C2为CPU访问内存。</li></ul></li><li>这种方式不必像（2）中一样需要总线使用权的申请和归还过程，因为总线使用权是C1和C2分时制的。对于总线来说，输入的数据、地址、控制信号等是由C1,C2周期控制的多路选择器的输出。</li><li>这种方式CPU不会停止主程序的运行，也不会进入等待状态，效率是三种方式中最高的，但是相应的硬件逻辑也更复杂。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
      <category>DMA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ICC-Route</title>
    <link href="/2023/11/08/ICC-Route/"/>
    <url>/2023/11/08/ICC-Route/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/Tao_ZT/article/details/102456916">https://blog.csdn.net/Tao_ZT/article/details/102456916</a></li></ul></li></ul><hr><h2 id="1-关于-Route"><a href="#1-关于-Route" class="headerlink" title="1. 关于 Route"></a>1. 关于 Route</h2><ul><li>Route的主要目标<ul><li>满足timing的要求，如setup&#x2F;hold&#x2F;removal&#x2F;recovery等。</li><li>满足DRC的要求，例如：transition&#x2F;capacitance，以及不能有short&#x2F;open。</li></ul></li><li>Route 绕线规则<ul><li><p>standard cell 的 pg rail可以采用M1,M2，M3。standard cell 的pin脚一般采用M1.  </p></li><li><p>Width and Spacing Rule</p><ul><li>原有一个最小宽度和间距对应的规则要求，如下图蓝色模块所示。<ul><li>但是若两侧金属宽度增加，那么间距也需要相对应的增加。即Width-Based Spacing。</li></ul></li></ul><img src="3201119-20230824144922635-1368228758.png" width = 50%/></li><li><p>需要满足DRC。</p></li></ul></li></ul><h2 id="2-Crosstalk"><a href="#2-Crosstalk" class="headerlink" title="2. Crosstalk"></a>2. Crosstalk</h2><ul><li>Crosstalk的危害<ul><li>delta delay  <ul><li><p>如下图所示，串扰可能会影响受害者信号，导致增加&#x2F;减小延时。</p><img src="3201119-20230824231159590-1603438839.png" width = 50%/><img src="3201119-20230824231359249-463379969.png" width = 50%/></li><li><p>延时的改变可能会导致setup&#x2F;hold出现违例，使电路无法正常工作。所以无论是ICC&#x2F;PT，都需要将delta delay的延时考虑在内。</p></li><li><p>可以使用下面指令查看delta_delay值的大小。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">report_timing</span></span> -crosstalk_delta ...<br></code></pre></td></tr></table></figure></li><li><p>可能Launch路和Capture路都有delta delay的影响，工具会根据是setup&#x2F;hold分析，决定一个最保守的加&#x2F;减法运算于原先时序路径上。</p></li></ul></li><li>glitch&#x2F;bump<ul><li>Crosstalk导致的glich&#x2F;bump可能会出现Logic Failure，可能会进一步导致芯片功能的错误。</li><li>所以在PT的时候，需要去考虑signal integrity。在后面的文章有详细介绍。</li></ul></li></ul></li><li>如何避免&#x2F;修复Crosstalk<ul><li>Crosstalk 影响相关因素<ul><li>与Aggressor和Victim驱动单元的驱动能力有关，Aggressor的驱动能力越大，Victim的驱动能力越小，那么对Victim的影响就越大，反之亦然。<ul><li>所以可以将Aggressor的驱动size down，而Victim的驱动size up。但是size down可能会出现时序 violation。</li></ul></li><li>与两根金属线之间的耦合电容相关，而这个电容值的大小与两条金属线长和间隔距离相关。   <ul><li>所以可以将长长的金属线打断，中间插入buffer。</li></ul></li></ul></li><li>对一些关键的信号加shielding&#x2F;NDR。<ul><li>shielding可以加在较强&#x2F;关键信号线的两侧，接上电源线&#x2F;地线（一般为地线），此时信号线之间的耦合电容变成信号线和地线之间的电容。</li><li>缺点如下 <ul><li>shielding导致一个特定区域走线变少，导致成本提高很多。</li><li>上面也有提到，信号线之间的电容变成了信号线和地之间的电容，而这个接地电容会增加信号线的负载，可能会对时序有负面影响。</li></ul></li><li>NDR，一般采用增大线宽和间距，并使用高层金属走线，也会导致成本的增加。</li></ul></li><li>在route_opt之前设置下面指令<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">set_si_options -static_noise <span class="hljs-literal">true</span> <span class="hljs-string">\</span><br>               -static_noise_threshold_above_low <span class="hljs-number">0.35</span> <span class="hljs-string">\</span><br>               -static_noise_threshold_below_high <span class="hljs-number">0.35</span><br>set_si_options -delta_delay <span class="hljs-literal">true</span> <span class="hljs-string">\</span><br>               -route_xtalk_prevention_true <span class="hljs-string">\</span><br>               -route_xtalk_prevention_threshold <span class="hljs-number">0.25</span> <span class="hljs-string">\</span><br>               -analysis_effort medium <br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-Route-流程"><a href="#3-Route-流程" class="headerlink" title="3. Route 流程"></a>3. Route 流程</h2><h3 id="3-1-Initial-Route"><a href="#3-1-Initial-Route" class="headerlink" title="3.1 Initial Route"></a>3.1 Initial Route</h3><ul><li><p>Pre - Route 基本过程</p><ul><li><p>（1）Global Route</p><ul><li><p>Router会将整个区域划分为若干个大小相等的小格子GRC(Global Routing Cell)，每个小格子能通过的绕线资源是有限的。 如果超过这个能承受的值，就认为是发生阻塞。</p></li><li><p>GR阶段，router会绕开congested区域，而且也会绕开P&#x2F;G-Shape(Rings&#x2F;Straps&#x2F;Rails)和Routing Blockages。</p><img src="3201119-20230824151559561-1851610570.png" width = 40%/></li></ul></li><li><p>（2）Track Assign</p><ul><li>分配track，并尽量走较长的直线，避免多处拐弯。尽量减少通孔数量。</li><li>TA这步并不做DRC检查或修正。</li></ul></li><li><p>（3）Detail Route</p><ul><li>主要修复TA阶段产生的physical drc violation。<ul><li>route通过遍历一个个特定大小的区域(SBox)去修复drc。</li></ul></li></ul></li><li><p>（4）Search &amp; Repair </p><ul><li>主要用于修剩下的drc Violation。算法是不断的增加SBox的Size，去遍历修。</li><li>即使Route的DRC Violation都清掉了，之后还是需要做Signoff的DRC。原因有下面三点：<ul><li>Routing DRC是complete technology DRC的子集。</li><li>我们需要统一Routing DRC和complete technology DRC的版本，可能存在两个版本不一致的情况。</li><li>ICC中placement和routing使用的都是一个FRAM view，而不是CEL view；可能有些细节并没有被检查到，所以之后还需要CEL View进行signoff DRC检查。<ul><li>没必要去读入CEL view的原因是：这两步没必要去读入太多细节信息，消耗run time。</li></ul></li></ul></li></ul></li></ul></li><li><p>上面介绍Pre-Route的四步，可以使用下面命令实现。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">route_opt -initial_route_only</span><br></code></pre></td></tr></table></figure><ul><li>这一阶段不需要考虑timing相关，需要考虑是否存在congestion。</li><li>在该指令运行之前还需要指令进行下面的一些设置。</li></ul></li><li><p>route_opt -initial..前的设置</p><ul><li>（1）Antenna rule的设置<ul><li>Antenna rule.tcl来源于stdcel厂商；因为天线效应和stdcell的设计相关。</li><li>使用下面指令在ICC阶段就设置，在Signoff的physical verification阶段也需要去检查一下天线效应。<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">set_route_zrt_detail_options -antenna <span class="hljs-literal">true</span><br>source antenn<span class="hljs-built_in">a_rules</span>.tcl<br></code></pre></td></tr></table></figure></li></ul></li><li>（2）Zrt Router 设置<ul><li>大部分使用Synopsys RM Flow的设置。<ul><li>其中RM(Reference Methodology)是说Synopsys创建的一个包含整个ICC流程的参考脚本。</li></ul></li><li>需要将之前设置好的一些物理约束source进来，例如：layer的设置等。</li></ul></li><li>（3）Routing Blockage<ul><li>使用gui界面指定哪个金属层的什么区域不让绕线，可以导出脚本，之后修改脚本坐标即可。</li></ul></li><li>（4）Routing Guide<ul><li><p>可以指定特定金属层不route和preroute；设置特定金属层走preferred direction，或者switch preferred direction；设置route track utilization；以及其它一些更为详细的走线约束。</p><ul><li>preroute为route之前先布好pg rail&#x2F;strap&#x2F;ring的线。</li><li>每层金属的方向是可以指定的，都是vertical,horizon间隔。preferred direction是指该层金属的方向。而Switch则是改变部分区域的金属走线方向，与设前面指定的不一致。<ul><li><p>举例如下图，macro之间的channel只能横向走线，只能走M4，但是M4是纵向的，所以可以使用switch，更改这部分区域M4的走线方向。</p>  <img src="3201119-20230825233148646-823833872.png" width = 40%/></li></ul></li></ul></li><li><p>针对出现的congestion，制定合理的routing guide指定部分区域走线方向，以及区域走线利用率，来将绕线阻塞的地方分配一些绕线资源到较为“空闲”的地方。</p></li></ul></li></ul></li><li><p>route_opt -initial..后的操作</p><ul><li>查看 DRC violation&#x2F;antenna violation等。</li><li>修出现的physical violation    <ul><li>可以首先检查short区域，short很大可能是因为congestion导致的，该区域可能会出现很多其它非short的drc violation。  </li><li>可以使用Global Route Congestion工具快速看修完之后congestion的结果。</li></ul></li></ul></li></ul><h3 id="3-2-PostRoute-Opt"><a href="#3-2-PostRoute-Opt" class="headerlink" title="3.2 PostRoute Opt"></a>3.2 PostRoute Opt</h3><ul><li>进入此步的前提是DRC violation，congestion等问题都大致解决了，才可以进行后面的操作。</li><li>该步骤使用的scenario的数目和PostCTS的数目是差不多的。margin可以根据实际情况进行调整或保持不变，主要看这步和前一步的correlation。  </li><li>该步骤主要使用route_opt指令，用于修复timing&#x2F;drc&#x2F;area&#x2F;power&#x2F;xtalk.</li><li>出现violation时，可以添加下面两个命令，进行增量优化。当数目较小时，可以手修。<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">route_opt -incremental</span><br><span class="hljs-attribute">psynopt</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>ICC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ICC-Placement</title>
    <link href="/2023/11/08/ICC-Placement/"/>
    <url>/2023/11/08/ICC-Placement/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Placement-准备"><a href="#1-Placement-准备" class="headerlink" title="1. Placement 准备"></a>1. Placement 准备</h2><ul><li>Placement 目标<ul><li>满足sdc约束。</li><li>满足物理约束（例如blockage&#x2F;move bound）。</li><li>考虑使用尽量少的绕线资源，优化避免congestion。</li><li>面积和功耗尽量小。</li></ul></li><li>文件准备<ul><li>准备好milkway库。<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">open_mw_lib</span></span> ../mw/...<br></code></pre></td></tr></table></figure></li><li>打开Floorplan design的mw_cel。<ul><li>在Milkway library下做的设计，都以milkway cel的形式存在。可以使用下面指令查看存在设计对应的mw_cel。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">list_mw_cels<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li>将Floorplan做的StdCell、Blockage、Bounds 的Placement remove掉，在Placement阶段使用工具进行重新放置。</li></ul><h2 id="2-时序约束（SDC）"><a href="#2-时序约束（SDC）" class="headerlink" title="2. 时序约束（SDC）"></a>2. 时序约束（SDC）</h2><ul><li>相关时序约束需要按照MCMM添加，可以看<a href="https://www.cnblogs.com/qianbinbin/p/17638107.html">这篇博客</a>。</li><li>在DC&#x2F;DCT阶段，一些High fanout net被设置为dont touch，在Placement阶段，dont touch属性需要remove掉。例如复位信号等，时钟信号仍先不动。</li></ul><h2 id="3-物理约束"><a href="#3-物理约束" class="headerlink" title="3. 物理约束"></a>3. 物理约束</h2><ul><li><p>（1）fix 住Floorplan做的所有的macro cell，防止在Placement时Macro被移动。</p></li><li><p>（2） placement blockage </p><ul><li>主要有以下三种<ul><li>Hard blockage：严格规定不可以在指定区域添加stdcell。</li><li>Soft blockage：在Coarse Placement不会摆stdcell，但是在Detail Placement时，基于Coarse Placement进行微调，可能会进入Soft blockage。</li><li>Partial blockage：可以指定cell类别添加&#x2F;不添加，以及添加百分比。</li></ul></li><li>可以使用下面指令为指定宽度的channel添加blockages。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">derive_placement_blockages -<span class="hljs-keyword">apply</span> -thin_channel_width <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>（3）create_bounds</p><ul><li>选择指定的cell都放在一个固定的区域。</li></ul></li><li><p>（4）keepout margin</p><ul><li>为macro设置一个keepout范围不放置stdcell。也可以指定hard&#x2F;soft。和在macro附近设置blockage是做一件事。 </li><li>在Floorplan阶段就需要去做，因为Floorplan阶段需要设置keepout，来确定endcap摆放在keepout外。</li></ul><img src="3201119-20230822101313413-1295167431.png" width = 50%/></li><li><p>（5）set_pnet_options</p><ul><li>主要是考虑到电源线下需要打通孔到底层金属，如果在pnet下放置stdcell，那么可能会出现congestion的问题。所以可以使用指令设置在pnet下stdcell的摆放。</li><li>可选选项：在特定金属层下 -partial、-complete、-none：部分摆，完全不摆，随意摆。<ul><li><p>其中部分摆：可以留出pin用于连接的space，就可以摆。</p><img src="3201119-20230822105422033-386758641.png" width = 25%/></li></ul></li></ul></li><li><p>（6）set_ignored_layers</p><ul><li>设置route使用的layer范围。</li></ul></li><li><p>（7）Non_Default Clock Routing</p><ul><li>考虑到时钟的特殊性，其需要NDR来约束，常见的：double-spacing，double-width以及shielding。这些会影响congestion的评估，所以应该在placement阶段就设置好。</li></ul></li><li><p>（8）Define libcell spacing</p><ul><li>使用下面指令指定限制多个cell之间的spacing。<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">set_spcacing_label_rule</span> <br></code></pre></td></tr></table></figure></li></ul></li><li><p>（9）一些Placement&#x2F;Optimization Attributes的设置如下表所示，对应place_opt的三个步骤。</p></li></ul><img src="3201119-20230822210035407-2091729725.png" width = 50%/><h2 id="4-Timing-Driven-placement-optimization"><a href="#4-Timing-Driven-placement-optimization" class="headerlink" title="4. Timing Driven placement &amp; optimization"></a>4. Timing Driven placement &amp; optimization</h2><ul><li><p>默认Placement是基于timing drivern的。</p></li><li><p>优化方法</p><ul><li>Placement会将关键路径上的模块放的靠近一些，连线就减短了，自然RC就小了。</li><li>使用Size cell来获得更小的延时，但是代价是面积和功耗。 </li><li>Simple logic mapping：对逻辑进行优化，remap。</li><li>Layer optimization：对于关键路径，采用高层金属布线，因为高层金属的厚度更大，电阻更小。</li></ul></li><li><p>优化思想</p><ul><li>无论是DC&#x2F;ICC，timing的优化都是基于path group进行优化的。默认的group是按照不同clk进行分组。</li><li>可以设置path group优先级。</li><li>DC会优先优化每个path group中最差的timing path（critical path）。<ul><li>可以通过指令 set_critical_range 设置优化critical path的范围；DC和ICC都可以使用这个指令。具体内容可以看<a href="https://www.cnblogs.com/qianbinbin/p/17507344.html">这篇内容</a>。<ul><li><p>也可以使用group_path进行分组时，添加-critical range选项设置range value。</p><img src="3201119-20230822230621586-1533856688.png" width = 50%/></li></ul></li></ul></li></ul></li><li><p>可以使用ICC的timing path highlight工具进行分析，更直观的在版图上看到timing path的走向，再进一步添加约束。</p></li><li><p>对于小的timing violation，可以使用psynopt进行增量优化。</p></li></ul><h2 id="5-Congestion-Driven-placement-optimization"><a href="#5-Congestion-Driven-placement-optimization" class="headerlink" title="5. Congestion Driven placement &amp; optimization"></a>5. Congestion Driven placement &amp; optimization</h2><ul><li><p>Congestion 导致的问题</p><ul><li>由于出现congestion，那么detail route和virtual route可能相差很大，导致virtual route估计的RC不准。Placement可能时序满足了，但是Route之后并不满足。 </li><li>detail route绕不通，可能会出现很多short。</li></ul></li><li><p>工具计算Congestion的方法</p><ul><li>计算穿过的routing和available的routing数量，如果前者大于后者，那么出现congestion。</li></ul><img src="3201119-20230823094226903-687717728.png" width = 50%/></li><li><p>congestion driven 优化</p><ul><li>解决congestion driven可以将那些非critical path的cell往稍远些摆放，但可能会导致RC变大，时序变差。</li><li>初步place_opt先不加-congestion选项，检查是否出现严重的congestion，如果没出现，不需要加该选项，因为可能导致时序和面积都变差。</li><li>为了获得placement之后和post_route更好的correlation。可以使用下面指令。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> placer_enable_enhanced_router TRUE<br></code></pre></td></tr></table></figure></li></ul></li><li><p>解决congestion的策略</p><ul><li>rerun placement with congestion option.</li><li>scan_reorder 可以缓解congestion。可以看下面第7节内容。</li><li>refine_placement<ul><li>适合在place_opt之后，添加指令refine_placement对阻塞进行优化.</li><li>一些选项可选，如 -congestion_effort 和 -perturbation_level（对其他部分设计的影响程度，可选min&#x2F;medium&#x2F;high&#x2F;max）。</li></ul></li><li>更改物理约束<ul><li>调整cell density&#x2F;pin density<ul><li>可以在place之前，将pin脚很多的cell使用dont_use指令屏蔽掉。</li><li>在一些特殊区域（如：macro的拐角，macro之间的channel等）使用partial blockage进行设置<ul><li>使用placement blockage -partial 选项，设置摆放的stdcell百分比是多少。或者使用下面指令，一样的效果。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_congestion_options -max_util <span class="hljs-number">0.4</span> -coordinate &#123;x1 y1 x2 y2&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>检查congestion是否和pg strap有关，检查是否设置了pnet options，或者strap太宽。</li></ul></li><li>添加&#x2F;更改 blockages</li></ul></li><li>更改Floorplan <ul><li>macro形状&#x2F;大小不合理，导致输入&#x2F;输出pin都挤到一起，引起阻塞。</li><li>移动macro位置。</li><li>移动pin&#x2F;pad的位置。</li></ul></li></ul></li></ul><h2 id="6-Area-Power-optimization"><a href="#6-Area-Power-optimization" class="headerlink" title="6. Area &amp; Power optimization"></a>6. Area &amp; Power optimization</h2><ul><li>面积优化<ul><li>设置指令指定slack大于某一界限值时，可以进行面积优化操作，如size down。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">physopt_area_critical_range = <span class="hljs-string">&quot;0.1&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li>功耗优化<ul><li>Leakage Power Optimization<ul><li>替换不同VT的cell，在功耗和时序之间balance。</li><li>也是可以使用下面的指令设置slack大于某一界限值时，进行功耗优化。 <pre><code class="hljs">set physopt_power_critical_range</code></pre></li></ul></li><li>Dynamic Power Optimization<ul><li>Low Power Placement：减小高翻转率信号的线长，目的减小C。翻转率可以通过读入SAIF文件得到。更多关于功耗优化的可以看<a href="https://www.cnblogs.com/IClearner/p/6898463.html">这篇文章</a>。</li><li>使用place_opt 添加-power选项。</li></ul></li></ul></li></ul><h2 id="7-Scan-chain-reorder"><a href="#7-Scan-chain-reorder" class="headerlink" title="7. Scan chain reorder"></a>7. Scan chain reorder</h2><ul><li>将寄存器首尾相连，做测试链。</li><li>出现的问题<ul><li>由于DFT在DC阶段插入scan chain是随意的，那么其导出的ddc和Scan_def.def给到ICC时，进行route，可能会导致连线乱飞，占大量的绕线资源，出现congestion的问题。 </li><li>解决方法：使用Placement工具提供的scan chain reorder工具，重新连接scan chain中reg的顺序。<ul><li><p>但是reorder存在一个作用范围，如下图所示，被分为了三部分，每个bucket内可以随意reorder。</p><img src="3201119-20230823132733499-1850647320.png" width = 70%/></li><li><p>在后端设计流程中，可以做scan reorder如下。</p><img src="3201119-20230823134507188-1632830487.png" width = 50%/></li></ul></li></ul></li></ul><h2 id="8-Place阶段一些常用opt指令"><a href="#8-Place阶段一些常用opt指令" class="headerlink" title="8. Place阶段一些常用opt指令"></a>8. Place阶段一些常用opt指令</h2><ul><li>place_opt<ul><li>选项<ul><li>-spg：DCT中会做一个粗略的Placement工作，并可以通过ddc传给ICC。</li></ul></li><li>place_opt 包括下面几步优化<ul><li>Coarse Placement<ul><li>考虑Power，Area，Congestion，将stdcell放一个大概的位置；不做逻辑优化。</li><li>Cells overlap and not on-site.已经确定好大致位置，后面只需微调。</li><li>此步也需要指定好Routing相关的设置，如Routing Blockages，因为此步的Placement需要考虑Congestion进行优化。</li></ul></li><li>Detail Placement<ul><li>Legalized stdcell，将Stdcell放置在合适的位置。具体内容可以看<a href="https://zhuanlan.zhihu.com/p/508482624">这篇文章</a>。</li></ul></li><li>Placement optimization  <ul><li>和上一步不断迭代优化。</li><li>主要优化方向：Timing&#x2F;Area&#x2F;Power&#x2F;Congestion.</li><li>会做逻辑优化，例如size cell 或者合并部分cell等。</li><li>在这步还会做AHFS（Auto High Fanout Synthesis），主要解high fanout net的DRC。</li></ul></li></ul></li></ul></li><li>pysnopt  <ul><li>本文章前面也提到，在某些较小violation需要修时，可以使用增量优化，节省时间。</li></ul></li><li>refine_placement<ul><li>在本文章前面介绍解决congestion的策略中也有介绍该指令。主要用于在place_opt之后做的处理阻塞的增量优化。</li></ul></li></ul><h2 id="9-Tie-Cell-Spare-Cell-insertion"><a href="#9-Tie-Cell-Spare-Cell-insertion" class="headerlink" title="9.Tie-Cell &amp; Spare-Cell insertion"></a>9.Tie-Cell &amp; Spare-Cell insertion</h2><ul><li>Tie-Cell<ul><li>为什么需要Tie-Cell<ul><li>在一些Design中，有些input pin被直接连到0&#x2F;1上，但是如果直接将input pin连接到0&#x2F;1上，ESD可能会损坏这个pin的gate&#x2F;poly。</li><li>即使有ESD保护，但是为了更稳妥，还是需要将input pin连接到Tie cell，而不是PG Strap。</li></ul></li><li>Tie-Cell的种类<ul><li>Tie-HI Cell 和 Tie-LO Cell </li><li>可以使用指令让工具自动插入Tie Cell，也可以使用独立的插入命令。</li></ul></li></ul></li><li>Spare-Cell<ul><li>是一种冗余逻辑单元，主要用于以下情况。<ul><li>在制造PostMask之后，想要修改电路，添加逻辑，可以使用在Placement洒下的sparecell。这样不用动base layer的mask，只需要修改那一层metal layer的连接关系，实现逻辑修改；可以节省baselayer mask的成本（mask是较贵的程序）。</li></ul></li><li>如何添加<ul><li>设置一个spare_list，将常见逻辑的cell都添加一定数量进去。</li><li>根据设计的规模，添加多组spare_list。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>ICC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ICC-FloorPlan</title>
    <link href="/2023/11/08/ICC-FloorPlan/"/>
    <url>/2023/11/08/ICC-FloorPlan/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://www.cnblogs.com/duxinshupd/p/15925167.html">https://www.cnblogs.com/duxinshupd/p/15925167.html</a></li><li><a href="https://blog.csdn.net/qq_34110120/article/details/83007656">https://blog.csdn.net/qq_34110120/article/details/83007656</a></li></ul></li></ul><hr><ul><li>在Floorplan之前，需要首先阅读一下IP和Stdcel的文档，观察是否有特别的要求，因为Floorplan的很多工作是跟stdcel和macro的设计风格有关，跟tf也有关。</li></ul><h2 id="1-实现流程"><a href="#1-实现流程" class="headerlink" title="1. 实现流程"></a>1. 实现流程</h2><ul><li><p>（1）定义大小和形状</p><ul><li>可以在手册中查找create_floorplan指令的相关选项配置。<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">create_floorplan</span></span> -left_io2core <span class="hljs-number">10.</span>..<br></code></pre></td></tr></table></figure></li></ul></li><li><p>（2）Macro Cell 摆放</p><ul><li>注意事项 <ul><li>macro的摆放需要考虑timing、congestion以及IR Drop。 </li><li>注意signal pin的方向，以及PG pin的分布。</li><li>注意Macro之间的连接关系，Hierarchy分析以及DataFlow分析。</li><li>Macro的堆叠需要考虑congestion、timing、si的影响。</li><li>留一些空间给decap插入，用于减小Dynamic IR-Drop。</li><li>也要留一些空间处理走线较长的信号线，留有空间，可以插入buffer。</li></ul></li><li>对于一些大型的设计，可以使用指令首先让工具摆放，作为一个初始参考。指令如下，可以选择多个选项。<ul><li>其中 -no_hierarchy_gravity 为指定不按照module的hierarchy分块。 <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">create_fp_placement</span></span> -timing_driven -congestion_driven...<br></code></pre></td></tr></table></figure></li></ul></li><li>一般都是手动摆放macro，摆放好了之后可以导出脚本，方便下一次直接使用。</li><li>摆放完之后要固定住，防止后面操作更改。</li></ul></li><li><p>（3）Ports&#x2F;Terminals的摆放</p><ul><li>port是逻辑存在的端口，而terminal是port的物理层实现。</li></ul><img src="3201119-20230818170236147-393202007.png" width = 50%/><ul><li>注意port的金属层选择，不同金属层有不同的方向，选择合适的金属层让port接口“顺着放”。</li><li>也可以使用脚本让工具自动摆放，人为可以添加约束。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">place_fp_pins -block_level<br></code></pre></td></tr></table></figure></li></ul></li><li><p>（4）EndCap Cell(Boundary Cell) </p><ul><li>放在Row的边界，主要为了满足DRC，保护处于边界位置的stdcell；以及match stdcell environment。</li></ul></li><li><p>（5）Tap Cell</p><ul><li>N 阱和P 衬底形成了一个PN结，为了避免这个PN结被正向偏置(Forwad Bias)，形成Latch-Up效应，从而损坏整个芯片。最容易的办法是把N-Well连接到最高电压上，同时把P-Substrate连接到最低电压上。 </li><li>而tap cell的目的就是这个，但是tap cell的作用范围有限，所以需要间隔一定距离就放置一个，具体的数据可以看Foundry给的文档。</li><li>也可以在标准单元设计时，集成well tie，这种情况就不需要单独的tap cell了。</li><li>可以使用下面语句添加tap cell。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">add_tap_cell_array<br></code></pre></td></tr></table></figure></li></ul></li><li><p>（6）PG Network</p><ul><li>目的：给所有的Macro和StdCell供上电。</li><li>评估标准：IR Drop。</li><li>摆放注意点<ul><li>查看stdcell的metal layer及其方向。</li><li>查看macro的PG Pin的使用和方向。</li><li>注意Top给整个block的供电方案，连接关系（Via）。<ul><li>从Top给底层金属供电，通过一层一层的Via孔打下去，这个从Top到底层金属的过程也有电压降的问题，但是如果Via孔打的多，电阻变小（具体公式可上网查），电压降就会减小。</li></ul></li><li>注意Macro之间的channel的供电方案。</li></ul></li><li>实现流程<ul><li>（a）Logically Connect PG Pins with PG Nets</li><li>（b）设置Macro Rings</li><li>（c）设置PG Strap<ul><li>pitch within group：一组VDD和VSS之间的间距，建议两者不要间隔太近，因为两者都要向下打Via，可能会导致Route阻塞。</li><li>建议strap细但密，还是考虑到strap太宽，打多个via，导致走线不好走。</li></ul></li><li>（d）Preroute Macros<ul><li>对于Macro的pins需要preroute instances连接到电源网络上。</li></ul></li><li>（e）Preroute Rail<ul><li>使用指令preroute_standard_cells布置Rail 供电网络给Stdcell的供电。</li><li>在Floorplan阶段可以使用下面指令快速将stdcell摆进去，然后检查供电网络是否布置出错或遗漏。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">create fp placement -effort low<br></code></pre></td></tr></table></figure></li><li>在Placement阶段可以使用下面指令将Floorplan阶段placement的StdCell remove掉；重新布置。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">remove_placement<br></code></pre></td></tr></table></figure></li></ul></li><li>（f）Verify PG Connection<ul><li>使用下面指令检查是否存在未供上电的cell&#x2F;区域。<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">verify_pg_nets</span><br></code></pre></td></tr></table></figure></li></ul></li><li>注意：可以通过下面指令指定选择layer范围(M4到M1之间的金属层)进行Via连接。上面介绍的多个步骤中可能会使用到。<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">set</span>_preroute_drc_strategy -max_layer M4 -min_layer M1<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>（7）额外的物理约束</p><ul><li>stdcell的摆放区域设定：例如靠近Core的边缘没必要摆放（硬性要求），部分区域指定部分stdcell可以摆（软性，自己定义的要求）。 <ul><li>create_placement_blockage：不允许在指定区域摆放指定cell。 </li><li>create_bounds：在指定区域摆放指定cell。</li><li>create_route_guide &#x2F; create_routing_blockage<ul><li>在Floorplan就指定Route相关设置的原因是，可能会虚拟走线计算时序等信息，所以需要提前把Route相关设置好。</li></ul></li></ul></li></ul></li><li><p>（8）Write Floorplan</p><ul><li>目的是将Floorplan信息指定部分写出DEF等文件，可以给DCT使用，做连线延时估计。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>ICC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ICC-CTS</title>
    <link href="/2023/11/08/ICC-CTS/"/>
    <url>/2023/11/08/ICC-CTS/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://www.cnblogs.com/IClearner/p/6606360.html">https://www.cnblogs.com/IClearner/p/6606360.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/36433282">https://zhuanlan.zhihu.com/p/36433282</a></li><li><a href="https://zhuanlan.zhihu.com/p/37918846">https://zhuanlan.zhihu.com/p/37918846</a></li><li><a href="https://blog.csdn.net/weixin_46752319/article/details/107387584">https://blog.csdn.net/weixin_46752319/article/details/107387584</a></li><li><a href="https://blog.csdn.net/weixin_43249158/article/details/124837883">https://blog.csdn.net/weixin_43249158/article/details/124837883</a></li><li>ICC userguide 2016.03</li></ul></li></ul><hr><ul><li>在做CTS之前，更重要的是要做好FloorPlan和Placement；或者说在前面应该思考时钟树如何综合。</li><li>时钟树上插入的clock buffer和普通buffer有何区别？<ul><li>clkbuf 的上升延迟时间和下降延迟时间较平衡，需要保证时钟上升和下降尽量对称，以此保证得到较为准确的占空比。</li></ul></li></ul><hr><h2 id="1-CTS的目标"><a href="#1-CTS的目标" class="headerlink" title="1. CTS的目标"></a>1. CTS的目标</h2><ul><li>clock skew 尽量小。</li><li>clock latency 尽量小。</li><li>common path 尽量长。（目的是改善ocv效应）</li></ul><h2 id="2-CTS在做什么"><a href="#2-CTS在做什么" class="headerlink" title="2. CTS在做什么"></a>2. CTS在做什么</h2><ul><li>读取clock的定义，以及在何种scenario下进行时钟树综合。<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read<span class="hljs-emphasis">_sdc</span><br><span class="hljs-emphasis">create_</span>scenario<br></code></pre></td></tr></table></figure></li><li>工具首先会对clock line上的cell&#x2F;net进行DRV优化。<ul><li>DRV：Design Rule Violation，包括max_transition, max_capacitance, max_fanout, max_net_length等。<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">compile_clock_tree</span><br></code></pre></td></tr></table></figure></li></ul></li><li>对每个clock的latency和skew进行优化。尽量缩短每个clock的latency，并减小sink之间的skew。<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">optimize_clock_tree</span><br></code></pre></td></tr></table></figure></li><li>balance已经定义的clock group，会尽量将不同clock的latency做的尽量接近。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">balance_inter_clock_delay<br></code></pre></td></tr></table></figure></li><li>Route Clock。<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">route_zrt_clock_tree</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-可控的CTS"><a href="#3-可控的CTS" class="headerlink" title="3. 可控的CTS"></a>3. 可控的CTS</h2><ul><li>CTS更多可控可看<a href="https://zhuanlan.zhihu.com/p/37918846">这篇文章</a>以及ICC的Tool commands文档。下面仅列出部分内容。</li><li>Target Skew：告诉工具，我们希望CTS之后能够得到的最大skew值。<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">set_clock_tree_options -target_skew <span class="hljs-number">100</span> -clock CLK<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>Target Insertion delay：指定工具最小的插入延迟(insertion delay).不指定默认为0.<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">set_clock_tree_options -target_early_delay <span class="hljs-number">100</span> -clock CLK<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>Max Transition：一般选择时钟周期的10%-20%。<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">set_max_transition <span class="hljs-number">200</span> -clock_path [get_clocks CLK]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>CTS exceptions：<ul><li><p>下面介绍的四个pins的设置都是该指令的配置选项。 </p> <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">set</span>_clock_tree_exceptions -stop_pins/exclude_pins.<span class="hljs-string">..</span> &#123; list of pins &#125;<br></code></pre></td></tr></table></figure></li><li><p>Stop pins（Sink pins） </p><ul><li>让CTS在某处停止，时钟信号不再继续传播；告诉工具将某些pin&#x2F;port标记为sink。</li><li>工具只对stop_pins的delay进行balance，如果其它pin也需要进行优化，需要对pin进行sdc约束，告诉工具。</li></ul></li><li><p>Exclude pins（Ignore pins）</p><ul><li>工具通过插入guide buffer来从时钟树中隔离这些引脚。</li><li>CTS不会对到达这些端点的时钟树进行时序计算和优化；只会进行设计规则修正。</li><li>常见的exclude pin就是所有的非时钟引脚，以及定义不正确的时钟引脚等，CTS阶段不需要管这些端口。</li><li>ICC会自己推断要排除的引脚，也可以自己使用脚本再额外设置。</li></ul></li><li><p>Nonstop pins</p><ul><li>工具会穿过Nonstop pins，继续查找真正的sink点。</li><li>驱动生成时钟的时序单元的时钟引脚一般是Nonstop pins。例如分频器等。</li><li>ICC认为时钟门控单元的时钟输入引脚是Nonstop pins，因此不需要手动重复设置。</li></ul></li><li><p>Float pins</p><ul><li>与Stop pins相类似，但是在<strong>构建时钟树时会考虑该引脚内部的时钟延迟</strong>。<ul><li>工具在计算到Float pins的Insertion delay时，会将Float pin内部的延迟（正&#x2F;负）添加到Insertion delay中。</li></ul></li><li>常见使用在Hard Macro的时钟输入引脚。<ul><li><p>考虑到Hard Macro的内部延迟信息会在lib文件的时序模型中表示，ICC会根据模型确定macro内部的延时。</p></li><li><p>根据外部计算的insertion delay判断这个是positive&#x2F;negative pin。相当于在原有insertion_delay ± macro_delay.</p><p><img src="/2023/11/08/ICC-CTS/3201119-20230716100843717-1161969140.png"></p></li></ul></li></ul></li><li><p>除了上面介绍的4个pin的约束，exception的约束还包括dont_touch&#x2F;buffer&#x2F;size系列。这里简要介绍一下dont_touch。</p><ul><li>当设计中存在已经设计好的时钟树，可以使用指令set_clock_tree_exceptions -dont_touch_subtrees $name设置为dont touch属性，CTS会将其它待综合的时钟树和pre-exiting的时钟树进行balance。</li></ul></li></ul></li></ul><h2 id="4-CTS步骤"><a href="#4-CTS步骤" class="headerlink" title="4. CTS步骤"></a>4. CTS步骤</h2><ul><li>CTS整体流程如下图所示，这里只介绍部分知识用作学习。</li></ul><p><img src="/2023/11/08/ICC-CTS/3201119-20230716165154145-1129330924.png"></p><h3 id="4-1-分析clock结构，制定CTS策略"><a href="#4-1-分析clock结构，制定CTS策略" class="headerlink" title="4.1 分析clock结构，制定CTS策略"></a>4.1 分析clock结构，制定CTS策略</h3><ul><li>策略主要需要尽可能的满足上面三个目标，如何让工具按照指定的策略进行时钟数综合呢？<ul><li>可以通过preplace clk的MUX选择器或分频逻辑模块（我理解为generate clock模块）在想要布时钟线的路径上。</li></ul></li><li>因此指定CTS策略这步需要确定preplace的逻辑以及放置的区域。</li></ul><h3 id="4-2-CTS开始前的检查和设置"><a href="#4-2-CTS开始前的检查和设置" class="headerlink" title="4.2 CTS开始前的检查和设置"></a>4.2 CTS开始前的检查和设置</h3><ul><li><p>（1）report_clock、report_clock_tree查看时钟和时钟树信息；以及report_constraints:查看设计是否有violation.</p><ul><li>此时可以有hold violation。</li></ul></li><li><p>（2）设置目标skew和insertion delay。设置DRC规则：max_fanout , max_transition , max_capacitance；下面有关于clock root相关DRC设置要求。</p></li><li><p>（3）设置时钟树的references</p><ul><li>指定clock buffer&#x2F;inverter list</li><li>其中inverter对工艺要求较高，必须采用LVT或SVT，而且只允许有一种VT。更多内容可以看<a href="https://blog.csdn.net/weixin_43249158/article/details/124837883">这篇文章</a>。</li></ul></li><li><p>（4）时钟树布线规则的定义(NDR)</p><ul><li><p>为了减少其它信号串扰和EM（电子迁移）的影响，一般会采用双倍线宽和双倍间距；并一般采用高层金属作为时钟信号的走线。  </p></li><li><p>标准单元的pin脚一般为M1&#x2F;M2金属层，如果设置为NDR，会导致很多DRC问题，所以在sink端还是使用默认线宽和间距布线。 </p><p><img src="/2023/11/08/ICC-CTS/3201119-20230716174615995-192191548.png"></p></li></ul></li><li><p>（5）设置时钟树延迟计算模式：精确程度：arnoldi &gt; awe &gt; elmore。</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">set_delay_calculation_options -routed_clock arnoldi</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-3-Clock-root-定义"><a href="#4-3-Clock-root-定义" class="headerlink" title="4.3 Clock root 定义"></a>4.3 Clock root 定义</h3><ul><li>clock root如果是input port，那么分为是否有I&#x2F;O Pad。<ul><li>如果没有I&#x2F;O Pad，那么需要准确的指定输入端口的驱动单元。<ul><li>对于一个弱的驱动来说，CTS需要插入额外的buffer来保证DRC通过。</li><li>如果不设置，那么工具会假设输入端口的驱动能力无穷大，内部不需要做额外的buffer处理。</li></ul></li><li>如果有I&#x2F;O Pad，那么需要准确的指定input_transition的大小</li></ul></li><li>定义时钟root点<ul><li>使用create_clock定义时钟的root点。<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">create_clock</span> -period <span class="hljs-number">10</span> -name clk1<span class="hljs-meta"> [get_ports FCLK1]</span><br></code></pre></td></tr></table></figure></li><li>如果是generate clock，可以使用create_generate_clock定义。<ul><li><p>要求master clock要定义清楚，并且generate clock和master clock要可以trace通。</p><p><img src="/2023/11/08/ICC-CTS/3201119-20230716143446863-32084362.png"></p></li><li><p>根据上图可以写出tcl：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">create_generated_clock  -name <span class="hljs-built_in">CLKPDIV2</span>  -source UPLL0/<span class="hljs-built_in">CLKOUT</span>   -add    -master_clock <span class="hljs-built_in">CLKP</span>  -divide_by <span class="hljs-number">2</span> [get_pins UFF0/Q]<br></code></pre></td></tr></table></figure></li><li><p>generate clock和master clock之间的相位关系必须指定清楚，最简单的方式是直接指定相位边沿关系。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">create_generated_clock</span> -name CLKdiv2  -edges &#123;<span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span>&#125; -source CLK<span class="hljs-meta"> [get_pins Udiv/Q]</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="4-4-找时序路径的端点"><a href="#4-4-找时序路径的端点" class="headerlink" title="4.4 找时序路径的端点"></a>4.4 找时序路径的端点</h3><ul><li>clock sinks可以是stop pins，exclude pins以及float pins。根据第3节的介绍来判断CTS如何计算&#x2F;优化。</li><li>第3节介绍的时钟端点是在同一时钟下各个路径之间的balance，我们也需要关心多个create_clock定义的时钟root端。<ul><li><p>虽不是同一时钟，但有reg进行talk。默认情况，CTS会分别build各自的clock tree，不会做inter-clock balance。如下所示。</p><img src="3201119-20230716145656725-1255455270.png" width = 60%/></li><li><p>上图由于两个时钟skew的值相差太大，导致很严重的建立时间违例。可以通过tcl设置进行inter-clock 的balance。</p>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">set_inter_clock_delay_options -<span class="hljs-keyword">balance_group </span><span class="hljs-string">&quot;Clk1 Clk2&quot;</span> -<span class="hljs-keyword">balance_group_name </span>group2 <span class="hljs-keyword">balance_inter_clock_delay </span>-<span class="hljs-keyword">clock_trees </span>&#123; <span class="hljs-keyword">clock_1 </span><span class="hljs-keyword">clock_2 </span>&#125;<br></code></pre></td></tr></table></figure>  <img src="3201119-20230716150640982-1767152118.png" width = 60%/></li></ul></li></ul><h3 id="4-5-Build-Clock-Tree"><a href="#4-5-Build-Clock-Tree" class="headerlink" title="4.5 Build Clock Tree"></a>4.5 Build Clock Tree</h3><ul><li>主要有两种方法<ul><li>clock_opt</li><li>compile_clock_tree + optimize_clock_tree</li></ul></li><li>相关指令选项可以看Tool Commands手册。</li><li>完成之后可以report_timing&#x2F;report_clock_tree&#x2F;report_constraint</li></ul><h3 id="4-6-Post-CTS"><a href="#4-6-Post-CTS" class="headerlink" title="4.6 Post-CTS"></a>4.6 Post-CTS</h3><ul><li>前面完成的是Pre-CTS，下面将完成Post-CTS。</li><li>ideal clock &amp; propagated clock<ul><li>在Pre-CTS阶段之前，我们使用的是ideal clock，从clock source到寄存器的时钟端口的network latency的值为我们使用set_clock_latency约束的。</li><li>在Pre-CTS之后，工具可以自动update IO latency 去反应实际时钟到达时间，并在原有的时钟树上插入计算的IO latency。具体内容可以在2016版ICC User Guide 5-104页找到。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">update_clock_latency<br><span class="hljs-comment"># 或在clock_opt加上 -update_clock_latency 选项</span><br></code></pre></td></tr></table></figure></li><li>在Post-CTS阶段之后，我们使用的是propagated clock，此时使用的network latency是实际的时钟互连线网络的RC 提取参数计算出的延时。</li></ul></li><li>Post-CTS 时钟属性处理<ul><li>移除所有时钟的理想属性<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">remove_ideal_network [ all_fanout -flat -clock_tree ]<br>remove_clock_latency <span class="hljs-variable">$clk</span><br><span class="hljs-comment"># 设置时钟为propagate属性</span><br>set_propagate_clock [ get_attr <span class="hljs-variable">$clock</span> <span class="hljs-built_in">source</span> ]<br></code></pre></td></tr></table></figure></li><li>重新定义clock uncertainty<ul><li>Pre-CTS<ul><li>setup： uncertainty &#x3D; PLL jitter + 预估的clock skew。</li><li>hold：uncertainty &#x3D; 预估的clock skew + hold margin。</li><li>hold是同一个时钟边沿检测，可以去掉clk jitter的影响。setup是两个clk边沿计算，需要加上jitter的影响。</li></ul></li><li>Post-CTS<ul><li>在Post-CTS阶段，时钟树的propagate delay已经确定，skew是真实存在的，不用再计算在uncertainty中。</li><li>setup：uncertainty &#x3D; PLL jitter。</li><li>hold：0 + hold_margin。</li></ul></li><li>hold margin：考虑到OCV的影响，不同的Flipflop之间的hold time可能是不同的，需要加hold margin来保证。Foundry提供的Signoff表格会给出要求的hold margin。</li></ul></li><li>在做完上面的处理之后，使用指令update_clock_latency再更新一下latency信息。</li></ul></li><li>修hold violation<ul><li>首先搬出一篇<a href="https://zhuanlan.zhihu.com/p/114752119">文章</a>，讲的很清楚为什么在Post-CTS阶段才去管hold violation。<ul><li>总结来说，hold和skew的关系最为密切，只有在Post-CTS阶段，skew值是真实计算的值，这个时候去修hold才是有意义的。</li><li>并不是说hold优先级没有setup高，反而hold才是最危险的，投片后如果出现hold violation无法通过降频去改善。</li></ul></li><li>可以通过指令 set_fix_hold去修hold violation。<ul><li>此时没有真实的布线，但是可以通过虚拟布线提取参数进行hold&#x2F;setup的计算，此步就可以去修setup&#x2F;hold的violation。</li><li>Route是在解DRC的过程，而在Post Route时，需要考虑SI，setup&#x2F;hold等问题。</li></ul></li></ul></li><li>面积优化<ul><li>psynopt -area_recovery</li><li>set_max_area 0</li><li>set physopt_area_critical_range 0.2, 该指令是指在timing slack大于某个值的path上用时序换面积。</li></ul></li><li>extract_rc 提取寄生参数</li><li>时钟绕线<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">route_zrt_group</span> -all_clock_nets -reuse_existing_global_route <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>ICC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ICC-MCMM</title>
    <link href="/2023/11/08/ICC-MCMM/"/>
    <url>/2023/11/08/ICC-MCMM/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/mikiah/article/details/7970235">https://blog.csdn.net/mikiah/article/details/7970235</a></li></ul></li></ul><hr><h2 id="1-关于-MCMM"><a href="#1-关于-MCMM" class="headerlink" title="1. 关于 MCMM"></a>1. 关于 MCMM</h2><ul><li><p>ICC可以读入多Corner、多Mode组合的scenarios，并行优化。</p></li><li><p>可以由PVT Corner、RC Corner以及工作模式组合成多种scenario的组合。</p><ul><li>PVT Corner：需要覆盖：WC&#x2F;WCL&#x2F;BC&#x2F;ML。</li><li>RC Corner：需要覆盖：Cworst&#x2F;Cbest&#x2F;RCworst&#x2F;RCbest。 </li><li>PVT和RC Corner相关内容可以看<a href="https://www.cnblogs.com/qianbinbin/p/17603907.html">这篇博客</a>。</li></ul></li><li><p>ICC流程 MCMM的设置。</p><ul><li>表中setup和hold的corner可以去signoff中表格查找。如果使用innovus，可以将所有的Corner都添加进去，让工具去选择合适的Corner进行分析。</li><li>注意，MCMM的分析是一个不断迭代的过程，最后得到的输出文件需要满足所有Corner。 <table><thead><tr><th>流程</th><th>MultiCorner</th></tr></thead><tbody><tr><td>FloorPlan</td><td>Setup</td></tr><tr><td>Placement</td><td>Setup</td></tr><tr><td>pre-CTS</td><td>Hold</td></tr><tr><td>post-CTS</td><td>Hold</td></tr><tr><td>Route</td><td>Hold</td></tr></tbody></table></li><li>在CTS之前，只需要对func mode进行优化即可，scan mode在CTS及CTS之后进行优化。<ul><li>因为scan_mode的setup是很容易满足的，所以只需要在hold需要覆盖的corner打开即可。</li></ul></li></ul></li><li><p>数字设计流程中的 timing correlation</p><ul><li>相邻两个阶段，需要预留的margin差异越小，这两个阶段的correlation越好。<ul><li>例如：如果逻辑综合使用的是DCT工具，那么DCT估算的连线延迟较placement之间的延迟差别不大。</li></ul></li></ul><table><thead><tr><th>flow</th><th>timing correlation</th></tr></thead><tbody><tr><td>DC -&gt; FloorPlan&#x2F;Placement</td><td>net延迟估计从WLM模型到virtual route（即使使用DCT，精度还是有差别）</td></tr><tr><td>Placement -&gt; CTS</td><td>Clock skew的差别以及需要加OCV的估计</td></tr><tr><td>CTS -&gt; Route</td><td>Detail Route以及SI-delta delay</td></tr><tr><td>Route -&gt; Signoff</td><td>StarRC提取RC，还需考虑Foundry给的Signoff表格</td></tr></tbody></table></li></ul><h2 id="2-MCMM-脚本设置"><a href="#2-MCMM-脚本设置" class="headerlink" title="2. MCMM 脚本设置"></a>2. MCMM 脚本设置</h2><ul><li>scenario 声明<ul><li>学习中首先考虑三个scenario，并指定了两种模式（func和scan）的时序约束sdc文件，以及包含PVT Corner的.db文件和包含RC Corner的TLUPLUS文件。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> SCENARIO_1                <span class="hljs-string">&quot;func_wc_cworst&quot;</span><br><span class="hljs-built_in">set</span> ICC_IN_SDC_1_FILE         <span class="hljs-string">&quot;../input_data/oc8051_func.postCTS.sdc&quot;</span><br><span class="hljs-built_in">set</span> OPCOND_1                  <span class="hljs-string">&quot;WORST&quot;</span><br><span class="hljs-built_in">set</span> OPCOND_1_LIB              <span class="hljs-string">&quot;saed90nm_max_hth&quot;</span><br><span class="hljs-built_in">set</span> TLUPLUS_1_FILE            <span class="hljs-string">&quot;<span class="hljs-variable">$TLUPLUS_CWORST</span>&quot;</span> <br><br><span class="hljs-built_in">set</span> SCENARIO_2                <span class="hljs-string">&quot;func_ml_cbest&quot;</span><br><span class="hljs-built_in">set</span> ICC_IN_SDC_2_FILE         <span class="hljs-string">&quot;../input_data/oc8051_func.postCTS.sdc&quot;</span><br><span class="hljs-built_in">set</span> OPCOND_2                  <span class="hljs-string">&quot;BEST&quot;</span><br><span class="hljs-built_in">set</span> OPCOND_2_LIB              <span class="hljs-string">&quot;saed90nm_min_ht_lvt&quot;</span><br><span class="hljs-built_in">set</span> TLUPLUS_2_FILE            <span class="hljs-string">&quot;<span class="hljs-variable">$TLUPLUS_CBEST</span>&quot;</span> <br><br><span class="hljs-built_in">set</span> SCENARIO_3                <span class="hljs-string">&quot;scan_ml_cworst&quot;</span><br><span class="hljs-built_in">set</span> ICC_IN_SDC_3_FILE         <span class="hljs-string">&quot;../input_data/oc8051_scan.postCTS.sdc&quot;</span><br><span class="hljs-built_in">set</span> OPCOND_3                  <span class="hljs-string">&quot;BEST&quot;</span><br><span class="hljs-built_in">set</span> OPCOND_3_LIB              <span class="hljs-string">&quot;saed90nm_min_ht_lvt&quot;</span><br><span class="hljs-built_in">set</span> TLUPLUS_3_FILE            <span class="hljs-string">&quot;<span class="hljs-variable">$TLUPLUS_CWORST</span>&quot;</span> <br></code></pre></td></tr></table></figure></li></ul></li><li>设置OCV timing derate<ul><li>OCV相关内容可以看<a href="https://www.cnblogs.com/qianbinbin/p/17604494.html">这篇博客</a>。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment">#timing derate</span><br><span class="hljs-comment">## for setup</span><br><span class="hljs-keyword">proc</span><span class="hljs-title"> set_derate_worst_case</span> &#123;&#125; &#123;<br>set_timing_derate -<span class="hljs-keyword">clock</span> -early <span class="hljs-number">0.92</span> -cell_delay<br>set_timing_derate -<span class="hljs-keyword">clock</span> -early <span class="hljs-number">0.92</span> -net_delay<br>set_timing_derate -<span class="hljs-keyword">clock</span> -late  <span class="hljs-number">1.00</span> -cell_delay<br>set_timing_derate -<span class="hljs-keyword">clock</span> -late  <span class="hljs-number">1.00</span> -net_delay<br><br>&#125;<br><span class="hljs-comment">## for hold</span><br><span class="hljs-keyword">proc</span><span class="hljs-title"> set_derate_best_case</span> &#123;&#125; &#123;<br>set_timing_derate -<span class="hljs-keyword">clock</span> -early <span class="hljs-number">1.00</span> -cell_delay<br>set_timing_derate -<span class="hljs-keyword">clock</span> -early <span class="hljs-number">1.00</span> -net_delay<br>set_timing_derate -<span class="hljs-keyword">clock</span> -late  <span class="hljs-number">1.12</span> -cell_delay<br>set_timing_derate -<span class="hljs-keyword">clock</span> -late  <span class="hljs-number">1.12</span> -net_delay<br>&#125;<br><br><span class="hljs-keyword">proc</span><span class="hljs-title"> set_derate_typical_case</span> &#123;&#125; &#123;<br>set_timing_derate -<span class="hljs-keyword">clock</span> -early <span class="hljs-number">0.95</span> -cell_delay<br>set_timing_derate -<span class="hljs-keyword">clock</span> -early <span class="hljs-number">0.95</span> -net_delay<br>set_timing_derate -<span class="hljs-keyword">clock</span> -late  <span class="hljs-number">1.05</span> -cell_delay<br>set_timing_derate -<span class="hljs-keyword">clock</span> -late  <span class="hljs-number">1.05</span> -net_delay<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>每个scenario分析脚本<ul><li><p>set_case_analysis </p><ul><li>设置工作mode，Func&#x2F;Scan。每个mode下，时序都需要满足要求。设置mode之后，工具只能看见当前mode下的timing path，所以也只能优化当前mode的path。</li></ul></li><li><p>set_operating_conditions</p><ul><li><p>时序分析工具一般有3中分析模式，这里的-analysis_type可选bc-wc&#x2F;ocv分析模型。bc-wc模型较为悲观，一般选择ocv模型。</p></li><li><p>可以通过-max_library、-max以及-min_library、-min指定 库和operating conditions。其中operating conditions在前面的max&#x2F;min库中有指定。</p><img src="3201119-20230817150556420-1541946885.png" width = 80%/></li></ul></li><li><p>set_tlu_plus_files</p><ul><li>可选 -max_tluplus 和 -min_tluplus，对应max condition和min condition相关的tluplus文件。因为考虑到一个scenario只有一个RC Corner，所以只需要指定一个就可以。</li><li>如果有tluplus emulation相关的文件，可以添加选项：-max&#x2F;min_emulation_tluplus.</li><li>tech2itf_map：itf和tf之间的映射关系，itf中包含了RC寄生参数信息，而tf则提供了technology-specific信息，例如：每层金属的名称、物理和电学特性。另外，ICC要求TF必须包含Design Rules。两者需要一个map表格将两个文件中相同的物理信息映射起来。</li></ul><p><img src="/2023/11/08/ICC-MCMM/3201119-20230818095155761-1983421665.png"></p><ul><li>必须要指定的是：maximum tluplus文件和mapping file。如果还指定了minimum tluplus文件，还会进行min condition的RC提取.</li></ul></li><li><p>set_scenario_options</p><ul><li>可以指定多个选项进行优化，如setup&#x2F;hold&#x2F;leakage_power&#x2F;dynamic_power。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">if</span> &#123;<span class="hljs-variable">$SCENARIO_1</span> != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; <span class="hljs-variable">$ICC_IN_SDC_1_FILE</span> != <span class="hljs-string">&quot;&quot;</span>&#125; &#123;<br>create_scenario <span class="hljs-variable">$SCENARIO_1</span><br><br><span class="hljs-keyword">set</span> auto_link_disable true<br><span class="hljs-keyword">source</span> <span class="hljs-variable">$ICC_IN_SDC_1_FILE</span><br><span class="hljs-keyword">set</span> auto_link_disable false<br><br>set_operating_conditions \<br>      -analysis_type on_chip_variation -max_library <span class="hljs-variable">$OPCOND_1_LIB</span> -max <span class="hljs-variable">$OPCOND_1</span><br><br>set_tlu_plus_files -max_tluplus <span class="hljs-variable">$TLUPLUS_1_FILE</span> -tech2itf_map <span class="hljs-variable">$TLUPLUS_MAP</span><br><br>set_clock_uncertainty -setup <span class="hljs-number">0.30</span> [all_clocks]<br>set_clock_uncertainty -hold  <span class="hljs-number">0.12</span> [all_clocks]<br>set_max_transition <span class="hljs-number">0.6</span> [current_design]<br>set_max_fanout <span class="hljs-number">64</span> [current_design]<br><br>set_scenario_options -setup true -hold true -leakage_power true -dynamic_power true<br>set_derate_worst_case<br><span class="hljs-comment">  # post cts 需要移除所有时钟的理想特性</span><br>remove_input_delay clk<br>set_propagated_clock [all_clocks]<br>remove_ideal_network -all<br><span class="hljs-comment">  # 修hold violation</span><br>        set_fix_hold [all_clocks]<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>ICC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ICC-数据准备</title>
    <link href="/2023/11/08/ICC-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87/"/>
    <url>/2023/11/08/ICC-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/weixin_46752319/article/details/107252336">https://blog.csdn.net/weixin_46752319/article/details/107252336</a></li><li><a href="https://blog.csdn.net/qq_38453556/article/details/116528487">https://blog.csdn.net/qq_38453556/article/details/116528487</a></li><li><a href="https://zhuanlan.zhihu.com/p/400608425">https://zhuanlan.zhihu.com/p/400608425</a></li></ul></li></ul><hr><h2 id="1-需要准备好的文件"><a href="#1-需要准备好的文件" class="headerlink" title="1. 需要准备好的文件"></a>1. 需要准备好的文件</h2><ul><li>逻辑层：需要.db、.sdc、.v文件<ul><li>.db：通常与DC使用的库是相同的，提供std_cell、IO、Macro时序、功耗和面积等信息，包含器件延迟，工艺角等信息。<ul><li>需要设置相应的库为target_library和link_library。</li></ul></li><li>.sdc：由DC导出，可人工修改，使其满足设计要求。</li><li>.v：由DC导出，门级网表文件。<ul><li>除了可以读入.v文件还可以读入.ddc文件，.ddc中不仅包含了netlist、sdc，还可以包含一些物理信息：placement blockage，-spg信息等。<ul><li>-spg相关信息可以看<a href="https://www.cnblogs.com/qianbinbin/p/17639773.html">这篇博客</a>.</li></ul></li></ul></li></ul></li><li>物理层：需要.mw、.tf、TLU文件<ul><li>Milkway：记录工艺和标准单元、macro、pad cell物理相关信息，以及这些单元在布局时需要的最小间隔和对绕线的要求等。<ul><li>指定.tf文件以及mw_reference_library（包括使用的stdcell&#x2F;IP等physical library）可通过下面指令。<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">create_mw_lib</span> -tech <span class="hljs-variable">$TECH_FILE</span> -mw_reference_library <span class="hljs-variable">$MW_REFERENCE_LIB_DIRS</span><br></code></pre></td></tr></table></figure></li><li>Milkway有多种view模式，可以看<a href="https://www.shangyexinzhi.com/article/4236824.html">这篇文章</a>。比较常用的是：CEL&#x2F;FRAM，前者更为具体，而后者更抽象。<ul><li><p>对于Stdcel：IP厂商一般会同时提供CEL View+FRAM View，以及GDS+LEF。</p></li><li><p>Macro（包括Memory，PLL，IO等）：一般IP厂商只提供GDS+LEF，我们需要使用synopsys的Milkway工具将其转化为对应的CEL和FRAM文件，以便ICC使用。</p><table><thead><tr><th></th><th>细节</th><th>抽象</th></tr></thead><tbody><tr><td>Encounter</td><td>GDS</td><td>LEF</td></tr><tr><td>IC Compiler</td><td>CEL View</td><td>FRAM View</td></tr></tbody></table></li></ul></li></ul></li><li>physical library ：典型的ICC流程中，物理库的信息是被包含在Milkyway数据库中。</li><li>.tf：工艺文件，提供了technology-specific信息以及tile的宽高，例如：每层金属的名称、物理和电学特性。另外，ICC要求TF必须包含<strong>Design Rules</strong>：包括width，pitch，spacing等值的定义。</li><li>TLU+<ul><li>RC寄生模型文件，用于计算互连线RC，有多个corner的建模。</li><li>由工艺厂商提供，但如果工艺厂商仅提供了itf文件，可以通过工具StarRC使用grdgenxo将itf文件转换成tluplus文件。指令如下。<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">grdgenxo -itf2TLUPlus -i <span class="hljs-attribute">&lt;ITF FILE&gt;</span> -o <span class="hljs-attribute">&lt;TLU+ file&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在Signoff时，可以使用STARRC抽取的nxtgrd文件（该文件比tluplus有更详细的信息），导入pt中。</li></ul></li></ul></li></ul></li><li>IP库：.sldb文件<ul><li>synthetic_library：DesignWare的可重用IP库，将运算符号转换成特定的库。</li></ul></li></ul><h2 id="2-指定库文件"><a href="#2-指定库文件" class="headerlink" title="2. 指定库文件"></a>2. 指定库文件</h2><ul><li>set link_library：为网表中的每个子设计在ICC内存中找到相应的设计。</li><li>set target_library：与DC一致，使用link library进行翻译，优化后映射到目标库中。</li><li>set_min_library：同时指定bestcase用作保持时间分析以及指定worstcase用作建立时间分析。（用MCMM分析更好）<ul><li>MCMM（Multi Corner - Multi Mode）：让ICC吃掉所有scenario的时序约束，让软件自行评估和优化；例如一条违例的路径可能出现在不同的scenario中，有不同的时序裕量，有的-1，有的-0.2，那么ICC会在裕量最差的那个scenario中进行修复。在后面ICC Placement处还会详细介绍。 <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">set</span>_min_library <span class="hljs-string">&quot;./wc_ccs.db&quot;</span> -min_<span class="hljs-keyword">version</span> <span class="hljs-string">&quot;./bc_ccs.db&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-检查物理库和逻辑库的一致性（check-library）"><a href="#3-检查物理库和逻辑库的一致性（check-library）" class="headerlink" title="3. 检查物理库和逻辑库的一致性（check_library）"></a>3. 检查物理库和逻辑库的一致性（check_library）</h2><ul><li>默认检查命令：check_library</li><li>完整检查命令：set_check_library_options -all (还会检查UPF power的约束，MMMC，CCS电流源模型等)</li></ul><h2 id="4-设置0互联延时"><a href="#4-设置0互联延时" class="headerlink" title="4. 设置0互联延时"></a>4. 设置0互联延时</h2><ul><li>首先在最理想的情况下看是否存在setup的违规，如果违规则应返回前端修改设计。<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">set</span>_zero_interconnect_delay_mode <span class="hljs-literal">true</span><br>report_timing -delay_type max<br><span class="hljs-keyword">set</span>_zero_interconnect_delay_mode <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>ICC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Verilator</title>
    <link href="/2023/11/03/Verilator/"/>
    <url>/2023/11/03/Verilator/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/430738271">https://zhuanlan.zhihu.com/p/430738271</a></li><li><a href="https://zhuanlan.zhihu.com/p/587049371">https://zhuanlan.zhihu.com/p/587049371</a></li><li><a href="https://zhuanlan.zhihu.com/p/587124830">https://zhuanlan.zhihu.com/p/587124830</a></li><li><a href="https://itsembedded.com/dhd/verilator_2/">https://itsembedded.com/dhd/verilator_2/</a></li><li><a href="https://blog.kuangjux.top/2022/02/20/verilator-learning/">https://blog.kuangjux.top/2022/02/20/verilator-learning/</a></li></ul></li></ul><hr><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul><li><p>流程</p><ul><li><p>运用 Verilator package，将 Verilog 和 System Verilog 编译转换为C++ &#x2F; System C模型。</p><ul><li>输出的模型会以.cpp&#x2F;.h文件存在。</li></ul></li><li><p>为了完成仿真，我们需要设计一个C++ Wrapper，这个Wrapper与传统的Verilog Testbench相类似，主要是为了连接顶层模块，并给予激励。</p></li><li><p>在C++编译器的工作下，前面生成的文件（包括转换后的C++&#x2F;System C 以及 C++ Wrapper）以及库文件（Verilator提供的runtime library等）会被一同合并编译成一个可执行文件。</p></li><li><p>执行这个生成的可执行文件，就可以开始仿真。</p></li></ul></li></ul><h2 id="2-应用举例"><a href="#2-应用举例" class="headerlink" title="2. 应用举例"></a>2. 应用举例</h2><h3 id="2-1-基本应用"><a href="#2-1-基本应用" class="headerlink" title="2.1 基本应用"></a>2.1 基本应用</h3><ul><li><p>待测试模块代码如下</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top(<br>  <span class="hljs-keyword">input</span> a,<br>  <span class="hljs-keyword">input</span> b,<br>  <span class="hljs-keyword">output</span> f<br>);<br>  <span class="hljs-keyword">assign</span> f = a ^ b;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></li><li><p>（1）首先我们使用下面指令将代码编译成C++代码；运行之后得到了一个obj_dir文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">verilator --cc top.v<br></code></pre></td></tr></table></figure><ul><li><p>可以看到obj_dir文件夹中包含下图这些文件，其中 .mk 文件为用于make构建仿真的可执行程序，.h和.cpp文件包含了我们top.v源码实现的信息。</p><img src="image-20231103134425943.png" alt="image-20231103134425943" style="zoom: 80%;" /></li></ul></li><li><p>（2）编写测试模块代码如下</p><ul><li><p>简单测试模块代码应包括以下内容。</p><ul><li><p>SystemC 的仿真kernel会一直跟踪当前时间，可以通过调用 sc_time_stamp() 方法去访问。</p></li><li><p>使用下面代码例化一个对象用于新建仿真。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Valu *dut = <span class="hljs-keyword">new</span> Valu;<br><span class="hljs-comment">// 其相当于verilog中 top dut(端口例化...)</span><br></code></pre></td></tr></table></figure></li><li><p>使用下面代码设置产生vcd波形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Verilated::<span class="hljs-built_in">traceEverOn</span>(<span class="hljs-literal">true</span>);<br>VerilatedVcdC *m_trace = <span class="hljs-keyword">new</span> VerilatedVcdC;<br>dut-&gt;<span class="hljs-built_in">trace</span>(m_trace, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 其中5这个参数表示跟踪深度限制在dut的5级以内。（5级是子模块层级）</span><br>m_trace-&gt;<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;waveform.vcd&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>下面代码中在while()循环中进行仿真。</p><ul><li>其中 MAX_SIM_TIME 为 clk 翻转次数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (sim_time &lt; MAX_SIM_TIME) &#123;<br>  dut-&gt;clk ^= <span class="hljs-number">1</span>;    <span class="hljs-comment">//翻转clk</span><br>  dut-&gt;<span class="hljs-built_in">eval</span>();      <span class="hljs-comment">//更新电路状态</span><br>  m_trace-&gt;<span class="hljs-built_in">dump</span>(sim_time);   <span class="hljs-comment">//将所有信号写入波形文件</span><br>  sim_time++;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后，使用下面代码结束仿真。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">m_trace-&gt;<span class="hljs-built_in">close</span>();<br><span class="hljs-keyword">delete</span> dut;<br><span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Verilator 是一个 two state simulator，因此它只支持逻辑值0和1，且对所有的信号初始化均为0.</p><ul><li><p>但是我们可以通过命令改变此行为，可以让 Verilator 支持所有的信号为1或随机值。</p><ul><li>这样不仅可以检查复位信号是否有效，还可以满足一些特殊电路情况的设计。</li></ul></li><li><p>需要在实例化 dut 对象之前调用<code>Verilated::commandArgs(argc, argv);</code>。</p><ul><li><p>另外，还需要添加编译选项 <code>--x-assign unique</code> 和 <code>--x-initial unique</code>。</p></li><li><p>最后，还需要在执行时，更改为下面命令，将<code>+verilator+rand+reset+2</code> 传递给仿真的可执行文件，来让仿真运行时信号可初始化为随机值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./obj_dir/V$(MODULE) +verilator+rand+reset+2<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>（3）编译生成可执行文件</p><ul><li><p>使用工具：GNU Compiler Collection（GCC）。</p></li><li><p>再次运行 Verilator ，包含 前面编写的测试模块代码和被测试模块代码，重新生成 .mk 文件</p><ul><li>其中 <code>-Wall</code> 选项为打开所有C++警告，也可以更换成<code>-Wno-fatal</code>，表示忽略所有非 fatal 的 warning。</li><li><code>--trace</code> 表明会追踪波形，如果需要导出vcd 或者 fst 等其他波形文件，需要加上这个选项。</li><li><code>--exe</code> 生成可执行文件。</li><li><code>--cc</code> 表明支持C++程序，不过也支持 C 程序。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">verilator -Wall --trace --cc top.v --exe main.c<br></code></pre></td></tr></table></figure></li><li><p>使用下面命令进行编译，生成可执行文件。</p><ul><li>其中<code>-C</code> 是在读取makefile之前，先改变路径到指定文件夹下。</li><li><code>-f</code> 是读取 名为Vtop.mk 的Makefile文件。</li><li>最后编译生成名为 Vtop 的可执行程序。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -C obj_dir/ -f Vtop.mk Vtop<br></code></pre></td></tr></table></figure></li></ul></li><li><p>（4）运行仿真</p><ul><li>直接调用 <code>obj_dir/</code> 下生成的可执行文件。</li><li>运行之后会生成 <code>*.vcd</code> 的波形文件；可以使用 gtkwave 等工具进行查看。</li></ul></li></ul><h3 id="2-2-拓展应用"><a href="#2-2-拓展应用" class="headerlink" title="2.2 拓展应用"></a>2.2 拓展应用</h3><h4 id="2-2-1-编写-Makefile"><a href="#2-2-1-编写-Makefile" class="headerlink" title="2.2.1 编写 Makefile"></a>2.2.1 编写 Makefile</h4><ul><li><p>将 2.1 节介绍的步骤编写成 Makefile 脚本如下。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs makefile">MODULE=top<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:sim</span><br><span class="hljs-section">sim: waveform.vcd</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:verilate</span><br><span class="hljs-section">verilate: .stamp.verilate</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:build</span><br><span class="hljs-section">build: obj_dir/Valu</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:waves</span><br><span class="hljs-section">waves: waveform.vcd</span><br>@echo<br>@echo <span class="hljs-string">&quot;### WAVES ###&quot;</span><br>gtkwave waveform.vcd<br><br><span class="hljs-section">waveform.vcd: ./obj_dir/V<span class="hljs-variable">$(MODULE)</span></span><br>@echo<br>@echo <span class="hljs-string">&quot;### SIMULATING ###&quot;</span><br>@./obj_dir/V<span class="hljs-variable">$(MODULE)</span><br><span class="hljs-comment"># 如果需要将信号初始化为随机数，那么需要更改为下面指令。 </span><br><span class="hljs-comment"># @./obj_dir/V$(MODULE) +verilator+rand+reset+2</span><br><br><span class="hljs-section">./obj_dir/V$(MODULE): .stamp.verilate</span><br>@echo<br>@echo <span class="hljs-string">&quot;### BUILDING SIM ###&quot;</span><br>make -C obj_dir -f V<span class="hljs-variable">$(MODULE)</span>.mk V<span class="hljs-variable">$(MODULE)</span><br><br><span class="hljs-section">.stamp.verilate: <span class="hljs-variable">$(MODULE)</span>.sv tb_<span class="hljs-variable">$(MODULE)</span>.cpp</span><br>@echo<br>@echo <span class="hljs-string">&quot;### VERILATING ###&quot;</span><br>verilator -Wall --trace -cc <span class="hljs-variable">$(MODULE)</span>.sv --exe tb_<span class="hljs-variable">$(MODULE)</span>.cpp<br><span class="hljs-comment"># 如果需要将信号初始化为随机数，那么需要更改为下面指令。</span><br><span class="hljs-comment"># verilator -Wall --trace --x-assign unique --x-initial unique -cc $(MODULE).sv --exe tb_$(MODULE).cpp</span><br>@touch .stamp.verilate<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:lint</span><br><span class="hljs-section">lint: <span class="hljs-variable">$(MODULE)</span>.sv</span><br>verilator --lint-only <span class="hljs-variable">$(MODULE)</span>.sv<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>rm -rf .stamp.*;<br>rm -rf ./obj_dir<br>rm -rf waveform.vcd<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-2-2-测试设置"><a href="#2-2-2-测试设置" class="headerlink" title="2.2.2 测试设置"></a>2.2.2 测试设置</h4><ul><li><p>复位信号设置</p><ul><li><p>可以通过修改测试模块中 <code>while()</code> 中的内容，添加复位信号相关设置，举例如下。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (sim_time &lt; MAX_SIM_TIME) &#123;<br>    dut-&gt;rst = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(sim_time &gt;=<span class="hljs-number">3</span> &amp;&amp; sim_time &lt; <span class="hljs-number">6</span>)&#123;<br>        dut-&gt;rst = <span class="hljs-number">1</span>;<br>        dut-&gt;a_in = <span class="hljs-number">0</span>;<br>        dut-&gt;b_in = <span class="hljs-number">0</span>;<br>        dut-&gt;op_in = <span class="hljs-number">0</span>;<br>        dut-&gt;in_valid = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    dut-&gt;clk ^= <span class="hljs-number">1</span>;<br>    dut-&gt;<span class="hljs-built_in">eval</span>();<br>    m_trace-&gt;<span class="hljs-built_in">dump</span>(sim_time);<br>    sim_time++;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>时钟上升沿计数</p><ul><li><p>在 <code>eval()</code> 和 <code>dump()</code> 之间添加判断语句，当 <code>clk=1</code> 发生时，就为计数器加1。</p><ul><li>实现代码如下，其中 <code>posedge_cnt</code> 为上升沿计数变量，其数据类型与 <code>sim_time</code> 一致。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (sim_time &lt; MAX_SIM_TIME) &#123;<br>  dut-&gt;clk ^= <span class="hljs-number">1</span>;    <span class="hljs-comment">//翻转clk</span><br>  dut-&gt;eval();      <span class="hljs-comment">//更新电路状态</span><br>    <span class="hljs-keyword">if</span>(dut-&gt;clk == <span class="hljs-number">1</span>)&#123;<br>      posedge_cnt++;        <span class="hljs-comment">// Increment posedge counter if clk is 1</span><br>  &#125;<br>  m_trace-&gt;dump(sim_time);   <span class="hljs-comment">//将所有信号写入波形文件</span><br>  sim_time++;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>信号值随机化</p><ul><li><p>2.1节（2）中有介绍通过设置、添加编译选项可以实现信号初始化值为随机数。除此之外，我们也可以为某个变量赋值为随机数。</p><ul><li><p>首先，需要 <code>include</code> C++ 的 header：<code>cstdlib</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>另外，需要使用 <code>srand()</code> 函数为随机数生成器提供种子；它可以放在 <code>main()</code> 函数开头。 </p></li><li><p>随机数生成相关语法很容易可以在网上查到，这里就不详细介绍。</p></li></ul></li></ul></li><li><p>除了上面介绍的，也可以通过添加一些C++代码，实现对某个信号单周期或多周期的监控等。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DC - DCT - DCG</title>
    <link href="/2023/11/02/DC%20&amp;%20DCT%20&amp;%20DCG/"/>
    <url>/2023/11/02/DC%20&amp;%20DCT%20&amp;%20DCG/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://www.cnblogs.com/lantingyu/p/12091751.html">https://www.cnblogs.com/lantingyu/p/12091751.html</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>DC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DC相关理解（四）</title>
    <link href="/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li>《专用集成电路设计实用教程》</li></ul></li></ul><hr><h2 id="1-多时钟同步设计-时序约束"><a href="#1-多时钟同步设计-时序约束" class="headerlink" title="1. 多时钟同步设计 时序约束"></a>1. 多时钟同步设计 时序约束</h2><ul><li><p>以下图为例，所有的时钟都来自同一个时钟源，所以是它们是同步设计。</p><ul><li>可以看到要综合的模块输入只有CLKC，其他的时钟只作用于综合模块端口，我们需要对端口加以约束。</li><li>首先约束作为综合模块的主时钟CLKC，约束语句如下。<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">create_clock</span> -p <span class="hljs-number">20</span><span class="hljs-meta"> [get_ports CLKC]</span><br></code></pre></td></tr></table></figure><img src="3201119-20230801110619220-52097225.png" style="zoom:50%"/></li></ul></li><li><p>虚拟时钟</p><ul><li><p>考虑到CLKA\CLKD\CLKE在要综合的设计中没有对应的输入端口，因此需要设置虚拟时钟。</p></li><li><p><strong>虚拟时钟在设计里并不驱动触发任何寄存器，主要用于说明相对主时钟I&#x2F;O端口的延迟。</strong></p></li><li><p>输入端</p><ul><li><p>由于虚拟时钟没有对应的输入端口，所以定义中没有源端口和引脚；另外还需要定义input_delay，约束如下。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">create_clock</span> -period <span class="hljs-number">30</span> -name CLKA<br><span class="hljs-attribute">set_input_delay</span> <span class="hljs-number">5</span>.<span class="hljs-number">5</span> -clock CLKA -max<span class="hljs-meta"> [get_ports IN1]</span><br></code></pre></td></tr></table></figure><img src="3201119-20230801112656557-102317151.png" style="zoom:50%"/><ul><li>时序图如下，所以可以计算需要满足$ t_N &lt; 20-5.5-t_{setup}$ 以及 $t_N &lt; 10-5.5-t_{setup}$。</li></ul><img src="3201119-20230801112837065-1640123071.png" style="zoom:50%"/></li></ul></li><li><p>输出端</p><ul><li>考虑到输出端有两个虚拟时钟，所以要加两个约束。</li><li>注：<strong>第二个命令中需要加上 -add_delay 选项。</strong>如果不加，第二条命令会覆盖第一条命令。<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">create_clock</span> -period<span class="hljs-meta"> [expr 1.0/75*1000] -name CLKD #要用1.0而不是1</span><br><span class="hljs-meta">create_clock -period 10 -name CLKE</span><br><span class="hljs-meta">create_clock -period 20 [get_ports CLKC]</span><br><br><span class="hljs-attribute">set_output_delay</span> -max <span class="hljs-number">2</span>.<span class="hljs-number">5</span> -clock CLKD<span class="hljs-meta"> [get_ports OUT1]</span><br><span class="hljs-attribute">set_output_delay</span> -max <span class="hljs-number">4</span>.<span class="hljs-number">5</span> -clock CLKE -add_delay<span class="hljs-meta"> [get_ports OUT1]</span><br></code></pre></td></tr></table></figure></li></ul><img src="3201119-20230801141919417-2022692869.png" style="zoom:50%"/><ul><li>时序图如下，所以可以计算需要满足$ t_S &lt; 10-4.5$ 以及 $t_S &lt; 6.7-2.5$。</li></ul><img src="3201119-20230801143047026-1906983568.png" style="zoom:50%"/></li></ul></li></ul><h2 id="2-异步设计的时序约束"><a href="#2-异步设计的时序约束" class="headerlink" title="2. 异步设计的时序约束"></a>2. 异步设计的时序约束</h2><ul><li>需要考虑异步带来的亚稳态问题，可以考虑在设计中使用一些同步电路处理。</li><li>对于穿越异步边界的任何路径，我们都必须<strong>禁止对这些路径做时序综合</strong>，因为相位关系并不是确定的，对这些路径去做时间约束没有意义。</li><li>set_false_path<ul><li><p>我们可以使用 set_false_path 为跨时钟域路径作解除时序约束。指令如下。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_false_path -from [get_clocks CLKA] -to [get_clocks CLKB] <br>set_false_path -from [get_clocks CLKB] -to [get_clocks CLKA]<br></code></pre></td></tr></table></figure><img src="3201119-20230801143833520-640437126.png" style="zoom:50%"/></li><li><p>除了上面介绍的功能，还可以用来约束逻辑上不存在的路径，举例如下。</p><ul><li>设计中难免会出现一些物理上连接的通路，但信号永远不会从这条路径走。可以使用指令report_timing_requirments命令报告出设计中所有的例外。</li></ul><img src="3201119-20230801151731627-226754709.png" style="zoom:50%"/></li></ul></li></ul><h2 id="3-多时钟周期的时序约束"><a href="#3-多时钟周期的时序约束" class="headerlink" title="3. 多时钟周期的时序约束"></a>3. 多时钟周期的时序约束</h2><ul><li><p>以下图电路为例，时钟周期定义为10ns，加法器延迟为6个时钟周期，那么我们需要对其进行多时钟周期的时序约束。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_multicycle_path</span> <span class="hljs-number">6</span> -setup -to<span class="hljs-meta"> [get_pins C_reg[*]/D]</span><br></code></pre></td></tr></table></figure>  <img src="3201119-20230801152328132-1946481598.png" style="zoom:50%"/><ul><li><p>建立时间分析</p><ul><li>时序图如下，DC只在第6个上升沿做建立时间的分析，此时加法器允许的最大延迟为$ T_{delay} &lt; 60-T_{setup}-T_{uncertainty}-T_{clk2q} $.</li></ul><img src="3201119-20230801153907814-2146387820.png" style="zoom:50%"/></li><li><p>保持时间分析</p><ul><li>对于单周期的保持时间分析，时序图绘制如下，图中可以看到，对于FF2来说，想要采到正确的A值，那么组合逻辑延时需要满足 $ t_{delay-comb} &gt; t_{hold} + t_{skew}$.</li></ul><p><img src="/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/3201119-20230801171420555-989107851.png"></p><ul><li>同理，对于多周期的保持时间分析，时序图如下，需要保证加法器的延迟至少要 $ 50+t_{hold}+t_{uncertainty}$.</li></ul><img src="3201119-20230801163759883-324298802.png" style="zoom:50%"/></li><li><p>对于既要综合出一条路径延时满足建立时间60ns又要满足保持时间50ns，实际上是没有必要的，这样会增加电路的复杂度。</p><ul><li>在保持时间分析给出的时序图可以看到，在CLK_FF1第一个采样的上升沿就分析保持时间，限定组合逻辑延迟。因此对于多周期也是同样道理，可以在0ns时分析保持时间。约束语句如下。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_multicycle_path <span class="hljs-number">5</span> -hold -to [get_pins C_reg[*]/D]<br><span class="hljs-comment"># 简化后，指令为： </span><br>set_multicycle_path <span class="hljs-number">0</span> -hold -to [get_pins C_reg[*]/D]<br></code></pre></td></tr></table></figure></li></ul></li><li><p>根据前面的介绍和计算，我们可以设计相应的时钟使能电路，使得最后一级寄存器可以在期望的时钟进行采样接收正确的数据。</p></li></ul><img src="3201119-20230801173205351-520598643.png" style="zoom:50%"/></li></ul><h2 id="4-门控时钟的约束"><a href="#4-门控时钟的约束" class="headerlink" title="4. 门控时钟的约束"></a>4. 门控时钟的约束</h2><ul><li>关于门控时钟相关内容可以看<a href="https://www.cnblogs.com/qianbinbin/p/17579897.html">这篇博客</a>。</li><li>考虑到不带锁存器的门控时钟可能会出现毛刺的情况，所以下面的分析都是基于带锁存器的。</li><li>带锁存器的门控时钟的时序约束如下所示。需要A信号在时钟上升和下降沿分别满足setup和hold的时间约束。</li></ul><img src="3201119-20230801173859430-1378957056.png" style="zoom:50%"/><h2 id="5-分频电路和多路传输电路的时钟约束"><a href="#5-分频电路和多路传输电路的时钟约束" class="headerlink" title="5. 分频电路和多路传输电路的时钟约束"></a>5. 分频电路和多路传输电路的时钟约束</h2><ul><li>注意，在模块划分时，需要注意将时钟电路和核心功能电路划分成不同模块。<ul><li>不仅可以对时钟逻辑更好的控制和分析，而且简化了其他模块的输入时钟约束。</li></ul></li></ul><img src="3201119-20230801191058941-1199247852.png" style="zoom:50%"/><ul><li>多路传输<ul><li>上图中，CLOCK_GEN是通过多路时钟MUX选出的，如果我们不加约束去指定，那么DC会自己选择一个。</li><li>我们可以加约束如下，去掉引脚a到引脚y的时间弧，此时DC认为选择了Ext_Clk.<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">set_disable_timing CLOCK_GEN/U1 -<span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> -<span class="hljs-selector-tag">to</span> y<br></code></pre></td></tr></table></figure></li></ul></li><li>分频电路<ul><li><strong>DC并不能推导出分频时钟的波形，时钟信号可以通过任何的组合逻辑电路，但是终止于寄存器。</strong>因为DC并不知道寄存器的输出是时钟还是非时钟信号。</li><li>建议的定义分频时钟脚本：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">create_clock -period <span class="hljs-number">50</span> <span class="hljs-selector-attr">[get_ports Ext_Clk]</span><br>create_generated_clock -name Int_Clk \<br>  -source <span class="hljs-selector-attr">[get_pins CLOCK_GEN/U2/CP]</span> -divide_by <span class="hljs-number">2</span> \<br>  <span class="hljs-selector-attr">[get_pins CLOCK_GEN/U2/Q]</span><br>set_clock_latency -source <span class="hljs-number">1.5</span> <span class="hljs-selector-attr">[get_clocks Int_Clk]</span><br>set_clock_latency <span class="hljs-number">0.5</span> <span class="hljs-selector-attr">[get_clocks Int_Clk]</span><br></code></pre></td></tr></table></figure></li><li>注意：对于CTS综合之后，我们不需要使用set_clock_latency为时钟建模，使用下面脚本。<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">set_propagated_clock <span class="hljs-comment">[list <span class="hljs-comment">[all_clocks]</span> <span class="hljs-comment">[get_generated_clock *]</span>]</span><br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>DC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何修时序违例（一）</title>
    <link href="/2023/11/02/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%97%B6%E5%BA%8F%E8%BF%9D%E4%BE%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/11/02/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%97%B6%E5%BA%8F%E8%BF%9D%E4%BE%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/kobayashiyou/article/details/118900663">https://blog.csdn.net/kobayashiyou/article/details/118900663</a></li><li><a href="https://zhuanlan.zhihu.com/p/425524095">https://zhuanlan.zhihu.com/p/425524095</a></li><li>《专用集成电路设计实用教程》</li></ul></li></ul><hr><h2 id="1-修-Setup-Violation"><a href="#1-修-Setup-Violation" class="headerlink" title="1. 修 Setup Violation"></a>1. 修 Setup Violation</h2><ul><li>setup 应该满足下面公式。<br>$$<br>T_{launch}+T_{ck2q}+T_{dp}+T_{margin}+T_{setup}&#x3D;T_{capture}+T_{clk}<br>$$</li></ul><h3 id="1-1-Pipeline-Retiming"><a href="#1-1-Pipeline-Retiming" class="headerlink" title="1.1 Pipeline &amp; Retiming"></a>1.1 Pipeline &amp; Retiming</h3><ul><li>对于组合逻辑延迟过大的电路可以采用pipeline和retiming。</li><li>Pipeline<ul><li>插入寄存器，将长组合逻辑链分割，流水线处理。流水线相关内容见<a href="https://www.cnblogs.com/qianbinbin/p/17580195.html">这篇博客</a>。</li></ul></li><li>Retiming<ul><li>在综合过程中，发现设计的流水线划分不平衡，可以使用Retiming技术，<strong>在时序路径上移动寄存器，平衡分段组合逻辑延迟。</strong></li><li>DC 2019 UserGuide中在 Page16-2 有介绍两种retiming：Adaptive Retiming以及Pipelined-Logic Retiming。<ul><li>两者区别具体解释可以看手册。</li><li>前者会在DC_Ultra工具下局部调整寄存器位置，后者是只适用于Pipeline Datapath Blocks。 </li><li>两者指令<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment"># Adaptive:</span><br>compile_ultra - retime<br><span class="hljs-comment"># Pipeline：</span><br>set_optimize_registers<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="1-2-减小data-path的delay"><a href="#1-2-减小data-path的delay" class="headerlink" title="1.2 减小data path的delay"></a>1.2 减小data path的delay</h3><h4 id="1-2-1-更换不同VT-cell"><a href="#1-2-1-更换不同VT-cell" class="headerlink" title="1.2.1 更换不同VT cell"></a>1.2.1 更换不同VT cell</h4><ul><li>阈值电压越低，门延迟越短。阈值电压越高，门延迟越长。</li><li>但是功耗和上面关系相反的。</li></ul><h4 id="1-2-2-插入Buffer"><a href="#1-2-2-插入Buffer" class="headerlink" title="1.2.2 插入Buffer"></a>1.2.2 插入Buffer</h4><ul><li><a href="https://www.cnblogs.com/qianbinbin/p/17459189.html">这篇文章</a>有介绍器件延迟的计算是根据input transition，output load索引查找表得到的。</li><li>因此，优化驱动减小input transition或优化扇出减小output load也有助于减小器件延时，改善setup违例。<ul><li>举例：net太长导致驱动变弱，可以插入buf打断net，提高驱动；fanout太大，通过插入buf来减少fanout等。</li></ul></li></ul><h4 id="1-2-3-SizeUp-Cell"><a href="#1-2-3-SizeUp-Cell" class="headerlink" title="1.2.3 SizeUp Cell"></a>1.2.3 SizeUp Cell</h4><ul><li>对于一些cell的驱动能力太弱，导致output transition较大，产生较大的delay。此时可以更换大Size的cell提高驱动能力。</li><li>但是太大的cell，对于前级电路来说也是一个大的output load，可能导致前级电路难以驱动它；所以一味增加cell的size并不会确定减小delay。</li><li>对于cell，如果output transition比intput transition大的多，那么说明这个cell可以适当增大改善一下。</li><li>可以使用下面的指令debug 一个cell 或一段net 的delay <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">report_delay_calculation</span> <br></code></pre></td></tr></table></figure></li></ul><h4 id="1-2-4-Layer-Assignment"><a href="#1-2-4-Layer-Assignment" class="headerlink" title="1.2.4 Layer Assignment"></a>1.2.4 Layer Assignment</h4><ul><li>高层金属有电阻小，延迟低的特点。所以可以通过更换布线层次来实现setup的修复。</li></ul><h3 id="1-3-Useful-skew"><a href="#1-3-Useful-skew" class="headerlink" title="1.3 Useful skew"></a>1.3 Useful skew</h3><ul><li>向前或者向后 slack较为充裕的路径借时间来修正setup violation。</li><li>不建议使用，可能会导致时钟树不平衡等问题，而且会掩盖模块内部时序问题，应该去检查模块内部时序是否需要修。除非对于SRAM这种固定的Macro，难以修改内部的延时，可以使用Useful skew。</li></ul><h3 id="1-4-减小T-launch-增加T-capture"><a href="#1-4-减小T-launch-增加T-capture" class="headerlink" title="1.4 减小T_launch &amp; 增加T_capture"></a>1.4 减小T_launch &amp; 增加T_capture</h3><ul><li>一般不会使用该方法修改clock line，风险和限制较多。</li></ul><h3 id="1-5-group-path-设置权重优化"><a href="#1-5-group-path-设置权重优化" class="headerlink" title="1.5 group_path 设置权重优化"></a>1.5 group_path 设置权重优化</h3><ul><li>根据需要设置不同group的权重，也可以设置target slack，使工具更强的优化对应的Timing。</li><li>举例如下<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setPathGroupOptions</span> in2reg -effortLevel low -weight <span class="hljs-number">1</span> -slackAdjustment <span class="hljs-number">0</span> -targetSlack <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-修-Hold-Violation"><a href="#2-修-Hold-Violation" class="headerlink" title="2. 修 Hold Violation"></a>2. 修 Hold Violation</h2><ul><li>hold 应该满足下面公式。<br>$$<br>T_{launch}+T_{ck2q}+T_{dp}&#x3D;T_{margin}+T_{hold}+T_{capture}<br>$$</li></ul><h3 id="2-1-增加data-path的delay"><a href="#2-1-增加data-path的delay" class="headerlink" title="2.1 增加data path的delay"></a>2.1 增加data path的delay</h3><ul><li>插入Buffer，增加data path的延时。<ul><li>前面修setup时，也有插入buffer这个方法，那是为了增加驱动能力，减小延时。buffer数量增加到一定程度，所引入的延时大于强驱动减小的延时。</li></ul></li><li>插入delay cell。</li><li>注意：插入buffer&#x2F;delay cell的位置需要靠近path 的endpoint附近，因为防止寄存器输出可能会经过多条组合逻辑通路，影响其它通路的setup。</li><li>更换不同VT cell，替换LVT为RVT或HVT cell。</li></ul><h3 id="2-2-增加T-launch"><a href="#2-2-增加T-launch" class="headerlink" title="2.2 增加T_launch"></a>2.2 增加T_launch</h3><ul><li>理论上是可行的，但是动clock line不仅需要确认前后级path是否有足够的margin，有时候还会遇到影响范围不可控或者实现不方便等诸多限制。</li></ul><h3 id="2-3-减小T-capture"><a href="#2-3-减小T-capture" class="headerlink" title="2.3 减小T_capture"></a>2.3 减小T_capture</h3><ul><li>与2.2 有一样的限制，一般不会使用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>Violation 修复</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DC相关理解（三）</title>
    <link href="/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="http://www.cnblogs.com/IClearner">http://www.cnblogs.com/IClearner</a></li><li>《专用集成电路设计实用教程》</li></ul></li></ul><hr><ul><li>博客中很多内容都来自《专用集成电路设计实用教程》，有空可以细读一下，加上实践。</li></ul><hr><h2 id="1-DC-编译策略及工具版本"><a href="#1-DC-编译策略及工具版本" class="headerlink" title="1. DC 编译策略及工具版本"></a>1. DC 编译策略及工具版本</h2><ul><li>编译策略<ul><li>两种：top-down，bottom-up；</li><li>top-down<ul><li>顶层设计和子设计在一起编译;所有的环境和约束设置针对顶层设计;此种策略自动考虑到相关的内部设计。</li><li>但是此种策略不适合大型设计;因为设计必须同时驻内存;硬件资源耗费大。</li></ul></li><li>bottom-up<ul><li>子设计单独约束;当子设计成功编译后;被设置为 dont_touch 属性;防止在之后的编译过程中被修改;</li><li>所有同层子设计编译完成后；再编译之上的父设计;直至顶层设计编译完成。</li><li>Bottom-up 策略允许大规模设计;因为该策略不需要所有设计同时驻入内存。</li></ul></li></ul></li><li>DC工具版本<ul><li>根据支持的功能特性的多少，有如下排序：DC NXT &gt; DC Graphical &gt; DC Ultra &gt; DC Expert。</li></ul></li></ul><h2 id="2-DC-中的优化"><a href="#2-DC-中的优化" class="headerlink" title="2. DC 中的优化"></a>2. DC 中的优化</h2><ul><li>设计中常常会出现多次例化的情况，我们可以使用指令uniquify为设计中每一个复制的模块产生一个唯一名字的拷贝，这样DC就可以根据每个模块本身特有的环境做优化和映射。</li><li>电路的综合优化主要包括三个阶段，如下图所示。<ul><li><p>结构级优化</p></li><li><p>逻辑级优化</p></li><li><p>门级优化</p><img src="3201119-20230730220535056-1872843735.png" style="zoom:50%"/></li></ul></li></ul><h3 id="2-1-结构级优化"><a href="#2-1-结构级优化" class="headerlink" title="2.1 结构级优化"></a>2.1 结构级优化</h3><ul><li><p>设计结构选择</p><ul><li>在DesignWare中选择最合适的结构或算法实现电路的功能。</li></ul></li><li><p>数据通路的优化</p><ul><li>选择CSA等算法优化数据通路的设计。</li></ul></li><li><p>共享共同子表达式</p><ul><li>提取可以共同使用的子表达式，减小资源消耗。 <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 优化前</span><br>f0 = a + b + c<br>f1 = a + b + d<br><span class="hljs-comment">// 优化后</span><br>tmp = a + b<br>f0 = tmp + c<br>f1 = tmp + d<br></code></pre></td></tr></table></figure></li></ul></li><li><p>重新排序运算符号</p><ul><li>以获得更少的资源和更小的延迟。</li><li>由于编译器解析表达式存在一定优先级，如果重排序加括号确定优先级，就可以实现一定的并行度，减小延时。</li></ul></li><li><p>资源共享：</p><ul><li><strong>对于算数运算的资源共享，默认策略是约束驱动的。</strong></li><li>示例如下图所示：DC会将(a)中的电路转化为(b)中的电路。</li></ul><img src="3201119-20230730205242607-1226873541.png" style="zoom:50%"/><ul><li>我们可以使用指令让DC使用面积优化策略，共享资源。如下面指令修改变量：<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> hlo_resource_allocation <span class="hljs-comment">area</span><br></code></pre></td></tr></table></figure></li><li>如果不希望DC综合时进行资源共享优化，可以将上面的变量设置为none，但是如果想要类似优化，只能在RTL编码时处理了。</li></ul></li></ul><h3 id="2-2-逻辑级优化"><a href="#2-2-逻辑级优化" class="headerlink" title="2.2 逻辑级优化"></a>2.2 逻辑级优化</h3><ul><li><p>做完2.1的结构级优化后，电路的功能以GTECH的器件表示。</p></li><li><p>结构优化</p><ul><li>共用子表达式减少逻辑，是DC默认的逻辑级优化策略。</li><li>结构优化过程中，可能会在电路中加入中间变量和逻辑结构。<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 优化前</span><br>f0 = ab + ac<br>f1 = b + c + d<br>f2 = b&#x27;c&#x27;e<br><span class="hljs-comment">// 优化后</span><br>f0 = at0<br>f1 = t0 + d<br>f2 = t0&#x27;e<br>t0 = b + c<br></code></pre></td></tr></table></figure></li><li>注意：在2.1节也介绍了共用子表达式的设计，但是两者不同。2.1节是算数电路级的子表达式；而2.2节是门级电路的共用子表达式。</li><li>使用下面指令设置结构优化<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">set</span>_structure <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>展平优化</p><ul><li>将多级的组合逻辑电路减少为两级，都变为<strong>先与后或</strong>的电路。如下图所示。</li></ul><img src="3201119-20230731100100130-12339361.png" style="zoom:50%"/><ul><li>主要用作速度的优化，电路面积可能会增大。</li><li>与约束无关，可以使用下面指令设置展平优化。<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">set_flatten <span class="hljs-keyword">true</span> -effort low | medium | high<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-3-门级优化"><a href="#2-3-门级优化" class="headerlink" title="2.3 门级优化"></a>2.3 门级优化</h3><ul><li><p>门级优化时，DC开始映射，实现门级电路。映射过程中的优化主要包括4个阶段：</p><ul><li>延迟优化</li><li>设计规则修整</li><li>以时序为代价的设计规则修整</li><li>面积优化</li></ul></li><li><p>映射考虑组合逻辑和时序逻辑</p><ul><li>对于组合逻辑的映射，主要选择能够满足时间和面积的要求。<ul><li>DC会对每个逻辑表达式进行多个变形，选择一个能够达到要求的逻辑表达式。</li></ul></li><li>对于时序逻辑的映射，选择的时序单元要求能够满足时间和面积的要求。<ul><li>有时，为例提高速度和面积，DC可能会选择比较复杂的时序单元。</li></ul></li></ul><img src="3201119-20230731102620780-718638315.png" style="zoom:50%"/></li><li><p>映射过程中，DC会检查电路是否满足DRC，如果有违例，DC会插入缓冲器以及修改单元的驱动能力。</p><ul><li>DC会首先在不影响面积和速度的情况下，尝试修复所有的DRC违例；如果没有其它方法，那么DC会牺牲时间和面积为代价进行修复。 </li><li>在检查DRC时，可能出现一个寄存器驱动多个寄存器，导致扇出过大不满足DRC规则，DC会将作为驱动的寄存器复制多个，并将扇出进行分割。<ul><li>在 dc_shell -topo 模式下中可以使用下面指令，自动进行扇出分割的优化。<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">compile_ultra -timing_high_effort_script</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="3-优化策略"><a href="#3-优化策略" class="headerlink" title="3. 优化策略"></a>3. 优化策略</h2><h3 id="3-1-增量编辑"><a href="#3-1-增量编辑" class="headerlink" title="3.1 增量编辑"></a>3.1 增量编辑</h3><ul><li>使用增量编辑时，设计不会回到GTECH，不会进行结构级优化和逻辑级优化，但是DesignWare的实现可能会发生变化。</li></ul><h3 id="3-2-自定义路径组和关键范围"><a href="#3-2-自定义路径组和关键范围" class="headerlink" title="3.2 自定义路径组和关键范围"></a>3.2 自定义路径组和关键范围</h3><ul><li><a href="https://www.cnblogs.com/qianbinbin/p/17580461.html">这篇博客</a>中有介绍修复setup违例，其中一种方法就是group_path。需要额外指定group_path是由DC优化策略所决定的。</li><li>DC默认的行为就是对关键路径进行优化，关键路径出现违例，而且没办法为关键路径找到一个更好的优化解决方案时，综合过程就停止。次关键路径也不会被优化，只是简单的完成映射而已。</li><li>除了group_path外，还可以指定关键范围，举例如下，DC会对在相较于关键路径差2ns的范围内的所有路径作优化。<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_critical_range</span> <span class="hljs-number">2</span><span class="hljs-meta"> [current_design]</span><br></code></pre></td></tr></table></figure>  <img src="3201119-20230731160544286-1584948039.png" style="zoom:50%"/><ul><li>解决次关键路径的时序问题可能也可以帮助关键路径的优化。</li><li>但是如果由于对次关键路径的优化导致关键路径的时序变差，那么DC将不对次关键路径进行优化。</li><li><strong>建议关键范围的值不要超过关键路径延时总值的10%。</strong></li></ul></li><li>group_path + 关键范围<ul><li>使DC对更多的路径做优化。<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">group_path</span> - name CLK1 -critical_range <span class="hljs-number">0</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li></ul></li><li>group_path &amp; 关键范围<ul><li>group_path：DC可能会牺牲一个路径组的时序，而让另一个路径组的路径时序有改善。所以可能加入一个路径组，导致时序最差的路径时序变得更差。</li><li>关键范围：不允许因为改善次关键路径而导致关键路径时序变差。</li></ul></li></ul><h3 id="3-3-模块划分"><a href="#3-3-模块划分" class="headerlink" title="3.3 模块划分"></a>3.3 模块划分</h3><ul><li><p>由于DC在对整个电路做综合时，必须保留每个模块的端口，因此逻辑综合不能够跨越模块边界，相邻模块的组合逻辑也不能合并。可以使用group和ungroup命令重新进行模块划分。   </p></li><li><p>举例如下，A到C之间的组合逻辑有些长，第一张图由于划分为三个模块，而DC工具没办法去跨模块进行优化。</p><ul><li>如果A、B、C之间没有层次的分隔，那么综合工具对组合逻辑的优化技术可以充分的使用。如第二张图所示。<ul><li>对于寄存器和组合逻辑顺序的划分可以选择 组合逻辑在寄存器前 或相反。</li><li>但若将组合逻辑放在寄存器前，可以对时序电路有更好的优化效果。</li><li>因为，工具在对时序电路进行优化时，可以选择一个更为复杂的触发器（JK\T\Muxed\Clock-enabled等），将一部分的组合逻辑电路吸收到触发器中，从而使电路的面积更小。</li></ul></li></ul><img src="3201119-20230731163110916-1333786165.png" style="zoom:40%"/><img src="3201119-20230731163133295-1970891544.png" style="zoom:40%"/></li><li><p>模块划分时，尽量不要使用胶合逻辑，可以如下图所示。</p><ul><li>胶合逻辑是模块到模块之间的组合逻辑，由于其不能被其他模块吸收，优化受到了限制。我们可以将胶合逻辑加到某一个模块的组合逻辑中，解决这个问题。</li></ul><img src="3201119-20230731165749749-321657828.png" style="zoom:40%"/></li><li><p>对于模块的划分，我们可以在RTL级进行修改，也可以在DC层进行修改。</p><ul><li><p>DC修改方式</p><ul><li>自动修改划分</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 选择优化延时/面积，更详细的可以参考《DC Synthesis Variables and Attributes Version》</span><br><span class="hljs-built_in">compile</span> -auto_ungroup area|delay<br><span class="hljs-comment"># 也可以直接使用指令，该指令在综合时自动取消所有模块分区和层次结构。</span><br><span class="hljs-built_in">compile</span> -ungroup_all<br></code></pre></td></tr></table></figure><ul><li>手动修改划分<ul><li><p>使用group可以产生新的层次模块。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">group</span> <span class="hljs-title">-design_name</span> NEW_DES -cell_name U23 &#123;U2 U3&#125;<br></code></pre></td></tr></table></figure><img src="3201119-20230731175612001-685439546.png" style="zoom:40%"/></li><li><p>使用ungroup取消一个或所有模块分区。        </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ungroup</span> -start_level <span class="hljs-number">2</span> U23<br></code></pre></td></tr></table></figure><img src="3201119-20230731180135816-723588570.png" style="zoom:40%"/></li></ul></li></ul></li><li><p>如果所有结构完全展开，那么会导致形式验证、ECO、后仿调试，会大大加大难度。所以，一般建议只flatten跨模块的大组合逻辑。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>DC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DC相关理解（二）</title>
    <link href="/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="http://www.cnblogs.com/IClearner">http://www.cnblogs.com/IClearner</a></li><li><a href="https://blog.csdn.net/u010827375/article/details/91398103">https://blog.csdn.net/u010827375/article/details/91398103</a></li><li><a href="https://zhuanlan.zhihu.com/p/425524095">https://zhuanlan.zhihu.com/p/425524095</a></li></ul></li></ul><hr><h2 id="1-线负载模型"><a href="#1-线负载模型" class="headerlink" title="1. 线负载模型"></a>1. 线负载模型</h2><ul><li>根据模型中提供的扇出-线网长度对应表，可以根据线网扇出负载估计线网长度。<ul><li>根据线网长度和阻抗、容抗、面积对应表格计算线上参数和延时信息。</li></ul></li><li>根据延时计算方式，电容和电阻有不同的组合方式，主要有三种模型：<ul><li>worst_case_tree</li><li>best_case_tree</li><li>balanced_tree</li></ul></li><li>指令如下，-name为指定线负载模型名字，来源于工艺库，-library指定工艺库。<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">set_wire_load_model</span> -name <span class="hljs-variable">$WIRE_LOAD_MODEL</span> -library <span class="hljs-variable">$LIB_NAME</span> <br></code></pre></td></tr></table></figure></li><li>按照模块内部子系统net所采用模型分类</li></ul><p><img src="/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230626213836361-578049867.png">  </p><ul><li>TOP<ul><li>该模式下，内部所有的子模块或者子系统都将会使用TOP层所设置的线负载模型，因此会覆盖所有的子模块的设置值。</li><li>由于top层电路规模最大，如果子模块也使用其线负载模型计算，那么最悲观。</li></ul></li><li>ENCLOSED<ul><li>该模式下，会默认选择能够cover整个net路径层次的线负载模型，并不一定是TOP层；</li><li>相较于TOP模式下，延时要短一些。</li></ul></li><li>SEGMENTED <ul><li>该模式下，则严格根据所设置对象的范围分别使用对应的线负载模型；<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">set_wire_load_mode enclosed</span><br></code></pre></td></tr></table></figure></li></ul></li><li>也可以使用默认的线负载模型，指令如下；DC工具在默认情况下会根据设计的cell面积自动选择合适的线负载模型。  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> auto_wire_load_selection <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li>线负载模型的设置在综合阶段可以初步的衡量net的延迟，但是在Routing之后，可以使用寄生参数提取工具，如STARRC抽取的SPEF文件，往往用于STA，根据其寄生参数计算net delay，此时的值会更加具备参考性。</li></ul><h2 id="2-时钟属性"><a href="#2-时钟属性" class="headerlink" title="2. 时钟属性"></a>2. 时钟属性</h2><ul><li>时钟不确定性（uncertainty）包括skew和jitter。</li><li>对于建立时间，考虑的时钟不确定需要包括受前级和本级skew值的影响、本级jitter值以及建立时间裕量。<ul><li>由于是建立时间，需要考虑前级寄存器时钟skew往后移Aps，本级寄存器时钟往前移Bps，那么skew所导致的不确定时间为(A+B)ps。</li></ul></li></ul><h3 id="2-1-时钟偏移（skew）"><a href="#2-1-时钟偏移（skew）" class="headerlink" title="2.1 时钟偏移（skew）"></a>2.1 时钟偏移（skew）</h3><ul><li>由于线网等延时，导致时钟信号到达寄存器口存在相位差。</li><li>其与时钟频率没有直接关系，与时钟线的长度及时钟线驱动的时序单元负载电容、个数有关。</li><li>skew 可以分为四类。<ul><li>Interclock skew<ul><li>不同时钟域之间两条路径的最大skew。</li></ul></li><li>Global skew<ul><li>同一个时钟域下，任意两条路径的最大skew。</li></ul></li><li>Local skew<ul><li>同一个时钟域下，任意两条有时序关系的路径的最大skew。</li></ul></li><li>Useful skew  <ul><li>可以在ICC，设置指令skew_opt。向前或者向后 slack较为充裕的路径借时间来修正violation。具体指令使用可见ICC userguide 5-159页。</li></ul></li></ul></li><li>更多关于skew对建立、保持时间影响的可以看<a href="https://mp.weixin.qq.com/s?__biz=MzU5NzQ1NDI5Nw==&mid=2247483957&idx=1&sn=279c4f86dd2ace14cb2c036f9cdf9f73&chksm=fe527e83c925f79534b3366d788c6ccbb2445ed4efde89b5d5fda4cfb5574cdc6ce3b4b1db89&scene=21#wechat_redirect">这篇博客</a>。 <ul><li>总结来说，Positive skew，setup检查宽松，hold检查更严格。Negative skew，setup检查严格，hold检查更宽松。<ul><li>Postive和Negative的划分是根据时钟分支点到launch寄存器和capture寄存器skew大小的比较；前者&lt;后者，则为Positive；后者&lt;前者，则为Negative。</li></ul></li></ul></li></ul><h3 id="2-2-时钟抖动（jitter）"><a href="#2-2-时钟抖动（jitter）" class="headerlink" title="2.2 时钟抖动（jitter）"></a>2.2 时钟抖动（jitter）</h3><ul><li>不随时间积累，时而超前、时而滞后的偏移。与时钟频率也无直接关系。</li><li>包括随机抖动和固定抖动<ul><li>随机抖动来源于：热噪声、Flicker Noise等，与电子器件和半导体器件的电子和空穴特性有关。选择合适的工艺可以得到更小的随机抖动。</li><li>固定抖动来源于：开关电源噪声、串扰、电磁干扰等。可以通过优化设计改善固定抖动；如选择合适的电源滤波方案、合理的PCB布局布线。</li></ul></li></ul><h3 id="2-3-时钟延迟（latency）"><a href="#2-3-时钟延迟（latency）" class="headerlink" title="2.3 时钟延迟（latency）"></a>2.3 时钟延迟（latency）</h3><ul><li>时钟信号从时钟源（例如：晶振）触发到达触发器时钟端口的延时，为时钟延迟。<ul><li><p>主要包括时钟源延迟（source latency）和 时钟网络延迟（network latency）。  </p><p><img src="/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230626132859580-2132739508.png"></p></li></ul></li></ul><h3 id="2-4-CTS之前-模拟时钟树的建模"><a href="#2-4-CTS之前-模拟时钟树的建模" class="headerlink" title="2.4 CTS之前 模拟时钟树的建模"></a>2.4 CTS之前 模拟时钟树的建模</h3><ul><li>（1）clk transition，模拟时钟树的驱动能力和负载。</li><li>（2）clk uncertainty，主要是模拟skew。</li><li>（3）clk latency，模拟时钟树线网延时。</li></ul><h2 id="3-时序约束实例"><a href="#3-时序约束实例" class="headerlink" title="3. 时序约束实例"></a>3. 时序约束实例</h2><p><img src="/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230626135608485-1889722607.png"></p><h3 id="3-1-路径2的约束"><a href="#3-1-路径2的约束" class="headerlink" title="3.1 路径2的约束"></a>3.1 路径2的约束</h3><ul><li>为了满足FF2的建立时间要求，触发器翻转时间 $ T_{clk2q}$ +寄存器和寄存器之前的组合逻辑延时 $ T_{logic}+t_{setup-FF2}$ ＜ 时钟周期。</li><li>保持时间一般是满足的，因为传输的延时($T_{clk2q}+T_{logic}$)一般都会大于触发器的保持时间。</li></ul><h3 id="3-2-路径1的约束"><a href="#3-2-路径1的约束" class="headerlink" title="3.2 路径1的约束"></a>3.2 路径1的约束</h3><p><img src="/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/1.png"></p><ul><li>首先需要告诉DC被综合模块外的延时为 $T_{clk2q}+T_M$，留下的时间为 $T_{clk}-T_{clk2q}-T_M$，将其与 $T_n+T_{setup}$ 时间相比较，如果 $T_n$ 太大，那么DC会对其进行优化，如果最优解也大于留下的时间，那么就会报错。<ul><li>假设我们已知输入端口外部电路的延迟为4ns，那么可以使用DC的约束指令<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_input_delay</span>  -max <span class="hljs-number">4</span> -clock  CLK <span class="hljs-meta"> [get_ports   A]</span><br><span class="hljs-attribute">set_input_delay</span> <span class="hljs-number">3</span>.<span class="hljs-number">5</span> -max -clock clk1<span class="hljs-meta"> [remove_from_collection [all_inputs][get_ports clk1]]</span><br><span class="hljs-comment"># 命令表示从所有的输入端口中除掉时钟clk  </span><br></code></pre></td></tr></table></figure></li></ul></li><li>前面介绍的是不考虑不确定因素的情况，当考虑时钟不确定性，有以下分析<ul><li>假设时钟不确定时间为U，假设触发器的建立时间为1ns，外部输入延时为D，那么内部N逻辑所允许的最大延迟S为：<ul><li>$S &#x3D; T_{clk}-D-U-1$</li></ul></li></ul></li></ul><h3 id="3-3-路径3的约束"><a href="#3-3-路径3的约束" class="headerlink" title="3.3 路径3的约束"></a>3.3 路径3的约束</h3><p><img src="/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230626150744715-795186339.png"></p><ul><li><p>告诉DC要综合的模块外部电路延时为 $T_t+T_{FF3setup}$ 留下的时间为 $T_{clk}-T_t-T_{FF3setup}$ 时间，将这个值与$T_{clk2q}+T_s$ 相比较，如果 $ T_s$ 太大，那么DC会对其进行优化，如果最优解也大于留下的时间，那么就会报错。</p><ul><li>假设DC约束指令如下<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">create_clock</span>  -period <span class="hljs-number">20</span> <span class="hljs-meta"> [get_ports Clk]</span><br><span class="hljs-attribute">set_output_delay</span>  -max  <span class="hljs-number">7</span>.<span class="hljs-number">0</span>  -clock   Clk <span class="hljs-meta"> [get_ports  B]</span><br></code></pre></td></tr></table></figure></li></ul><p><img src="/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230626151654320-255737286.png"></p></li><li><p>上面是没有考虑时钟不确定的，假设综合模块内部延时为S（包含 $T_{clk2q}$ 和组合逻辑延时），外部输出延时为X（包括外部组合逻辑和后级寄存器的建立时间），时间不确定度为Y，时钟周期为T。</p><ul><li>满足 $T-S-Y&#x3D;X$。</li></ul></li></ul><h3 id="3-4-路径4的约束"><a href="#3-4-路径4的约束" class="headerlink" title="3.4 路径4的约束"></a>3.4 路径4的约束</h3><ul><li>分为两种情况<ul><li><p>模块内部除了从输入到输出的组合逻辑外还有时序逻辑。</p><p><img src="/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230626153544543-2038590331.png"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_input_delay</span>  <span class="hljs-number">0</span>.<span class="hljs-number">4</span>  -clock  CLK  -add_delay<span class="hljs-meta"> [get_ports B]</span><br><span class="hljs-attribute">set_output_delay</span>    <span class="hljs-number">0</span>.<span class="hljs-number">2</span>  -clock  CLK  -add_delay<span class="hljs-meta"> [get_ports D]</span><br><span class="hljs-attribute">set_max_delay</span>   $CLK_PERIOD  -from<span class="hljs-meta"> [get_ports B]  -to  [get_ports D] </span><br></code></pre></td></tr></table></figure><ul><li>DC计算 $ T&gt;E+F+U+G $（其中U为不确定时间）。</li></ul></li><li><p>模块内部都是组合逻辑，没有时序逻辑，这种需要使用虚拟时钟的概念。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>DC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DC相关理解（一）</title>
    <link href="/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/11/02/DC%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="http://www.cnblogs.com/IClearner">http://www.cnblogs.com/IClearner</a></li><li><a href="https://www.cnblogs.com/ASIC-Horizon/p/10053487.html">https://www.cnblogs.com/ASIC-Horizon/p/10053487.html</a></li><li><a href="http://www.kiaic.com/article/detail/2469.html">http://www.kiaic.com/article/detail/2469.html</a></li><li><a href="https://blog.csdn.net/uiojhi/article/details/113575422">https://blog.csdn.net/uiojhi/article/details/113575422</a></li><li><a href="https://zhuanlan.zhihu.com/p/139113465">https://zhuanlan.zhihu.com/p/139113465</a></li></ul></li></ul><hr><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>report_lib命令可以查看工艺库中常用的物理量单位。</li><li>不要人为加紧对整个设计的约束，以免限制DC对真正关键的器件适当的优化。</li></ul><hr><h2 id="1-DC做了什么？"><a href="#1-DC做了什么？" class="headerlink" title="1. DC做了什么？"></a>1. DC做了什么？</h2><ol><li>对读入的设计（verilog&#x2F;vhdl&#x2F;system verilog）进行翻译，得到统一的格式GTECH。</li><li>施加各种约束，接近实际电路，这样在库中才能选择更准确地映射器件；对时序和面积进行优化。</li><li>选择合适工艺库中的器件一一映射。</li></ol><h2 id="2-做完综合可以得到什么？"><a href="#2-做完综合可以得到什么？" class="headerlink" title="2. 做完综合可以得到什么？"></a>2. 做完综合可以得到什么？</h2><ul><li>.ddc   包括映射的门电路信息与网表、.v格式的网表、延时信息（sdf）、设计约束（sdc）等信息。</li><li>.v     网表，用作后仿真</li><li>.sdf   描述设计网表中单元延迟以及互连线延迟，用作后仿真</li><li>.sdc   约束文件，可以给到ICC，用于下一步布局布线</li><li>Scan_def.def   扫描链布局信息</li></ul><h2 id="3-电路延迟模型"><a href="#3-电路延迟模型" class="headerlink" title="3. 电路延迟模型"></a>3. 电路延迟模型</h2><ul><li>器件延迟<ul><li>NLDM  <ul><li>表格得到的信息是上升下降沿delay的值以及output transition的值。</li><li>查找表依照input transition，output load查找。</li><li>65nm及更大工艺 准确可靠。</li><li>电压源模型，随着连线金属电阻变大，电压源模型失真。</li></ul></li><li>CCS   <ul><li>电流源模型，查找表参数依然是input transition，output load。</li><li>表中的值不再是定值，而是电流波形。</li></ul></li><li>无论是CCS还是NLDM模型，都需要注意index不要超过查找表的range，否则计算结果不准确，没有参考意义。</li></ul></li><li>线延迟<ul><li>WLM 线负载模型 <ul><li>设计规模不同，模型不同，不准确</li><li>关心线上挂了多少负载，计算RC模型。并不关心线长。</li></ul></li><li>Topographical Mode<ul><li>先用DC跑一版不带物理约束（布局信息）的，得到ddc网表，用于ICC初步布局，吐出物理约束DEF文件，再跑DC综合，得到第二次的ddc网表文件，再给ICC布局布线。<ul><li>DEF Design Exchange Format, 用于不同软件之间的电路物理信息交互；对库单元以及他们的位置和连接关系进行描述。</li></ul></li><li>dc_shell -topo 模式启动</li><li>该模式下需要使用compile_ultra</li></ul></li></ul></li></ul><h2 id="4-DC的几个库文件"><a href="#4-DC的几个库文件" class="headerlink" title="4. DC的几个库文件"></a>4. DC的几个库文件</h2><ul><li><p>逻辑库</p><ul><li>逻辑单元相关信息</li><li>设计规则约束</li><li>针对特定工艺的操作条件及线负载模型（WLM）</li></ul></li><li><p>链接库（link_library）</p><ul><li>用于解析元件使用的逻辑库</li></ul></li><li><p>目标库 (target_library)</p><ul><li>用于实现设计功能的逻辑库</li></ul></li><li><p>DC使用链接库中的单元对设计进行翻译，然后再将其优化、映射到目标库上。</p></li><li><p>举个例子</p><ul><li>link_library：tcbn65lpwc.db,dw_fondation.sldb；<ul><li>其中dw_foundation.sldb 是Synopsys提供的Design Ware的综合库，除了在link_library中指定<strong>还需要在synthetic_library中指定</strong>。</li><li>Design Ware库：它包含了一些IP，如一些基础运算和算术单元等（DWF_ mult_ tc,DWF_ div_ uns和DWF_sqrt_tc单元等）。</li></ul></li><li>target_library：tcbn65lpwc.db</li></ul></li><li><p>symbol library</p><ul><li>提供DC GUI界面设计实现的图形符号，如果使用脚本模式而不是图形模式，可以不指定。</li></ul></li><li><p>库文件一般都是.db结尾，该文件无法直接打开，需要找到对应的lib文件。</p></li></ul><h2 id="5-读入设计文件"><a href="#5-读入设计文件" class="headerlink" title="5. 读入设计文件"></a>5. 读入设计文件</h2><ul><li>analyze &amp; elaborate<ul><li>analyze 对设计进行检查。<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">analyze -<span class="hljs-keyword">format</span> verilog -vcs <span class="hljs-string">&quot;-f filelist.f&quot;</span><br></code></pre></td></tr></table></figure></li><li>elaborate 将检查后的设计转化为工艺独立的GTECH设计。该指令可以自动link。<ul><li>link：首先确认设计需要引用哪些库单元或子设计，然后在链接库中找这些单元，之后再将设计连接到链接库中的单元。</li></ul></li></ul></li></ul><h2 id="6-接口特性"><a href="#6-接口特性" class="headerlink" title="6. 接口特性"></a>6. 接口特性</h2><ul><li>为了保证使用约束语言对电路的每一条时序路径建模精准，我们需要考虑<ul><li>输入&#x2F;输出路径延迟约束，在<a href="https://www.cnblogs.com/qianbinbin/p/17505346.html">这篇博客</a>中有详细介绍。</li><li>接口的环境属性，下面详细展开。</li></ul></li></ul><h3 id="6-1-输入端口的外部驱动特性"><a href="#6-1-输入端口的外部驱动特性" class="headerlink" title="6.1 输入端口的外部驱动特性"></a>6.1 输入端口的外部驱动特性</h3><ul><li>对于输入端口来说，上一级的驱动能力以及输入端口的容性负载决定了输入信号的延迟时间和transition time。</li><li>驱动能力是驱动阻抗的倒数，跳变时间是驱动阻抗和输入端口容性负载的乘积。<ul><li>一个MOS管的开关模型是一个电阻串联一个开关，驱动阻抗越小，分压就越少，而负载上的电压越高，可以带起功率更大的负载来。</li><li>跳变时间的计算是基于RC模型的。</li></ul></li><li>几条指令区别<ul><li>set_driving_cell<ul><li>模拟端口驱动器件，工具在库中找到更真实的transition。</li></ul></li><li>set_drive<ul><li>通过为input&#x2F;inout端口指定电阻值来定义外部驱动强度。</li></ul></li><li>set_input_transition<ul><li>指定端口transition time。</li></ul></li><li>对于设计顶层端口进行驱动定义时,不可以使用set_drive_cell，因为不知道顶层端口的驱动单元是什么。 </li><li>对于时钟、复位信号这类大扇出的信号，一般设置set_drive 0,表示驱动无穷大，并且设置set_dont_touch_network不让综合工具插入buffer。<ul><li>因为综合时没有布局布线信息，即使综合工具针对时钟和复位进行了优化，也是不准确的，拿一个不准确的clk信号去分析setup和hold也没有意义；正确的做法就是不要处理，而要到后端再去做CTS。</li><li>对于复位信号处理：满足恢复时间约束和撤销时间约束。create_buffer_tree （？？？）.</li></ul></li></ul></li></ul><h3 id="6-2-设置输入、输出端口的负载"><a href="#6-2-设置输入、输出端口的负载" class="headerlink" title="6.2 设置输入、输出端口的负载"></a>6.2 设置输入、输出端口的负载</h3><ul><li>使用set_load指令对输入&#x2F;输出容性负载进行定义。</li><li>输入端口负载DC可以自动获取，不需要人为设置。</li></ul><h3 id="6-3-定义输出端口扇出负载"><a href="#6-3-定义输出端口扇出负载" class="headerlink" title="6.3 定义输出端口扇出负载"></a>6.3 定义输出端口扇出负载</h3><ul><li>set_fanout_load：用于约束输出端口，设置该级扇出负载为N，告诉下一级cell，最大的max_fanout要至少大于N + 已知load。<ul><li>而上面那句话介绍的set_max_fanout是用来约束输入端口的，限制前一级的扇出负载不能大于这级能承受的值。</li></ul></li></ul><h3 id="6-4-几条易混淆命令解释"><a href="#6-4-几条易混淆命令解释" class="headerlink" title="6.4 几条易混淆命令解释"></a>6.4 几条易混淆命令解释</h3><ul><li>注意<ul><li>默认情况下，DRC的约束等级最高，可以使用compile -option 选择更高优先级优化，可见用户指令手册。</li><li>因为DRC优先级最高，所以不要施加过紧或过松的约束，都会影响DC对其他单元的优化。</li><li>DRC的约束主要包括<ul><li>set_max_transition、set_max_fanout、set_max_capacitance</li></ul></li></ul></li><li>set_max_transition<ul><li>防止出现长连线导致的长的转换时间，另外这条指令可以约束转换时间，降低功耗。</li></ul></li><li>set_load <ul><li>选项加上[load_of AN2]，可以设置一个标准单元，并用该单元的标称电容和连线电容作为总的电容值。模拟输出端口驱动的外部负载，设置的值影响输出端口net上的电容，影响相应路径延时。</li><li>可以在set_load直接加数字，指定一常数负载值。</li></ul></li><li>set_max_capacitance <ul><li>可以使用该命令为整个设计所有的线网设置最大电容的设计规则。</li></ul></li><li>set_max_fanout<ul><li>fanout数量太大一方面会导致route容易在此处出现congestion；另一方面可能会出现EM问题：由于fanout太大，输出电流过大，导致这部分的金属线长时间被熔断或变形，进而出现短路&#x2F;断路的问题。</li><li>同样可能会出现EM现象的还有尺寸大的cell，例如大小为x24&#x2F;x32；这种cell的默认属性为dont use。这种尺寸的cell，虽然驱动能力大，但其输出电流也大，如果fanout后为多个这样的cell，那么容易出现EM问题。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字中后端</category>
      
      <category>DC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内存重排序</title>
    <link href="/2023/11/01/%E5%86%85%E5%AD%98%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/11/01/%E5%86%85%E5%AD%98%E9%87%8D%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/125737864">https://zhuanlan.zhihu.com/p/125737864</a></li></ul></li></ul><hr><h2 id="1-内存重排序"><a href="#1-内存重排序" class="headerlink" title="1. 内存重排序"></a>1. 内存重排序</h2><ul><li><a href="https://www.cnblogs.com/qianbinbin/p/17731460.html">这篇博客</a>中介绍由于对MESI的优化导致出现重排序，这里主要介绍内存重排序。</li><li>这里只考虑一个核重排序两个不同内存地址的内存操作（load&#x2F;store）；对于相同地址的内存操作，在顺序执行（冯诺依曼）架构下要求是按照程序顺序执行。</li><li>根据内存操作是load&#x2F;store，重排序可以分为下面三种场景<ul><li>store - store<ul><li>由于MESI优化时，为每个CPU插入了一个store buffer，可能会出现有的store操作需要写数据到store buffer，而有的store操作不需要写入store buffer；从而导致两个store操作可能会发生重排序。具体可以看MESI协议相关内容的<a href="https://www.cnblogs.com/qianbinbin/p/17731460.html">博客</a>。</li></ul></li><li>load - load<ul><li>考虑到读出时，有的可以直接从store buffer&#x2F;cache中读出，而有的则需要先从内存中取数据并与其它CPU进行比较再读出；从而导致了load-load重排序。</li></ul></li><li>store - load &amp; load - store <ul><li>和上面的介绍相同，由于读出&#x2F;写入 cache状态不同，导致有不一样的延时，可能会发生store - load &#x2F; load - store重排序。</li></ul></li></ul></li><li>对于x86架构处理器，为TSO内存一致性模型，仅支持store - load重排序，其它三种均不支持。具体内容见<a href="https://www.cnblogs.com/qianbinbin/p/17723730.html">这篇博客</a>。</li></ul><h2 id="2-内存屏障"><a href="#2-内存屏障" class="headerlink" title="2. 内存屏障"></a>2. 内存屏障</h2><ul><li><p>为了禁止部分类型的内存重排序，可以通过插入内存屏障(Memory Barriers)。</p></li><li><p>下面对两种类型的内存屏障分析基于以下代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//CPU0执行func1()，CPU1执行func2()，a变量在CPU1的cache中，b变量在CPU0的cache中。</span><br>a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span>()</span>&#123;<br>  a=<span class="hljs-number">1</span>;<br>  smp_mb();<br>  b=<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun2</span>()</span>&#123;<br>  <span class="hljs-keyword">while</span>(b==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>  smp_mb();<br>  assert(a=<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>上面代码执行过程如下</p><ul><li>（1）CPU0 执行a&#x3D;1的赋值操作，由于a不在CPU0的cache中，所以CPU0先将写入值1放在store buffer中，并发送invalid message到总线上。</li><li>（2）CPU1 执行while(b&#x3D;&#x3D;0)循环判断，由于b不在CPU1的cache里面，所以CPU1发送一个read message到总线上，观察其它CPU是否有此地址的cache以及memory中是否有相关信息。</li><li>（3）CPU1 收到CPU0的invalid 信息后，立即返回已经invalid信息，并将invalid信息送入invalid queue，在CPU空闲时清空自己的cacheline。</li><li>（4）CPU0 收到CPU1的invalid回执后，将store buffer中的值<strong>a&#x3D;1</strong>写回cacheline中，并更改状态为modified。</li><li>（5）CPU1 收到CPU0发送的b值，并将其写入自己的cache中，并将状态设为shared状态。</li><li>（6）CPU1 将b的值从cache line中load到寄存器中，此时满足条件b&#x3D;&#x3D;0，所以一直在循环。</li><li>（7）CPU0 执行smp_mb()函数，应该将store buffer中的数据都写入cache中，就这个例子，a&#x3D;1已经写入cache中了。</li><li>（8）CPU0 执行b&#x3D;1的赋值操作，由于b的值在CPU0的cache中，原状态为shared，所以需要发送invalid信号给其它CPU，先写入store buffer中。</li><li>（9）CPU0 在接收到CPU1的invalid 回执后，将b&#x3D;1值写入cache中，并更改状态为modified。而CPU1对应地址的cache应为invalid。</li><li>（10）CPU1 再次发现b所在cache为invalid状态，所以CPU1发送一个read message到总线上，观察其它CPU是否有此地址的cache以及memory中是否有相关信息。</li><li>（11）CPU1 收到CPU0发送的b值，并将其写入自己的cache中，并将状态设为Modified状态。</li><li>（12）CPU1 将b的值从cache line中load到寄存器中，此时不满足条件b&#x3D;&#x3D;0，所以跳出循环。</li><li>（13）CPU1 执行smp_mb()函数，会对invalid queue中的项进行标注，随后相关cacheline的load操作需要等待invalid queue中被处理，才可以继续执行。</li><li>（14）CPU1 在smp_mb()函数之后，a相关的cache被清除，需要重新读取。如果没有该处屏障，那么CPU1会拿到a最原始的值0，assert失败。</li><li>（15）CPU1发送一个read message到总线上，观察其它CPU是否有此地址的cache以及memory中是否有相关信息。最终从CPU0那里获取到a&#x3D;1的新值，assert正确。</li></ul></li><li><p>上面介绍的过程中，smp_mb()函数主要包括两类：</p><ul><li><p>Store Memory Barriers</p><ul><li>告诉CPU在执行 屏障之后的指令 前，需要先将所有在store buffer中的数据更新到cacheline中。</li></ul></li><li><p>Load Memory Barriers</p><ul><li>告诉CPU在执行任何load操作前，先处理所有在invalid queue中的invalid 消息。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
      <category>内存相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MESI协议</title>
    <link href="/2023/11/01/MESI%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/11/01/MESI%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/375706879">https://zhuanlan.zhihu.com/p/375706879</a></li><li><a href="https://zhuanlan.zhihu.com/p/112605471">https://zhuanlan.zhihu.com/p/112605471</a></li><li><a href="https://zhuanlan.zhihu.com/p/125549632">https://zhuanlan.zhihu.com/p/125549632</a></li></ul></li></ul><hr><h2 id="1-MESI-四种状态"><a href="#1-MESI-四种状态" class="headerlink" title="1. MESI 四种状态"></a>1. MESI 四种状态</h2><ul><li>在<a href="https://www.cnblogs.com/qianbinbin/p/17617970.html">这篇博客</a>中有介绍MESI协议的四种状态分别为：Modified、Exclusive、Shared、Invalid.</li><li>由于下面四种操作，Cache的状态会在MESI间跳转。<ul><li>LR: Local Read，当前CPU读操作</li><li>LW: Local Write，当前CPU写操作</li><li>RR：Remote Read，其它CPU读操作</li><li>RW: Remote Write，其它CPU写操作</li></ul></li></ul><img src="3201119-20230926232206330-164782807.png" style="zoom:50%;" /><ul><li>针对上面的状态转移图，进行下面四种状态的详细分析。<ul><li><p>Modified</p><ul><li>LR：当前CPU读操作，缓存中拥有最新数据，直接从缓存中读取就可以。仍为<strong>Modified</strong>。</li><li>LW：当前CPU写操作，直接修改当前CPU缓存数据，修改后仍拥有最新数据，仍为<strong>Modified</strong>。</li><li>RR：其它CPU读操作，为了保证一致性，需要当前CPU将数据写回内存，并从当前CPU中获取cacheline给到其它CPU，并更改所有CPU 状态为<strong>Shared</strong>。      </li><li>RW：其它CPU写操作，需要当前CPU将数据写回内存，并完成其它CPU的写操作，以及更改除 完成写的CPU 的其它CPU状态为<strong>Invalid</strong>。</li></ul></li><li><p>Exclusive</p><ul><li>LR：当前CPU读操作，可以直接读出，仍为<strong>Exclusive</strong>。</li><li>LW：当前CPU写操作，修改当前缓存内的数据，并更改状态为<strong>Modified</strong>。</li><li>RR：其它CPU读操作，将当前CPU cache中的数据分享给其它CPU，并更改状态为<strong>Shared</strong>。</li><li>RW：其它CPU写操作，当前CPU 的Cacheline不可用，更改当前状态为<strong>Invalid</strong>。</li></ul></li><li><p>Shared</p><ul><li>LR：当前CPU读操作，可以直接读出，仍为<strong>shared</strong>。</li><li>LW：当前CPU写操作，更改状态为<strong>Modified</strong>。</li><li>RR：其它CPU读操作，多个CPU的数据都与内存中一致，所以状态仍为<strong>Shared</strong>。</li><li>RW：其它CPU写操作，其它CPU数据为最新，当前CPU数据失效，更改当前CPU状态为<strong>Invalid</strong>。</li></ul></li><li><p>Invalid</p><ul><li>LR：当前CPU读操作，CPU缓存不可用，需要重新从内存中加载cacheline。<ul><li>其它CPU无数据，当前CPU加载新的数据后，更改状态为<strong>Exclusive</strong>。</li><li>其它CPU有数据，且状态为S&#x2F;E，即从内存中取出数据与其它CPU数据一致，那么状态修改为<strong>Shared</strong>。</li><li>其它CPU有数据，且状态为M，即其cache中数据和内存中数据不一致，那么会先让其它CPU将数据写回内存中，随后当前CPU再读出内存中数据，此时当前CPU的数据和其它CPU以及内存中数据均一致，状态修改为<strong>Shared</strong>。</li></ul></li><li>LW：当前CPU写操作，当前CPU缓存不可用，首先需要从内存中取出数据到cacheline。<ul><li>其它CPU无数据，且当前CPU写入数据和内存数据不一致时，更改状态为<strong>Modified</strong>。</li><li>其它CPU有数据，且它们状态为S&#x2F;E，那么当前CPU写入数据，并更新当前CPU状态为<strong>Modified</strong>。</li><li>其它CPU有数据，且它们状态为M，那么需要先将其它CPU的cache数据写回主存，随后再写入当前CPU的cache中，并更新状态为<strong>Modified</strong>。并发送给其它CPU invalid信号。</li></ul></li><li>RR：其它CPU读操作，因为当前CPU处于Invalid状态，所以其它CPU读操作与当前CPU无关，状态保持<strong>Invalid</strong>。</li><li>RW：其它CPU写操作，因为当前CPU处于Invalid状态，所以其它CPU写操作与当前CPU无关，状态保持<strong>Invalid</strong>。</li></ul></li></ul></li></ul><h2 id="2-MESI-协议的问题及优化"><a href="#2-MESI-协议的问题及优化" class="headerlink" title="2. MESI 协议的问题及优化"></a>2. MESI 协议的问题及优化</h2><ul><li>问题<ul><li>考虑到在MESI中，需要依赖总线嗅探机制，整个过程是串行的，因此可能会发生阻塞。举例如下。<ul><li>假设CPU0 特定地址的cacheline 为shared状态，那么CPU0会发送invalid信号给其它CPU。</li><li>而其它CPU接收到invalid信号后，将对应cacheline的valid bit拉低。</li><li>CPU0 会在收到CPU1更改invalid信息后，再修改对应cache line的数据，并将对应的状态更改为Modified。所以存在一段阻塞时间。</li><li>另外当高速缓存压力很大时，可能实时处理invalid事件也需要一定阻塞时间。两种阻塞情况都会导致性能降低。</li></ul></li></ul></li><li>优化<ul><li>Store Buffer<ul><li>可为每个CPU添加一个Store Buffer。<ul><li>当发生LW时，CPU可以不用等待其它CPU回复的信息，直接将更新的值写入Store Buffer中，继续执行后续操作，不必插入阻塞等待时间。<ul><li>在其它CPU回复后，再将数据从Store Buffer中写入cache line，并更改状态为Modified。</li></ul></li></ul></li><li>当发生LR时，CPU可以先在Store Buffer中查找，如果存在直接从Store Buffer中获取，若没有再查找Cache Line。</li></ul></li><li>Invalid Queue<ul><li>为什么需要invalid queue<ul><li>假设所有的store操作都需要CPU发出invalid信号给其它CPU，store buffer可能会被填满，那么CPU只能进入等待状态。性能并没有得到很大提升。</li><li>引入invalid queue可以加快收到invalid回执的速度，减少每个数据在store buffer停留时间段。</li></ul></li><li>可为每个CPU添加一个Invalid Queue。<ul><li>当发生RW操作时，当前CPU都需要进行Invalid操作，并返回给那个正在完成LW操作的CPU信息。</li><li>使用失效队列后，当前CPU会首先将接收到的Invalid信息放到Invalid Queue中，并立即返回已经invalid的信息。在后续CPU空闲下来时再处理Invalid Queue中的信息，将对应地址的cache line置为无效。</li></ul></li><li>如果当前CPU想要发送MESI信息给其它CPU，会先检查invalid queue中是否有相关的cacheline，如果有的话，那么不可以立刻发送，需要等待invalid queue中的cacheline被处理之后再发送。</li></ul></li></ul></li><li>优化后的问题<ul><li>插入 Store Buffer之后，可能会出现 即使指令本身是按照顺序执行的，但最终仍然会<strong>乱序执行</strong>。<ul><li>举例1：按照顺序依次执行A,B两个写指令，A写指令对应地址缓存处于S状态，B写指令对应地址缓存处于E状态，那么B会比A先完成写入操作。<ul><li>因为A写入之后，需要发送给其它CPU invalid信息，A写入的数据会进入Store Buffer中；而B写入之后，由于cacheline是独占的，所以不需要通知其它CPU，直接更改cacheline中的数据就可以，并更新状态为Modified。</li></ul></li><li>举例2：按照顺序依次执行C,D两个读指令，C读指令对应地址缓存处于I状态，D读指令对应地址缓存处于S状态，那么D会比C先完成读操作。<ul><li>因为C读取前，需要先从内存中加载cacheline，并需要与其它CPU进行比较，参考上面Invalid的介绍。而D读取可以直接读出，并不需要更改状态。</li></ul></li></ul></li><li>插入 Invalid Queue 之后，可能会导致读取到过时的数据。<ul><li>举例：CPU0执行LW操作，对应cacheline为S状态，那么他会发送invalid信息给其它CPU，CPU1会将invalid信息写入他的invalid queue，并立即回复CPU0表示已经执行invalid操作（后面都会称这个过程为 返回回执）。<ul><li>CPU0接收到回执后，更新缓存行，但是CPU1可能还没来得及做invalid操作，此时CPU1如果发生读操作，会导致读到过时数据。</li></ul></li></ul></li></ul></li></ul><h2 id="3-重排序"><a href="#3-重排序" class="headerlink" title="3. 重排序"></a>3. 重排序</h2><ul><li>前面有介绍优化MESI后可能会出现的一致性问题。MESI协议原是强一致性，为了优化其性能，最终弱化成了最终一致性。可能会出现重排序的情况。</li><li>重排序一般包括下面三种<ul><li>编译器优化的重排序<ul><li>编译器在不改变单线程语义的前提下，可以重新安排语句的执行顺序。</li></ul></li><li>指令级并行的重排序<ul><li>处理器采用指令级并行技术（Instruction-Level Parallesim，ILP），如果指令之间不存在数据依赖性，处理器可以改变语句对应的机器指令的执行顺序。</li><li>ILP相关内容可以看<a href="https://www.cnblogs.com/qianbinbin/p/17735751.html">这篇博客</a>。</li></ul></li><li>内存系统的重排序  <ul><li>由于处理器使用缓存和读&#x2F;写缓冲区，使得load和store看上去是乱序执行的。</li><li>内存重排序相关内容可以看<a href="https://www.cnblogs.com/qianbinbin/p/17738130.html">这篇博客</a>。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
      <category>Cache</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内存模型</title>
    <link href="/2023/11/01/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/11/01/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/weixin_43008591/article/details/131872164">https://blog.csdn.net/weixin_43008591/article/details/131872164</a></li><li><a href="https://zhuanlan.zhihu.com/p/422848235">https://zhuanlan.zhihu.com/p/422848235</a></li><li><a href="https://blog.csdn.net/qq_29328443/article/details/107616795">https://blog.csdn.net/qq_29328443/article/details/107616795</a></li><li><a href="https://zhuanlan.zhihu.com/p/563126470">https://zhuanlan.zhihu.com/p/563126470</a></li><li><a href="https://zhuanlan.zhihu.com/p/563127372">https://zhuanlan.zhihu.com/p/563127372</a></li><li><a href="https://blog.csdn.net/qq_29328443/article/details/104215898">https://blog.csdn.net/qq_29328443/article/details/104215898</a></li><li><a href="https://gitee.com/laokz/OS-kernel-test/blob/master/memorder/riscv.md">https://gitee.com/laokz/OS-kernel-test/blob/master/memorder/riscv.md</a></li><li><a href="https://drive.google.com/file/d/1s0lZxUZaa7eV_O0_WsZzaurFLLww7ou5/view">https://drive.google.com/file/d/1s0lZxUZaa7eV_O0_WsZzaurFLLww7ou5/view</a></li><li><a href="https://zhuanlan.zhihu.com/p/21387258">https://zhuanlan.zhihu.com/p/21387258</a></li><li>《A Primer on Memory Consistency and Cache Coherence》</li></ul></li></ul><hr><h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0. 写在前面"></a>0. 写在前面</h2><ul><li>这部分知识的学习是兴趣导向，没有项目支撑，可能部分理解并不正确，欢迎一起讨论。</li></ul><h2 id="1-隐式-显式-内存访问"><a href="#1-隐式-显式-内存访问" class="headerlink" title="1. 隐式 &amp; 显式  内存访问"></a>1. 隐式 &amp; 显式  内存访问</h2><ul><li>隐式：从存储器中取出指令的过程。</li><li>显式：加载&#x2F;存储指令，根据指令的地址进行显式读写内存操作。</li></ul><h2 id="2-内存一致性模型"><a href="#2-内存一致性模型" class="headerlink" title="2. 内存一致性模型"></a>2. 内存一致性模型</h2><h3 id="2-1-共享内存-执行顺序问题"><a href="#2-1-共享内存-执行顺序问题" class="headerlink" title="2.1 共享内存 执行顺序问题"></a>2.1 共享内存 执行顺序问题</h3><ul><li>举例如下，C1和C2执行顺序可以有多种组合，r1、r2的值也会有多种结果，如下表所示。</li></ul><img src="3201119-20230923112425619-324331088.png" style="zoom:50%;"/>  <ul><li>甚至对于一些系统，{r1,r2}&#x3D;{0,0}.而这些执行顺序是都满足cache coherence。</li></ul><table><thead><tr><th>r1</th><th>r2</th><th>执行顺序</th></tr></thead><tbody><tr><td>0</td><td>NEW</td><td>S1-L1-S2-L2</td></tr><tr><td>NEW</td><td>0</td><td>S2-L2-S1-L1</td></tr><tr><td>NEW</td><td>NEW</td><td>S1-S2-L1-L2</td></tr></tbody></table><h3 id="2-2-Sequential-Consistensy"><a href="#2-2-Sequential-Consistensy" class="headerlink" title="2.2 Sequential Consistensy"></a>2.2 Sequential Consistensy</h3><h4 id="2-2-1-关于-SC"><a href="#2-2-1-关于-SC" class="headerlink" title="2.2.1 关于 SC"></a>2.2.1 关于 SC</h4><ul><li>该模型要求<ul><li>所有的内存访问操作都是<strong>原子操作</strong>，即两个&#x2F;多个核不能同时对内存进行操作。</li><li>对于<strong>单个核</strong>内的内存访问要求<strong>严格按照程序代码顺序</strong>执行（无论是指令顺序执行&#x2F;乱序执行）。</li><li>对于多核间，程序代码可以任意顺序交织执行。</li></ul></li><li>举例如下<ul><li>图中(a)(b)(c)满足顺序一致性模型；(d)不满足顺序一致性模型，因为Core2的程序顺序(S2,L2)和内存顺序(L2,S2)不一致。</li></ul></li></ul><img src="3201119-20230923165655184-1696324924.png" style="zoom:50%;"/><img src="3201119-20230925142959738-1356371306.png" style="zoom:50%;"/><h4 id="2-2-2-SC-实现方法"><a href="#2-2-2-SC-实现方法" class="headerlink" title="2.2.2 SC 实现方法"></a>2.2.2 SC 实现方法</h4><ul><li><p>简单的SC实现</p><ul><li><p>对于多任务的单核处理器：</p><ul><li>在单个核上执行所有线程，线程T1执行一段时间后，进行上下文切换，之后再开始执行T2。</li><li>在上下文切换时必须保证完成所有之前的内存访问指令，来保证SC的规则。</li></ul></li><li><p>使用 Switch模块 处理多核间的内存访问请求：</p><ul><li>前面介绍到SC模型是原子操作，所以内存模型提供的核和内存之间的抽象接口应该是下图的Switch开关模型。</li><li>每个核按照自己对应的<strong>程序顺序</strong>向Switch模块发起内存访问请求，Switch模块负责接收内存请求，并处理。</li></ul><img src="3201119-20231001153427562-684741947.png" style="zoom:50%;"/></li><li><p>这两种方法可以证明SC模型的可行性，但是随着核的数量增加，会很快遇到性能瓶颈。尤其Switch开关让人觉得SC模型无法并发执行，实际可对其进行优化，提升性能。</p></li></ul></li><li><p>有 Cache 一致性的基础SC实现</p><ul><li><p>增加cache，可以并行执行 不冲突的store和load操作。</p><ul><li>这里冲突的定义是，在同一时刻，两个操作同时访问一个地址，且其中至少一个操作是store。</li></ul></li><li><p>如下图，每个核对应一个cache。<a href="https://www.cnblogs.com/qianbinbin/p/17617970.html">这篇博客</a>中有介绍多核Cache间的一致性，可通过缓存一致性协议（MESI&#x2F;MSI&#x2F;MOESI等）保障。</p><img src="3201119-20231001170429491-2132919648.png" style="zoom:50%;"/><ul><li>这里假设使用的是MSI协议，那么可以通过cache的MSI状态，来设定当前的内存是否可读&#x2F;写。<ul><li>Modified状态，表示当前<strong>内存</strong>可读可写。</li><li>Share状态，表示当前<strong>内存</strong>只可读。</li><li>注意：这里可读可写指的是内存，只有在M状态，会出现cacheline中的数据载入内存中。</li></ul></li></ul><img src="3201119-20231001212529763-371812296.png" style="zoom:50%;"/></li></ul></li><li><p>有 Cache 一致性的优化SC实现</p><ul><li>目前大部分内核的SC实现会在基础SC实现基础上加很多技术以提高性能，下面将详细介绍。</li><li>（1）Non-Binding Prefetching<ul><li>硬件预取相关内容可看<a href="https://www.cnblogs.com/qianbinbin/p/17740391.html">这篇博客</a>。</li><li>可以通过硬件预取的方式，隐藏内存访问延迟，降低cache 失效带来的延迟时间。</li><li>由于非绑定预取的预取值是放在cache&#x2F;buffer中的，仍需满足cache coherence。不会影响到内存模型。</li></ul></li><li>（2）Speculative Cores</li><li>（3）Dynamically Scheduled Cores</li><li>（4）Non-Binding Prefetching in Dynamically Scheduled Cores</li><li>（5）Multithreading</li></ul></li></ul><h4 id="2-2-3-SC-内存模型下的原子操作"><a href="#2-2-3-SC-内存模型下的原子操作" class="headerlink" title="2.2.3 SC 内存模型下的原子操作"></a>2.2.3 SC 内存模型下的原子操作</h4><ul><li>原子操作就是不可中断的一个或者一系列操作，不会被线程调度机制打断的操作。</li><li>实现原子操作并不难，但是过于简化的设计会导致性能不佳。<ul><li>例如，在原子操作开始时，让处理器锁定内存系统，防止其它内核进行内存访问，在完成原子操作（读&#x2F;写）之后，再打开内存系统义工其它CPU访问。</li></ul></li><li>原子RMW操作<ul><li>RMW：如果CPU想要更改一个变量的值，那么发生的操作为：从内存<strong>读</strong>出对应地址的值放到寄存器中（read），然后修改寄存器中的值（modify），最后将修改后的值写回内存位置（write），这个过程称为RMW。</li><li>RMW的原子操作可以通过在缓存中实现，注意由于SC对内存操作顺序的严格要求，不存在store buffer、invalid queue。<ul><li>在单个CPU的缓存中实现load和store操作，期间阻塞其它CPU发来的一致性请求信息，在原子操作完成之后再响应其它处理器即可。</li><li>前提条件：原子操作对应的cacheline状态为M（这里仍假设使用的是MSI协议，如上介绍只有M状态可读可写）。</li></ul></li><li>可以对上面的实现方式进行优化<ul><li>考虑到MSI协议中S状态也可读，所以可以实现在不违反原子性的情况下，允许load和store中间有其它操作。</li><li>举例：原子操作对应的cacheline状态为S，此时可以进行load操作，期间若当前CPU发生写操作，那么会更改状态为Modified，此时可以发生store操作。</li><li>但是上面这个过程并不一定能够保证原子性，即无法保证在load和store操作是否会有其它CPU发起一致性请求信息，导致当前CPU的cacheline状态被更改。所以需要处理器进行检查。</li></ul></li></ul></li></ul><h3 id="2-3-Total-Store-Ordering（TSO）"><a href="#2-3-Total-Store-Ordering（TSO）" class="headerlink" title="2.3 Total Store Ordering（TSO）"></a>2.3 Total Store Ordering（TSO）</h3><h4 id="2-3-1-关于TSO"><a href="#2-3-1-关于TSO" class="headerlink" title="2.3.1 关于TSO"></a>2.3.1 关于TSO</h4><ul><li><p>为什么需要TSO</p><ul><li><p>举例1如下</p><img src="3201119-20231005200319206-1292757074.png" style="zoom:50%;"/><ul><li>在考虑存在store buffer的情况下，那么两个处理器可以按照下面的顺序执行：<ul><li>（1）C1执行S1，将store的新值NEW放到store buffer中。 </li><li>（2）C2执行S2，将store的新值NEW放到store buffer中。</li><li>（3）C1和C2分别执行内存load操作，此时load的值均为0。</li><li>（4）最后CPU将store buffer中的值写回内存中。</li><li>注意：CPU在load 内存值前，会先查看store buffer，因此C1是可以看到x的值，但看不到y的值，所以r1&#x3D;0；C2同理。</li></ul></li></ul></li><li><p>上面描述的执行违反了SC，使用store buffer这类可提升性能的硬件设计，需要对内存操作进行重排序。</p><ul><li>对于SC模型，四种内存操作顺序组合中，四种都需满足，严格按照程序顺序向内存发起访问请求。</li><li>对于TSO模型，四种内存操作顺序组合中，仍需满足load-load&#x2F;load-store&#x2F;store-store这三个约束，仅支持store-load重排序操作。</li></ul></li></ul></li><li><p>举例2如下</p><ul><li>C1首先将x的新值NEW写入store buffer中，同理，y的新值NEW也被放到C2的store buffer中。</li><li>C1、C2首先进行的内存操作是L1和L3，此时CPU查看到C1、C2的store buffer中都有x和y的值，所以r1和r3的值分别为新值。</li><li>C1、C2之后进行的内存操作是L2和L4，此时C1和C2分别看到y和x的值为初始值，所以r2和r4的值均为0.</li><li>最后进行的内存操作是S1和S2，此时进行的是store-load重排序，满足TSO模型，将x和y的新值NEW写入内存中。</li></ul><img src="3201119-20231005204023094-1910416683.png" style="zoom:50%;"/><img src="3201119-20231005203938302-741663026.png" style="zoom:50%;"/></li></ul><h4 id="2-3-2-TSO-实现方法"><a href="#2-3-2-TSO-实现方法" class="headerlink" title="2.3.2 TSO 实现方法"></a>2.3.2 TSO 实现方法</h4><ul><li>与SC模型类似，可以使用Switch实现，或是带缓存一致性的内存模型实现。</li><li>与SC的区别在于添加了store buffer。<ul><li><p>该store buffer可以选择为每个CPU分别添加一个或是使用共享store buffer，但buffer中每个条目由CPU id进行标记，需要对应的id相匹配。</p><img src="3201119-20231008130209670-1983742951.png" style="zoom:50%;"/></li></ul></li></ul><h4 id="2-3-3-TSO-模型下的原子操作"><a href="#2-3-3-TSO-模型下的原子操作" class="headerlink" title="2.3.3 TSO 模型下的原子操作"></a>2.3.3 TSO 模型下的原子操作</h4><ul><li>这里仍以RMW原子操作为例：<ul><li>考虑到store操作需要CPU从store buffer中取值写入内存，由于TSO模型支持Store-Load重排序，那么可能会发生下图情况，其中S1为之前的store操作，此时难以保证RMW的原子操作。</li><li>因此，原子RMW操作应在清空store buffer之后再执行。<ul><li><p>这里清空store buffer的意思是指将store buffer中所有的值都写回内存中。</p></li><li><p>为了保证load之后可以马上进行store操作，需要在load时保证对应cacheline状态为M状态（可读可写状态）。</p><ul><li>由于此时cacheline的状态为Modified状态，所以store操作可以直接写入cache中，绕过store buffer。</li></ul></li><li><p>并且在load和store之间不能处理缓存一致性相关信息，在完成store操作之后再处理。 </p>  <img src="3201119-20231005232829753-1126412102.png" style="zoom:50%;"/></li></ul></li></ul></li></ul><h4 id="2-3-4-FENCE-指令"><a href="#2-3-4-FENCE-指令" class="headerlink" title="2.3.4 FENCE 指令"></a>2.3.4 FENCE 指令</h4><ul><li><p>在TSO下，store-load可以发生重排序，当程序员希望store-load之间为定序，那么可以通过插入FENCE指令来实现。</p><ul><li><p>如下表，由于C1和C2都在S和L操作之间插入了FENCE指令，所以在FENCE时，需要将store buffer中所有的值都写回cache中。因此最后的结果不可能是{r1,r2}&#x3D;{0,0}. </p><img src="3201119-20231006141541627-33100539.png" style="zoom:50%;"/></li></ul></li><li><p>在<a href="https://www.cnblogs.com/qianbinbin/p/17738130.html">这篇博客</a>中，有介绍可通过内存屏障来保证一些内存操作的顺序，其中使用的函数smp_mb()是封装在linux操作系统层的。</p><ul><li>RISC-V的指令集架构中是提供了Fence指令来做内存访问的同步。</li></ul></li></ul><h3 id="2-4-Relaxed-Consistensy"><a href="#2-4-Relaxed-Consistensy" class="headerlink" title="2.4 Relaxed Consistensy"></a>2.4 Relaxed Consistensy</h3><h4 id="2-4-1-关于-RMO（Relax-Memory-Order）"><a href="#2-4-1-关于-RMO（Relax-Memory-Order）" class="headerlink" title="2.4.1 关于 RMO（Relax Memory Order）"></a>2.4.1 关于 RMO（Relax Memory Order）</h4><ul><li>为什么需要RMO<ul><li>一些情景下，内存操作顺序即使发生重排序也不会影响最终语义，此时可以放松内存模型限制来提升性能。</li><li>RMO下需要程序员根据内存操作之间的数据依赖关系考虑 添加内存屏障等操作 来保证顺序。</li></ul></li></ul><h4 id="2-4-2-RMO-下提升性能的优化方法"><a href="#2-4-2-RMO-下提升性能的优化方法" class="headerlink" title="2.4.2 RMO 下提升性能的优化方法"></a>2.4.2 RMO 下提升性能的优化方法</h4><ul><li>（1）Non-FIFO, Coalescing Write Buffer<ul><li>在TSO中，我们要求Store Buffer必须是基于FIFO实现的。因此写入buffer的数据顺序就是刷入cache中的顺序。</li><li>在RMO中，Store Buffer的设计 允许 来自<strong>一个 cacheline</strong> 的相近几个写请求被合并到一个store buffer表项中。<ul><li>store buffer的合并写入也需要特定的要求限制，具体分析可以学习ARM架构下Store Buffer的设计。具体可见<a href="https://cnblogs.com/vaughnhuang/p/16915470.html">这篇博客</a>。</li><li>另外，如果两个store之间存在FENCE指令，那么也不可以合并写入。</li></ul></li></ul></li><li>（2）Simpler Support for Core Speculation</li><li>（3）Coupling Consistency and Coherence<ul><li>在SC&#x2F;TSO模型中，我们认为缓存一致性相关的设计是一个黑盒。</li><li>在RMO模型中，可以将缓存一致性的黑盒打开，允许部分CPU从store buffer中取新值，也允许部分CPU从cache中取旧值。<ul><li>当然，可能需要多个CPU共享一个store buffer或是共享一个L1 DCache。</li></ul></li></ul></li></ul><h4 id="2-4-3-XC-Example-Relaxed-Consistency-Model"><a href="#2-4-3-XC-Example-Relaxed-Consistency-Model" class="headerlink" title="2.4.3 XC (Example Relaxed Consistency Model)"></a>2.4.3 XC (Example Relaxed Consistency Model)</h4><ul><li><p>这里举一个例子来帮助理解松散一致性内存模型。</p></li><li><p>设内存操作顺序遵循下面规则  </p><ul><li>该模型默认 load 和 store 操作是无序的，程序员可以在需要严格排序时使用FENCE指令。</li><li>一个CPU中，FENCE指令也是有先后顺序的。</li><li>当前CPU中的FENCE指令不会影响其它CPU中的内存操作顺序。</li><li>XC模型中只维护 访问相同地址的两个操作间 的TSO排序规则。<ul><li>Load - Load to the same address</li><li>Load - Store to the same address</li><li>Store - Store to the same address</li></ul></li><li>XC模型确保在load操作也会检查store buffer。</li></ul></li><li><p>在XC模型下使用FENCE</p><ul><li><p>如下表所示，F1:FENCE指令排序了Store操作，让C1为data1和data2赋值完新值后，再为flag赋值为SET。</p></li><li><p>F2:FENCE指令是为了防止L2,L3和L1发生重排序。 </p>  <img src="3201119-20231007141039245-1469699710.png" style="zoom:50%;"/></li></ul></li><li><p>XC 实现方法</p><ul><li>TSO 模型中由于存在store buffer，导致store-load可能会发生重排序；XC 模型中添加Reorder Unit，来完成load和store之间的重排序。</li><li>与前面介绍的模型一样，可以使用Switch简单的实现，或是使用带缓存一致性的内存模型实现。</li><li>Switch结构<ul><li>对于每个Core，load&#x2F;store以及FENCE指令按照Ci的程序顺序给到Reorder Unit单元的队尾。</li><li>重排序单元根据程序顺序&#x2F;XC模型内存操作顺序规则 进行重新排序。</li><li>当Switch选择Ci时，会执行Ci的Reorder Unit队首的load&#x2F;store操作。</li></ul></li><li>带缓存一致性 内存模型<ul><li><p>和TSO&#x2F;SC一样，将重排序规则的实现和cache coherence的实现分割开，不同的是增加了Reorder Unit。</p>  <img src="3201119-20231008133755888-219165500.png" style="zoom:50%;"/></li></ul></li></ul></li><li><p>XC 内存模型下的原子操作</p><ul><li>假设XC 内存模型下，存在多个core，每个core通过一个 non-fifo Coalescing Write Buffer 连接到 Memory System。</li><li>XC 内存模型下的原子操作实现可以借用TSO模型，但不需要在RMW操作之前清空store buffer，因为XC模型允许不同地址的store和load乱序操作。</li><li>RMW 操作可用于加锁，如下表，分别为在TSO模型和XC模型下进行加锁和解锁的操作。<ul><li><p>TSO 模型下，使用原子RMW操作进行加锁，加锁之后完成Critical Section 部分的load和store操作，最后向L中写入0，表示解锁。</p><ul><li>我个人认为需要在RMW和Critical Section之间添加一个FENCE指令。因为可能会发生RMW中store操作和Critical Section中的load操作进行重排序。</li></ul></li><li><p>XC 模型下，由于不会限制Critical Section 部分内存操作和RMW之间进行重排序，所以需要添加FENCE指令，另外在Critical Section 和 解锁之间也要插入一个FENCE指令，防止解锁语句和之前的语句发生重排序。</p>  <img src="3201119-20231010102001410-1309634596.png" style="zoom:50%;"/></li></ul></li></ul></li></ul><h4 id="2-4-4-无数据竞争（DRF）程序的一致性模型"><a href="#2-4-4-无数据竞争（DRF）程序的一致性模型" class="headerlink" title="2.4.4 无数据竞争（DRF）程序的一致性模型"></a>2.4.4 无数据竞争（DRF）程序的一致性模型</h4><ul><li><p>同步模型  </p><ul><li>RMO 通过放松对内存操作顺序的限制，来给编译器和硬件更多的优化空间，从而提高性能。</li><li>如果程序遵守<strong>特定的限制</strong>，那么程序仍能呈现出SC的效果。</li><li>这个<strong>特定的限制</strong>可以通过同步操作实现，这个同步操作是硬件可以支持的，以C语言中的test_and_set()函数为例。特定的限制也可以称为<strong>同步模型</strong>。</li></ul></li><li><p>Data-Race-Free是同步模型中的一种，一个程序遵循Data-Race-Free同步模型，需要满足</p><ul><li>所有的同步操作都可以由硬件支持(recognized by hardware)。</li><li>在一个理想的系统上(内存操作都是原子的而且按程序顺序)，所有的<strong>有冲突的内存操作</strong>都具有happens-before关系。<ul><li>其中有冲突的内存操作是指：两个内存操作针对同一地址，其中至少有一个是写操作。</li><li>happens-before 更为具体的解释可以看<a href="https://zhuanlan.zhihu.com/p/433467241">这篇博客</a>.</li></ul></li></ul></li><li><p>在 RMO 模型下，使用FENCE、RMW等同步操作来确保DRF，那么程序也会呈现出顺序一致性(SC)的效果。</p></li><li><p>举例，如下表。</p><ul><li><p>两者区别在于上表中C2没有同步操作，而下表的C1和C2都通过添加FENCE指令和RMW加锁来实现同步操作。</p></li><li><p>上表中C2没有使用同步操作，所以C2的load操作可能会和C1的store操作同时进行，从而出现数据争用的情况。最后(r1,r2)的值可能会有四种情况。</p></li><li><p>下表中C2和C1使用的是同一个锁（L变量），那么C1的 Critical Section 只能在C2之前执行，或是C2的 Critical Section 只能在C1之前执行。</p><ul><li>所以下表的执行结果只能是(r1,r2)&#x3D;(0,0)&#x2F;(NEW,NEW).</li></ul><img src="3201119-20231011190906128-1149913925.png" style="zoom:50%;"/><img src="3201119-20231011190932117-1021057976.png" style="zoom:50%;"/></li></ul></li><li><p>一些定义</p><ul><li>内存操作可以分为两类，一类为<strong>同步操作</strong>(synchronization operations)，还有一类为<strong>数据操作</strong>（data operations）.<ul><li>其中同步操作包括锁的获取和释放，以及FENCE指令等。</li></ul></li><li>如果两个<strong>数据操作</strong>Di、Dj来自不同的核，访问相同的内存位置，且至少有一个数据操作是store，那么会发生<strong>冲突</strong>。</li><li>如果两个<strong>同步操作</strong>Si、Sj来自不同的核，访问相同的内存位置，且至少有一个同步操作是store，那么会发生<strong>冲突</strong>。</li></ul></li></ul><h4 id="2-4-5-Release-Consistency"><a href="#2-4-5-Release-Consistency" class="headerlink" title="2.4.5 Release Consistency"></a>2.4.5 Release Consistency</h4><ul><li>松散内存模型根据不同的设置可变形为多种。</li><li>上表中，对所有的同步操作都用FENCE指令来前后包围太过于浪费性能。<ul><li>实际上，只需要F12,F13和F22,F23。</li><li>其中F11\F14\F21\F24删除掉也没关系，C2的Critical Section和C1的Critical Section不会相互干扰。</li></ul></li></ul><h4 id="2-4-6-因果关系-写原子性"><a href="#2-4-6-因果关系-写原子性" class="headerlink" title="2.4.6 因果关系 &amp; 写原子性"></a>2.4.6 因果关系 &amp; 写原子性</h4><ul><li><p>下面介绍RMO的两个属性：因果关系和写原子性</p></li><li><p>因果关系（causality）</p><ul><li>如下图，L1可能发生在S1之前，但是由于B1-L1之间不断循环，直到满足条件才可以执行后续S2的store操作。C2和C3的关系与此类似。</li><li>如果L3操作中r3的值为NEW，那么因果关系成立。如果r3的值为0，那么因果关系被破坏。</li></ul><img src="3201119-20231024093214632-673248065.png" style="zoom:50%;"/>  </li><li><p>写原子性（write atomicity）</p><ul><li>一个core的Store操作可以立即被其它core看到。</li><li>前面介绍的<strong>XC模型</strong>，在定义上也是<strong>遵循写原子性的</strong>，可通过内存屏障指令指定在此指令之后store的数据从store buffer中读出到cache&#x2F;内存中，被其它core看见。</li><li>另外写原子性允许当前core的写操作可以先被当前core观察到，之后再被其它core观察到。类似于2.3.1节介绍的TSO例2.</li></ul></li><li><p>因果关系 &amp; 写原子性    </p><ul><li>写原子性可以保证正确处理IRIW (Independent Read Independent Write)。<ul><li><p>举例如下表格，假设<strong>不满足写原子性。</strong></p><ul><li>假设C1和C3是一个多线程core的两个线程上下文，它们共享一个store buffer。C2和C4也是如此。</li><li>如果不满足写原子性，那么C1执行S1操作时，此时C3只能看到S1操作的结果。同理，C4只能看到S2操作的结果。</li><li>此时r2和r4的值均为0。没有正确处理IRIW操作。</li></ul><img src="3201119-20231024094205072-307274823.png" style="zoom:50%;"/></li><li><p>正确处理IRIW不能保证写原子性。</p></li></ul></li></ul></li></ul><h3 id="2-5-RISC-V-Weak-Memory-Order-RVWMO"><a href="#2-5-RISC-V-Weak-Memory-Order-RVWMO" class="headerlink" title="2.5 RISC-V Weak Memory Order(RVWMO)"></a>2.5 RISC-V Weak Memory Order(RVWMO)</h3><ul><li><p>RVWMO 可以看成是RC和XC的混合体。</p><ul><li>RVWMO内存顺序与XC一致，并存在几种FENCE指令的变体。</li><li>RVWMO的load和store操作可以携带一些属性，与RC一致。<ul><li>其中load指令可以携带ACQUIRE，存储指令可以携带RELEASE。RMW指令可以携带Release&#x2F;Acquire或者两者同时。     </li><li>ACQUIRE在RVWMO中分为ACQUIRE-RC_PC和ACQUIRE-RC_SC，RELEASE分为RELEASE-RC_PC和RELEASE-RC_SC。load&#x2F;store可以携带任意一种ACQURE&#x2F;RELEASE，RMW只能选择RC_SC。</li><li>其中PC为Processor Consistency，而SC为Sequential Consistency。</li></ul></li></ul></li><li><p>FENCE 指令</p><ul><li><p>fence 指令格式如下。</p><ul><li>其中两个参数分别为predecessor和successor。前者指示fence指令前的操作，后者指示fence指令后的操作。</li><li>参数指示栅栏对哪种类型的访问进行排序，这些类型可以是：内存读取（r）、内存写入（w）、设备输入（i）以及设备输出（o）。</li></ul><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">fence</span> pred<span class="hljs-punctuation">,</span> succ    <br></code></pre></td></tr></table></figure></li><li><p>XC中的FENCE指令为fence rw,rw.即保证fence之后所有的load&#x2F;store操作都不会出现在fence之前的load&#x2F;store操作之前。</p></li><li><p>除此之外，还有五种组合，包括</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">fence</span> rw<span class="hljs-punctuation">,</span>w<span class="hljs-comment">;</span><br><span class="hljs-keyword">fence</span> r<span class="hljs-punctuation">,</span>rw<span class="hljs-comment">;</span><br><span class="hljs-keyword">fence</span> r<span class="hljs-punctuation">,</span>r<span class="hljs-comment">;</span><br><span class="hljs-keyword">fence</span> w<span class="hljs-punctuation">,</span>w<span class="hljs-comment">;</span><br><span class="hljs-keyword">fence</span>.tso<br># 其中<span class="hljs-keyword">fence</span>.tso指令是<span class="hljs-keyword">fence</span>的变种，相当于<span class="hljs-keyword">fence</span> rw<span class="hljs-punctuation">,</span>rw<span class="hljs-comment">; 除去store load之间的约束，允许store-load重排序。</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>语法依赖</p><ul><li><p>RVWMO在某些方面约束要比XC要强，例如：地址、数据或控制依赖可以约束RVWMO中的内存顺序。 </p></li><li><p>参考<a href="https://gitee.com/laokz/OS-kernel-test/blob/master/memorder/riscv.md">这篇文章</a>，语法依赖可以认为是一条指令的源操作数与前面指令（不一定相邻）的目的操作数是同一个寄存器；因此必须前面指令执行结束后才可以进行后续指令。</p><ul><li>注意<ul><li>（1）是否存在语法依赖看寄存器名，而不是值。</li><li>（2）并不是所有指令都有目的操作数；所以没有指令会依赖这种指令。</li><li>（3）x0寄存器不构成任何依赖；因为它的值是固定的、已知的。</li><li>（4）语法依赖具有传递性，例如：B依赖A，C依赖B，那么C依赖A。即全局内存操作顺序A必在C之前。 <ul><li><p>举例如下，其中b依赖于a，而c依赖于b，d依赖于c。因此，尽管a和d并不相关，但也被强制的制定了执行顺序。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">(a) ld <span class="hljs-built_in">a1</span>,<span class="hljs-number">0</span>(<span class="hljs-built_in">s0</span>)<br>(<span class="hljs-keyword">b) </span><span class="hljs-keyword">xor </span><span class="hljs-built_in">a2</span>,<span class="hljs-built_in">a1</span>,<span class="hljs-built_in">a1</span><br>(c) <span class="hljs-keyword">add </span><span class="hljs-built_in">s1</span>,<span class="hljs-built_in">s1</span>,<span class="hljs-built_in">a2</span><br>(d) ld <span class="hljs-built_in">a5</span>,<span class="hljs-number">0</span>(<span class="hljs-built_in">s1</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>语法依赖按照寄存器的用途分为三类，并都需要保证正确的执行顺序。</p><ul><li><p>地址依赖：前一条指令的目的寄存器结果是后面访存指令的操作地址，用法类似于指针。如下图所示。</p><img src="3201119-20231024150824221-1929559695.png" style="zoom:50%;"/></li><li><p>数据依赖：前一条指令的目的寄存器结果是后面指令的操作数。如下图所示。</p><img src="3201119-20231024150848949-1465640225.png" style="zoom:50%;"/></li><li><p>控制依赖：两条指令之间存在一个依赖于第一条指令的<strong>分支&#x2F;间接跳转指令</strong>，判断语句依赖于前面指令的目的寄存器结果。条件语句对后续的所有指令构成控制依赖。但在RVWMO模型中，仅保证后续的store指令有序。</p><ul><li>如下图所示，需保证顺序L1-B1-S1。</li></ul><img src="3201119-20231024150912913-1898672627.png" style="zoom:50%;"/></li></ul></li><li><p>除了前面介绍的三种语法依赖，RISC-V还存在流水线依赖。举例如下。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">       代码<span class="hljs-number">1</span>         代码<span class="hljs-number">2</span>          代码<span class="hljs-number">3</span>          代码<span class="hljs-number">4</span><br>-------------------------------------------------------------<br>(a) <span class="hljs-keyword">lw </span><span class="hljs-built_in">t0</span>, (<span class="hljs-built_in">s0</span>)   <span class="hljs-keyword">lw </span><span class="hljs-built_in">t0</span>, (<span class="hljs-built_in">s0</span>)   <span class="hljs-keyword">lw, </span><span class="hljs-built_in">t0</span>, (<span class="hljs-built_in">s0</span>)   <span class="hljs-keyword">lw, </span><span class="hljs-built_in">t0</span>, (<span class="hljs-built_in">s0</span>)<br>(<span class="hljs-keyword">b) </span><span class="hljs-keyword">sw </span><span class="hljs-built_in">t1</span>, (<span class="hljs-built_in">t0</span>)   <span class="hljs-keyword">sw </span><span class="hljs-built_in">t0</span>, (<span class="hljs-built_in">t1</span>)   <span class="hljs-keyword">sw, </span><span class="hljs-built_in">t1</span>, (<span class="hljs-built_in">t0</span>)   <span class="hljs-keyword">lw, </span><span class="hljs-built_in">t1</span>, (<span class="hljs-built_in">t0</span>)<br>(c) <span class="hljs-keyword">lw </span><span class="hljs-built_in">t2</span>, (<span class="hljs-built_in">t0</span>)   <span class="hljs-keyword">lw </span><span class="hljs-built_in">t2</span>, (<span class="hljs-built_in">t1</span>)   <span class="hljs-keyword">sw, </span><span class="hljs-built_in">t2</span>, (<span class="hljs-built_in">s1</span>)   <span class="hljs-keyword">sw, </span><span class="hljs-built_in">t2</span>, (<span class="hljs-built_in">s1</span>)<br></code></pre></td></tr></table></figure><ul><li>上面描述的4段代码，都是前两条指令构成语法依赖。</li><li>代码1和代码2约束点为：<strong>在store地址或者值未知时，不能load这个store的值。</strong>因此(b) store操作的值或地址不能确定时，不能执行(c).又因为(b)依赖于(a)，所以(c)依赖于(a)。</li><li>代码3和代码4约束点为：<strong>前面的load&#x2F;store地址未知时不能进行store。</strong>因为对于同一地址，不可发生写超前。<ul><li>例如将写操作提前进行，前一条指令操作（写&#x2F;读）也是针对同一地址，那么可能会发生写错旧值覆盖新值&#x2F;读新值覆盖读旧值。因此(b)地址未确定时，(c)不能执行。而(b)依赖于(a)，所以(c)不能超前于(a)。</li></ul></li></ul></li></ul></li><li><p>对同一地址的约束</p><ul><li>对于同一地址，要求满足load-store，store-store顺序，可以进行store-load 以及 load-load重排序。除此之外，还需要满足下面的要求：<ul><li>（1）写不超前<ul><li>针对同一地址，store指令不可以超前于前面一条的指令。与上面介绍的代码3和代码4约束点的解释一致。（也就是上面需要满足的load-store，store-store顺序）</li></ul></li><li>（2）读CoRR(Coherence for Read-Read pairs)<ul><li>对于同一个地址的两个读，只要后一个load不会得到相较于前一个load更旧的值，就可以<strong>不约束</strong>两者的内存顺序。</li></ul></li><li>（3）原子操作<ul><li>因为原子指令中会存在store操作<ul><li>当store位于程序顺序后面时不会超前到前面指令。</li><li>当store位于程序顺序前面时，如果后面是store操作时，也不可超前；如果后面操作是load时，规定也不可以乱序，为了保证原子指令的操作语义。</li></ul></li></ul></li></ul></li><li><h2 id="举例1-下面代码中，如果想要产生outcome输出，那么需要满足：-（d）这里被插入bubble，可能是为了等待其它指令执行完成。（为什么插入bubble，并且在-d-处结束不理解）-（e）执行sw操作，将写入数据t2写入store-buffer中。-（f）执行lw操作，并从store-buffer中读出对应地址的数据，即a1-t2-2-（g）执行异或运算得到t3-0-（h）执行加法运算得到s0-s0-（i）执行lw操作，将s0地址处数据load出来，此时未有写入数据，所以a2-0-（a）执行sw操作，写入core0对应的store-buffer中，再获得其它core返回的invalid回执之后再写入cache-内存中。-（c）执行sw操作，与上面（a）相同，将数据t1写入内存地址为s1处。-（d）bubble结束，开始执行lw操作，load对应地址的数据，即a0-t1-1-若考虑可能发生的内存重排序，那么过程为：-内存操作顺序应为：f-i-a-c-d-e-考虑到写不超前，（d）和（e）的顺序不可发生变化。（i）应在（a）前面。-考虑到fence指令，（a）应在（c）前面。-考虑到CoRR，（f）和（d）之间存在对同一个地址的sw语句（e），因此允许（f）在内存顺序上超前于（d）。-因为流水线结构，即使（f）排序到（e）前面，但仍可以在load时从前面的sw操作获取数据直接给到（f），所以load也不会出错。-Hart-0-Hart-1"><a href="#举例1-下面代码中，如果想要产生outcome输出，那么需要满足：-（d）这里被插入bubble，可能是为了等待其它指令执行完成。（为什么插入bubble，并且在-d-处结束不理解）-（e）执行sw操作，将写入数据t2写入store-buffer中。-（f）执行lw操作，并从store-buffer中读出对应地址的数据，即a1-t2-2-（g）执行异或运算得到t3-0-（h）执行加法运算得到s0-s0-（i）执行lw操作，将s0地址处数据load出来，此时未有写入数据，所以a2-0-（a）执行sw操作，写入core0对应的store-buffer中，再获得其它core返回的invalid回执之后再写入cache-内存中。-（c）执行sw操作，与上面（a）相同，将数据t1写入内存地址为s1处。-（d）bubble结束，开始执行lw操作，load对应地址的数据，即a0-t1-1-若考虑可能发生的内存重排序，那么过程为：-内存操作顺序应为：f-i-a-c-d-e-考虑到写不超前，（d）和（e）的顺序不可发生变化。（i）应在（a）前面。-考虑到fence指令，（a）应在（c）前面。-考虑到CoRR，（f）和（d）之间存在对同一个地址的sw语句（e），因此允许（f）在内存顺序上超前于（d）。-因为流水线结构，即使（f）排序到（e）前面，但仍可以在load时从前面的sw操作获取数据直接给到（f），所以load也不会出错。-Hart-0-Hart-1" class="headerlink" title="举例1- 下面代码中，如果想要产生outcome输出，那么需要满足：  - （d）这里被插入bubble，可能是为了等待其它指令执行完成。（为什么插入bubble，并且在(d)处结束不理解）  - （e）执行sw操作，将写入数据t2写入store buffer中。  - （f）执行lw操作，并从store buffer中读出对应地址的数据，即a1&#x3D;t2&#x3D;2.  - （g）执行异或运算得到t3&#x3D;0.  - （h）执行加法运算得到s0&#x3D;s0.  - （i）执行lw操作，将s0地址处数据load出来，此时未有写入数据，所以a2&#x3D;0.  - （a）执行sw操作，写入core0对应的store buffer中，再获得其它core返回的invalid回执之后再写入cache&#x2F;内存中。  - （c）执行sw操作，与上面（a）相同，将数据t1写入内存地址为s1处。  - （d）bubble结束，开始执行lw操作，load对应地址的数据，即a0&#x3D;t1&#x3D;1.- 若考虑可能发生的内存重排序，那么过程为：  - 内存操作顺序应为：f-i-a-c-d-e    - 考虑到写不超前，（d）和（e）的顺序不可发生变化。（i）应在（a）前面。    - 考虑到fence指令，（a）应在（c）前面。    - 考虑到CoRR，（f）和（d）之间存在对同一个地址的sw语句（e），因此允许（f）在内存顺序上超前于（d）。      - 因为流水线结构，即使（f）排序到（e）前面，但仍可以在load时从前面的sw操作获取数据直接给到（f），所以load也不会出错。  &#96;&#96;&#96;      Hart 0            Hart 1"></a>举例1<br>- 下面代码中，如果想要产生outcome输出，那么需要满足：<br>  - （d）这里被插入bubble，可能是为了等待其它指令执行完成。（为什么插入bubble，并且在(d)处结束不理解）<br>  - （e）执行sw操作，将写入数据t2写入store buffer中。<br>  - （f）执行lw操作，并从store buffer中读出对应地址的数据，即<strong>a1&#x3D;t2&#x3D;2</strong>.<br>  - （g）执行异或运算得到t3&#x3D;0.<br>  - （h）执行加法运算得到s0&#x3D;s0.<br>  - （i）执行lw操作，将s0地址处数据load出来，此时未有写入数据，所以<strong>a2&#x3D;0.</strong><br>  - （a）执行sw操作，写入core0对应的store buffer中，再获得其它core返回的invalid回执之后再写入cache&#x2F;内存中。<br>  - （c）执行sw操作，与上面（a）相同，将数据t1写入内存地址为s1处。<br>  - （d）bubble结束，开始执行lw操作，load对应地址的数据，即<strong>a0&#x3D;t1&#x3D;1</strong>.<br>- 若考虑可能发生的内存重排序，那么过程为：<br>  - <strong>内存操作顺序</strong>应为：<strong>f-i-a-c-d-e</strong><br>    - 考虑到写不超前，（d）和（e）的顺序不可发生变化。（i）应在（a）前面。<br>    - 考虑到fence指令，（a）应在（c）前面。<br>    - 考虑到CoRR，（f）和（d）之间存在对同一个地址的sw语句（e），因此允许（f）在内存顺序上超前于（d）。<br>      - 因为流水线结构，即使（f）排序到（e）前面，但仍可以在load时从前面的sw操作获取数据直接给到（f），所以load也不会出错。<br><br>  &#96;&#96;&#96;<br>      Hart 0            Hart 1</h2><pre><code class="hljs">  li t1, 1          li t2, 2</code></pre>  (a) sw t1,0(s0)   (d) lw a0,0(s1)<br>  (b) fence w, w    (e) sw t2,0(s1)<br>  (c) sw t1,0(s1)   (f) lw a1,0(s1)<br>                (g) xor t3,a1,a1<br>                (h) add s0,s0,t3<br>                (i) lw a2,0(s0)<br>  Outcome: a0&#x3D;1, a1&#x3D;2, a2&#x3D;0（允许）<pre><code class="hljs"></code></pre></li></ul></li></ul><h3 id="2-6-Consistency-Coherence"><a href="#2-6-Consistency-Coherence" class="headerlink" title="2.6 Consistency &amp;  Coherence"></a>2.6 Consistency &amp;  Coherence</h3><ul><li>Coherence问题：<ul><li>当一份数据有多份拷贝时，可能会发生coherent问题。</li><li>对于单核，数据可能会同时出现在cache和主存中，此时会发生coherent问题。</li><li>对于多核，数据可能会在多个core的cache中或是在主存中，此时也容易发生coherent问题。</li></ul></li><li>Cosistent问题：<ul><li>当一块内存区域被多个Master进行读写时，可能会出现cosistent问题。</li><li>需要保证多个master读写顺序，以及对cache进行性能优化时可能会导致的重排序也可能引起cosistent问题。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
      <category>内存相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈 - 堆</title>
    <link href="/2023/11/01/%E6%A0%88%20&amp;%20%E5%A0%86/"/>
    <url>/2023/11/01/%E6%A0%88%20&amp;%20%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/qq_52505851/category_12399093.html">https://blog.csdn.net/qq_52505851/category_12399093.html</a></li><li><a href="https://blog.csdn.net/hanlin1985/article/details/3132210">https://blog.csdn.net/hanlin1985/article/details/3132210</a></li><li><a href="https://www.cnblogs.com/wahahahehehe/p/15164437.html">https://www.cnblogs.com/wahahahehehe/p/15164437.html</a></li><li><a href="https://www.cnblogs.com/lesroad/p/10389971.html">https://www.cnblogs.com/lesroad/p/10389971.html</a></li></ul></li></ul><hr><h2 id="1-栈-寄存器"><a href="#1-栈-寄存器" class="headerlink" title="1. 栈 &amp; 寄存器"></a>1. 栈 &amp; 寄存器</h2><ul><li><p>栈的用处</p><ul><li>（1）RISC-V 划分了x10-x17八个寄存器为参数寄存器，用于传递参数或返回值。考虑到如果参数&#x2F;局部变量很多，8个寄存器放不下，那么需要开辟栈空间存储。</li><li>（2）用于保护和恢复函数调用过程中的相关信息，如返回地址、上下文寄存器信息等。这些信息可以帮助函数（中断）在执行完毕后返回到正确的位置。</li></ul></li><li><p>栈：后进先出（LIFO），栈指针指向栈的顶部，从高地址向低地址，为压栈过程，存入数据；从低地址向高地址，为弹栈过程，取出数据。</p><ul><li>下面代码中，由于diffofsums()函数，出现无条件跳转指令。当参数寄存器足以使用，那么不需要开辟栈空间。</li></ul><p><img src="/2023/11/01/%E6%A0%88%20&%20%E5%A0%86/3201119-20230906220555789-544830672.png"></p><ul><li>如果参数寄存器不足以使用，可以将参数先压入栈中，需要使用时再从栈中取出。临时寄存器在<strong>使用之后</strong>不需要弹栈恢复。</li><li>如果为了避免函数调用修改掉主寄存器中的内容，可以通过下面步骤实现。<ul><li>在栈上分配空间存储对应数目的寄存器值。</li><li>将寄存器s3,t0,t1的值存到栈上，等待函数运算结束之后，再从栈中取出恢复寄存器旧值。</li><li>使用寄存器进行相对应的运算。</li><li>将运算后的结果给到调用者层的寄存器a0。</li><li>将栈中的其它值弹出，恢复寄存器s3,t0,t1的旧值。</li><li>释放栈空间。</li></ul></li></ul><p><img src="/2023/11/01/%E6%A0%88%20&%20%E5%A0%86/3201119-20230906222236489-589165970.png"></p><ul><li>每个函数有自己的栈空间，也只能访问自己的栈。</li></ul></li><li><p>为了减少压栈和栈弹出的次数，RISC-V将19个寄存器分为了两组：</p><ul><li>临时寄存器：调用者不会再使用他们，所以不需要被保存和恢复（压栈&#x2F;弹栈）。如上面代码中的t0，t1.（x5-x7,x28-x31）</li><li>保存寄存器：希望在调用前后需要保持相同值的寄存器，需要压栈&#x2F;弹栈。如上面代码中的s3，在调用函数之后需要其仍未调用前的旧值.（x8-x9,x18-x27）</li></ul><p><img src="/2023/11/01/%E6%A0%88%20&%20%E5%A0%86/3201119-20230906232325563-433575287.png"></p></li><li><p>嵌套过程</p><ul><li>非叶函数：是指调用了其它函数或者改变非易失性寄存器的函数。  <ul><li>非易失性寄存器：在断电后仍能保持内容不变的寄存器，常用于保存一些重要的数据或状态，如程序计数器、栈指针、返回地址等。</li><li>易失性寄存器：在断电后，会丢失其内容的寄存器，常用于保存一些临时的数据或操作数，例如通用寄存器、浮点寄存器、向量寄存器等。</li><li>一般来说，被调用函数需要保护（压栈&#x2F;弹栈）非易失性寄存器的值。而被调函数可以自由的使用易失性寄存器的值，不需要保存&#x2F;恢复它们的值。</li></ul></li><li>在非叶函数调用时，遵循下面两条规则：<ul><li>调用者保存规则：调用者需要将所有调用后还需要的参数存储器或临时存储器压栈保存。</li><li>被调用者保存规则：被调用者将返回地址寄存器x1和被调用者使用的保存寄存器压栈。</li></ul></li><li>代码示例如下所示。</li></ul><p><img src="/2023/11/01/%E6%A0%88%20&%20%E5%A0%86/3201119-20230907111834366-1859723362.png"></p></li></ul><h2 id="2-堆"><a href="#2-堆" class="headerlink" title="2. 堆"></a>2. 堆</h2><ul><li>堆和栈的区别<ul><li>栈：后进先出（LIFO），由编译器自动分配和释放。使用一级缓存，调用完立即释放。</li><li>堆：可对任意位置进行操作，通常由程序员手动分配，使用完需及时释放(free)，不然容易造成内存泄漏。 </li><li>更为详细的介绍可以看<a href="https://blog.csdn.net/hanlin1985/article/details/3132210">这篇博客</a>。</li></ul></li><li>下图为Linux操作系统下RISC-V分配内存的规定。<ul><li>栈从用户地址空间的<strong>高端向下生长</strong>。<ul><li>函数内局部变量的存储单元都可以在栈上创建，并在函数执行结束时这些存储单元自动被释放。</li><li>栈内存分配运算<strong>内置于处理器的指令集</strong>中，效率很高，但是分配的内存容量有限。</li></ul></li><li>内存的低端是保留的，再往上是RISC-V的机器代码，称为代码段。</li><li>再往上是静态数据段，用于存放静态数据、全局数据和常量。</li><li>再往上就是堆<ul><li>对于链表这类数据结构，往往随着生命周期增长或缩短，存放在堆内。</li><li>关于数组是存放在栈&#x2F;堆&#x2F;静态数据段，主要看是如何声明的。<ul><li>如果是程序员 new malloc， 则是存放在堆中的。</li></ul></li></ul></li><li>堆和栈是相向生长，随着两个段的此消彼长达到内存的高效使用。</li></ul></li></ul><img src="3201119-20230918160341670-703117698.png" style="zoom:33%;" /><ul><li>程序员可以通过显示函数调用来分配(malloc)和释放(free)堆上的空间。<ul><li>如果忘记释放空间，可能会导致内存泄漏，最终耗尽大量内存。</li><li>如果过早释放空间，可能会导致悬空指针，导致指针指向错误的位置。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V 指令</title>
    <link href="/2023/11/01/RISC-V%20%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/11/01/RISC-V%20%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li>《计算机组成与设计 第五版》</li><li>《RISC-V-Reader-Chinese-v2p1》（包云岗老师）</li><li>《手把手教你设计CPU RISC-V处理器》</li><li><a href="https://blog.csdn.net/qq_38915354/article/details/115696721">https://blog.csdn.net/qq_38915354/article/details/115696721</a></li><li><a href="https://zhuanlan.zhihu.com/p/374235855">https://zhuanlan.zhihu.com/p/374235855</a></li><li><a href="https://blog.csdn.net/weixin_46623752/article/details/125770550">https://blog.csdn.net/weixin_46623752/article/details/125770550</a></li><li><a href="https://blog.csdn.net/sucaiwa/article/details/129328891">https://blog.csdn.net/sucaiwa/article/details/129328891</a></li></ul></li></ul><hr><h2 id="1-寄存器相关"><a href="#1-寄存器相关" class="headerlink" title="1. 寄存器相关"></a>1. 寄存器相关</h2><ul><li>RISC-V 架构可选32bit（RV32）&#x2F;64bit(RV64)，可选32个寄存器（I架构）&#x2F;16个寄存器（E架构）。 <ul><li>考虑<strong>整数通用寄存器组</strong>：其中0寄存器被预留为常数0，其余31&#x2F;15个寄存器为通用整数寄存器。 </li><li>考虑<strong>浮点寄存器组</strong>（一般为F&#x2F;D类扩展指令集），有32个通用浮点寄存器；寄存器位宽由扩展指令集类型决定，F类：单精度、32bit，D类：双精度、64bit。</li></ul></li><li>RISC-V 的汇编语言是对寄存器的数据进行处理。<ul><li>算术运算（加、减、立即数加）。</li><li>数据传输（取：从存储器取数据到寄存器；存：从寄存器读数据存到存储器，更多关于存储器访问指令下面有介绍）。</li><li>逻辑运算（与，或，异或…）。</li><li>移位操作（逻辑左&#x2F;右移，算数左&#x2F;右移）。</li><li>条件分支（相等、不等、大于、小于跳转）。</li><li>无条件跳转（跳转 - 链接）。</li></ul></li><li>存储器访问指令<ul><li>对于更复杂的数据结构（例如数组和结构体）包含比寄存器更多的数据元素，只能存放于存储器中，使用数据传输指令进行读取。</li><li>与RISC架构策略一致，只有Load和Store指令可以访问存储器，其它指令都不可访问存储器。</li><li>存储器读写指令基本单位是<strong>字节（Byte）</strong>。</li><li>RISC-V架构存储模式只支持小端格式。</li><li>RISC-V推荐使用地址对齐的存储器读写操作，但也支持地址非对齐。</li><li>RISC-V架构的考虑硬件架构复杂度，<strong>不支持读写指令下存储地址自增&#x2F;自减的模式。</strong></li></ul></li></ul><h2 id="2-RV32I-指令格式"><a href="#2-RV32I-指令格式" class="headerlink" title="2. RV32I 指令格式"></a>2. RV32I 指令格式</h2><ul><li>下图介绍了六种基本指令格式</li></ul><img src="3201119-20230702170812050-2086168818.png" width = 60%/><ul><li>R-type<ul><li>实现rs1，rs2两个寄存器的值运算，并将运算后的结果存在rd中。opcode 和 func 共同决定实现哪种运算。</li></ul></li><li>I-type<ul><li>可以实现带一个常数的算数指令以及Load指令。 注意immediate字段为补码值。  </li><li>对于Load指令：可以取相对于rd中的基地址+imm字节的数据。<ul><li>例如下面的指令，从x22寄存器中获取基地址，并加上偏移地址（64&#x2F;8bit &#x3D; 8Byte） ，取出字，放到x9寄存器中。<ul><li>其中(x)22放在rs1寄存器中，(x)9放在rd字段，64放在imm字段。<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">lw</span> <span class="hljs-built_in">x9</span>, <span class="hljs-number">64</span>(<span class="hljs-built_in">x22</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li>考虑到逻辑操作中的<strong>移位</strong>，使用的也是I型指令格式，考虑到寄存器位宽为32bit，所以shamt也不会超过32，所以imm只需要划出5bit空间，其余几bit作为额外的操作码字段。</li></ul></li><li>S-type<ul><li>用于Store指令，immediate字段仍为补码值。</li><li>存在两个源寄存器，一个存放基址，一个存放数据。</li><li>设计选择与R-type保持类似的指令格式，将imm进行拆分，可以一定程度降低硬件的复杂性。<ul><li>例如下面的指令，x9中写着要存入的值，x10中写着存储器基地址，并加上偏移地址（240&#x2F;8bit &#x3D; 30Byte）。<ul><li>其中(x)9放在rs2字段中，(x)10放在rs1字段中，240放在imm字段中（要被拆分）。<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">sw</span> <span class="hljs-built_in">x9</span>, <span class="hljs-number">240</span>(<span class="hljs-built_in">x10</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li>U-type<ul><li>I、S型指令格式中已经有12bit imm，但是需要考虑有时常数很大，12bit不够，此时可以使用LUI指令。<ul><li>将高20bit常数加载到寄存器的第31-12bit，低12bit用常数0填充。之后可以使用 addi 指令与低12bit立即数相加，以实现对32bit寄存器数值的配置。</li><li>需要注意：ADDI指令处理的立即数为有符号数，使用ADDI指令加上低12bit时，如果12bit最高位为1，那么做的是减法而不是加法。<ul><li>此时需要进行补值，对于 ADDI 的12bit最高位为1的情况，加上2^12即可。相关处理可以看<a href="https://zhuanlan.zhihu.com/p/374235855">这篇文章</a>。</li></ul></li></ul></li></ul></li><li>B-type<ul><li><p>比较两个源寄存器rs1和rs2，并进行跳转。</p></li><li><p>例子如下：</p><ul><li>指令格式上可以看到imm[0]被舍弃掉了，因为该bit被设置为0；汇编器根据label的地址计算出相对当前PC值的偏移量为16bytes &#x3D; ‘b1_0000，映射如下图。<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">beq</span> <span class="hljs-built_in">x19</span>, <span class="hljs-built_in">x10</span>, label<br></code></pre></td></tr></table></figure><img src="3201119-20230702221434146-1599458281.png" width = 60%/></li></ul></li><li><p>看到这里，其实就会有一个疑问，为什么B型和J型立即数在inst中分散的奇奇怪怪，但是寄存器却是固定位置的，知乎上搜到了这个问题的一些<a href="https://www.zhihu.com/question/405003253">回答</a>。我认为其中有一个解释的很有道理，为了平衡（寄存器索引到读出寄存器值的时间）和（通过inst生成参与操作的立即数选择逻辑的时间），提高整体的运算速度。</p></li></ul></li><li>J-type<ul><li>主要用在无条件跳转指令jal和jalr上。<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">jal <span class="hljs-built_in">rd</span>, <span class="hljs-built_in">label</span><br>jalr <span class="hljs-built_in">rd</span>, rsl, imm<br></code></pre></td></tr></table></figure></li><li>jal <ul><li>主要实现两步：<ul><li>J-type和前面介绍的B-type一样，舍弃掉imm[0]，强制设置该bit为0；将imm偏移量加到该指令的PC值，得到最终跳转目标地址。RV32I的J指令格式中imm有21bit，但是imm[0]被舍弃掉了，因此可以跳转±2^(21-1) &#x3D; ±1MB，其中21-1是因为有1bit的符号位。  </li><li>并且将下一条指令的PC（当前指令PC值+4）写入寄存器rd中。+4是因为对于RV32I来说，其指令长度为4个字节，且使用字节寻址。将下一条地址写入寄存器中，是为返回做准备。</li></ul></li></ul></li><li>jalr<ul><li><p>！！<strong>注意，jalr不是J型指令格式而是I型指令格式。</strong></p></li><li><p>imm的12bit立即数为偏移量，基地址保存在rs1中，两者相加为最终跳转的目标地址。只能跳转±2KB（2^11&#x3D;2KB，去掉符号位）。</p></li><li><p>jalr也需要将下一条指令的PC值写入rd寄存器中。</p><img src="3201119-20230702233922982-373352789.png" width = 60%/></li></ul></li></ul></li></ul><h2 id="3-RISC-V-寻址模式"><a href="#3-RISC-V-寻址模式" class="headerlink" title="3. RISC-V 寻址模式"></a>3. RISC-V 寻址模式</h2><ul><li>PC 相对寻址<ul><li>前面介绍的B型和J型都是分支跳转指令；前者的寻址范围为基于当前PC值 -4096~4096，后者的寻址范围为基于当前PC值 -2^(20) ~ 2^(20).</li></ul></li><li>基址寻址<ul><li>如S型指令。</li></ul></li><li>寄存器寻址<ul><li>如R型指令。</li></ul></li><li>立即数寻址<ul><li>如I型指令。</li></ul></li></ul><img src="3201119-20230921162921388-1215879610.png" width = 60%/><h2 id="4-RISC-V-原子指令"><a href="#4-RISC-V-原子指令" class="headerlink" title="4. RISC-V 原子指令"></a>4. RISC-V 原子指令</h2><ul><li>对于单处理器，任务之间的同步机制可以通过<strong>加锁和解锁</strong>实现。</li><li>对于多处理器有以下方法。</li></ul><h3 id="4-1-硬件原语"><a href="#4-1-硬件原语" class="headerlink" title="4.1 硬件原语"></a>4.1 硬件原语</h3><ul><li>通过一组硬件原语（例如CAS、TAS、TTAS、FAA），实现在进行内存单元读取和写入之间不能插入其他操作。<ul><li>程序员需要使用一些基本的硬件原语来构建同步原语库。原语相关的解释可以看<a href="https://baike.baidu.com/item/%E5%8E%9F%E8%AF%AD">这篇文章</a>，其主要特点为在执行过程中不可被中断。</li><li>考虑到使用单条同步原语对处理器的设计要求较高，因为需要在单条不可中断的指令中完成存储器的读和写操作。</li></ul></li></ul><h3 id="4-2-原子指令"><a href="#4-2-原子指令" class="headerlink" title="4.2 原子指令"></a>4.2 原子指令</h3><h4 id="4-2-1-lr-sc"><a href="#4-2-1-lr-sc" class="headerlink" title="4.2.1 lr&#x2F;sc"></a>4.2.1 lr&#x2F;sc</h4><ul><li><p>使用指令对，第二条指令返回一个值，该值表示指令对是否被原子执行。没有<strong>其他处理器</strong>在该指令对之间执行，则可认为是完成原子操作。</p><ul><li>在RISC-V中，该指令对为lr(load reserved)和sc(store conditional).</li></ul></li><li><p>lr指令格式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lr.&#123;w/d&#125;.&#123;aq/rl&#125; rd, (rs1)<br></code></pre></td></tr></table></figure><ul><li>其中w&#x2F;d分别对应为word（32bits）和double word（64bits）。</li><li>其中aq&#x2F;rl分别对应为acquire&#x2F;release。lr和sc可以通过这两个后缀添加额外的内存访问顺序限制。具体会在内存访问相关内容的<a href="https://www.cnblogs.com/qianbinbin/p/17723730.html">博客</a>中进行介绍。<ul><li>注意：成功的sc才代表这个原子指令的执行，失败的sc不产生任何内存操作，自然也不会对内存访问顺序的约束产生任何影响。</li></ul></li><li>其中{}中的内容不是必须填写的，编译器能够根据当前的运行环境自动进行设置。</li></ul></li><li><p>sc指令格式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sc.&#123;w/d&#125;.&#123;aq/rl&#125; rd, rs2, (rs1)<br></code></pre></td></tr></table></figure><ul><li>与lr指令参数含义相同。</li></ul></li><li><p>lr&#x2F;sc 指令伪代码描述</p><ul><li><p>第2行，从rs1地址处取数据加载到rd寄存器中。</p></li><li><p>第3行，在rs1内存地址上设置保留标记(reservation set)。</p></li><li><p>第5行，在将rs2寄存器的数据写到rs1地址之前，会首先检查rs1内存地址是否有设置保留标记。</p><ul><li>如果有，那么将rs2寄存器的数据写入rs1内存地址中；并将rd寄存器的值设置为0.表示保存成功。</li><li>如果没有，则不完成保存rs2寄存器数据到rs1内存地址的过程，并向rd寄存器写入一个非零值，表示保存失败。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//lr指令</span><br>rd = [rs1]<br>reservation_set(cur_hart)<br><span class="hljs-comment">//sc指令</span><br><span class="hljs-keyword">if</span> (is_reserved(rs1)) &#123;<br>    *rs1 = rs2<br>    rd = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span><br>    rd = <span class="hljs-number">1</span><br>clean_reservation_set(cur_hart)<br></code></pre></td></tr></table></figure></li><li><p>根据上面的描述，我们发现sc指令并不是一定会执行成功，需要满足下面几个条件：</p><ul><li>（1）lr&#x2F;sc指令需要访问相同的地址。</li><li>（2）lr和sc指令之间没有其它的写操作访问同样的地址。</li><li>（3）lr和sc指令之间没有任何的中断和异常发生。</li><li>（4）lr和sc指令之间没有执行mret指令。<ul><li>其中mret指令可用作机器模式转换为用户模式。更多信息可在网上检索。</li></ul></li></ul></li></ul></li><li><p>lr&#x2F;sc 示例</p>  <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">again:</span> <span class="hljs-built_in">lr</span>.d <span class="hljs-built_in">x10</span>,(<span class="hljs-built_in">x20</span>)  <span class="hljs-comment">//将x20寄存器指向内存地址的值load到x10寄存器中</span><br><span class="hljs-symbol">sc.d</span> <span class="hljs-built_in">x11</span>,<span class="hljs-built_in">x23</span>,(<span class="hljs-built_in">x20</span>)   <br><span class="hljs-comment">//首先检查x20寄存器指向内存地址的空间是否有保留标志，有，将x23寄存器的值store到x20指向的内存空间。并设置x11寄存器值为0.</span><br><span class="hljs-keyword">bne</span> <span class="hljs-built_in">x11</span>，<span class="hljs-built_in">x0</span>,again   <span class="hljs-comment">//如果x11寄存器中的值不为0，则跳回again</span><br><span class="hljs-symbol">addi</span> <span class="hljs-built_in">x23</span>,<span class="hljs-built_in">x10</span>,<span class="hljs-number">0</span>      <span class="hljs-comment">//完成x23寄存器的值和x20寄存器指向的内存地址的值的原子交换</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="4-2-2-AMO（Atomic-Memory-Operation）"><a href="#4-2-2-AMO（Atomic-Memory-Operation）" class="headerlink" title="4.2.2 AMO（Atomic Memory Operation）"></a>4.2.2 AMO（Atomic Memory Operation）</h4><ul><li><p>使用前面介绍的lr&#x2F;sc指令可以进行加解锁，执行原子操作。但这种实现起来较为复杂，尤其对于单变量的原子操作，使用这种方式的代价很大。</p></li><li><p>AMO即原子内存操作，AMO又分为几类，包括：<strong>原子交换指令、原子加法指令、原子逻辑指令和原子取大小值指令。</strong></p></li><li><p>（1）原子交换指令</p><ul><li><p>amoswap 指令格式如下所示</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">amoswap.</span><span class="hljs-template-variable">&#123;w/d&#125;</span><span class="language-xml">.</span><span class="hljs-template-variable">&#123;aqrl&#125;</span><span class="language-xml"> rd,rs2,(rs1)</span><br></code></pre></td></tr></table></figure></li><li><p>其伪代码如下所示。</p><ul><li>先将内存rs1地址处数据给到rd寄存器，之后再将rs2数据写入rs1地址处，实现rs2与内存中数据交换。</li><li>伪代码中两步应是原子的、不可分割的。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">rd</span>=*rs1<br>*<span class="hljs-attribute">rs1</span>=rs2<br></code></pre></td></tr></table></figure></li></ul></li><li><p>（2）原子加法指令</p><ul><li><p>amoadd 指令格式如下所示</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">amoadd.</span><span class="hljs-template-variable">&#123;w/d&#125;</span><span class="language-xml">.</span><span class="hljs-template-variable">&#123;aqrl&#125;</span><span class="language-xml"> rd,rs2,(rs1)</span><br></code></pre></td></tr></table></figure></li><li><p>其伪代码如下所示。</p><ul><li>该指令返回rs1地址处内存原先值给rd寄存器了；后将rs2和内存中地址为rs1处的数据进行相加，并将相加结果写回内存地址为rs1处。</li><li>伪代码中两步应是原子的、不可分割的。</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">rd = <span class="hljs-strong">*rs1</span><br><span class="hljs-strong">*rs1 = *</span>rs1 + rs2<br></code></pre></td></tr></table></figure></li></ul></li><li><p>（3）原子逻辑操作指令</p><ul><li><p>一共有3条：原子与、原子或、原子异或。指令格式分别如下。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">amoand.</span><span class="hljs-template-variable">&#123;w/d&#125;</span><span class="language-xml">.</span><span class="hljs-template-variable">&#123;aqrl&#125;</span><span class="language-xml"> rd,rs2,(rs1)</span><br><span class="language-xml">amoor.</span><span class="hljs-template-variable">&#123;w/d&#125;</span><span class="language-xml">.</span><span class="hljs-template-variable">&#123;aqrl&#125;</span><span class="language-xml"> rd,rs2,(rs1)</span><br><span class="language-xml">amoxor.</span><span class="hljs-template-variable">&#123;w/d&#125;</span><span class="language-xml">.</span><span class="hljs-template-variable">&#123;aqrl&#125;</span><span class="language-xml"> rd,rs2,(rs1)</span><br></code></pre></td></tr></table></figure></li><li><p>其伪代码如下所示。</p><ul><li>三个逻辑运算都是将rs1作为内存地址，将地址原数据返回给rd寄存器。后从内存中取出数据与rs2做逻辑运算，并将运算结果写回内存中。</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//amoand</span><br>rd = *rs1<br><span class="hljs-comment">*rs1 = *rs1 &amp; rs2</span><br><span class="hljs-comment">//amoor</span><br>rd = *rs1<br><span class="hljs-comment">*rs1 = *rs1 | rs2</span><br><span class="hljs-comment">//amoxor</span><br>rd = *rs1<br><span class="hljs-comment">*rs1 = *rs1 ^ rs2</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>（4）原子取大小值指令</p><ul><li><p>其包括4条指令：原子有符号取大值指令、原子无符号取大值指令、原子有符号取小值指令、原子无符号取小值指令。指令格式如下。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"># 其中带u的为无符号，没有u的为有符号</span><br><span class="language-xml">amomax.</span><span class="hljs-template-variable">&#123;w/d&#125;</span><span class="language-xml">.</span><span class="hljs-template-variable">&#123;aqrl&#125;</span><span class="language-xml"> rd,rs2,(rs1)</span><br><span class="language-xml">amomaxu.</span><span class="hljs-template-variable">&#123;w/d&#125;</span><span class="language-xml">.</span><span class="hljs-template-variable">&#123;aqrl&#125;</span><span class="language-xml"> rd,rs2,(rs1)</span><br><span class="language-xml">amomin.</span><span class="hljs-template-variable">&#123;w/d&#125;</span><span class="language-xml">.</span><span class="hljs-template-variable">&#123;aqrl&#125;</span><span class="language-xml"> rd,rs2,(rs1)</span><br><span class="language-xml">amominu.</span><span class="hljs-template-variable">&#123;w/d&#125;</span><span class="language-xml">.</span><span class="hljs-template-variable">&#123;aqrl&#125;</span><span class="language-xml"> rd,rs2,(rs1)</span><br></code></pre></td></tr></table></figure></li><li><p>其伪代码如下所示。</p><ul><li>四条大小值比较指令都是将rs1作为内存地址，将地址原数据返回给rd寄存器；后从内存中取出数据与rs2的值做大小值判断（包括有符号和无符号），将比较后的值返回给内存单元。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">exts</span><span class="hljs-params">(a)</span></span><br>&#123;<br>    return 扩展符号(a)<br>&#125;<br><span class="hljs-comment">//amomax</span><br>rd = *rs1<br>*rs1 = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">exts</span>(*rs1),<span class="hljs-built_in">exts</span>(rs2))<br><span class="hljs-comment">//amomaxu</span><br>rd = *rs1<br>*rs1 = *rs1 = <span class="hljs-built_in">max</span>(*rs1,rs2)<br><span class="hljs-comment">//amomin</span><br>rd = *rs1<br>*rs1 = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">exts</span>(*rs1),<span class="hljs-built_in">exts</span>(rs2))<br><span class="hljs-comment">//amominu</span><br>rd = *rs1<br>*rs1 = *rs1 = <span class="hljs-built_in">min</span>(*rs1,rs2)<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于CPU</title>
    <link href="/2023/11/01/%E5%85%B3%E4%BA%8ECPU/"/>
    <url>/2023/11/01/%E5%85%B3%E4%BA%8ECPU/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li>《计算机组成与设计 第五版》</li><li>《手把手教你设计CPU RISC-V处理器》</li></ul></li></ul><hr><h2 id="1-CPU部分性能指标"><a href="#1-CPU部分性能指标" class="headerlink" title="1. CPU部分性能指标"></a>1. CPU部分性能指标</h2><h3 id="1-1-程序执行时间"><a href="#1-1-程序执行时间" class="headerlink" title="1.1 程序执行时间"></a>1.1 程序执行时间</h3><ul><li>程序的CPU执行时间 &#x3D; 程序占用CPU时钟周期数 * 时钟周期。<ul><li>所以提高程序响应时间可以通过减少程序执行所需的时钟周期数，或提高时钟频率。</li></ul></li><li>上式的程序占用CPU时钟周期数 &#x3D; 程序指令数 * 指令平均时钟周期数。<ul><li>其中指令平均时钟周期数是指执行每条指令所需要的时钟周期平均数，缩写为Cycles per Instruction，CPI。</li><li>因此程序占用时间 &#x3D; 指令数 * CPI * 时钟周期长度。</li></ul></li><li>算法、编程语言和编译器会影响指令数和CPI，而指令系统体系结构在此基础上还会影响时钟周期长度。</li></ul><h3 id="1-2-CPU-频率"><a href="#1-2-CPU-频率" class="headerlink" title="1.2 CPU 频率"></a>1.2 CPU 频率</h3><ul><li>主要包括主频、外频和倍频。<ul><li>主频：CPU内核工作的时钟频率。</li><li>外频：系统总线的工作频率，CPU与周边设备传输数据的频率。该频率越高，单位时间系统接收来自外设的数据越多。</li><li>倍频：其值 &#x3D; 主频&#x2F;外频。</li></ul></li></ul><h3 id="1-3-缓存容量和性能"><a href="#1-3-缓存容量和性能" class="headerlink" title="1.3 缓存容量和性能"></a>1.3 缓存容量和性能</h3><ul><li>有关于缓存的内容可见<a href="https://www.cnblogs.com/qianbinbin/category/2316464.html">这个文件夹</a>。</li></ul><h2 id="2-ISA-指令集体系结构"><a href="#2-ISA-指令集体系结构" class="headerlink" title="2. ISA - 指令集体系结构"></a>2. ISA - 指令集体系结构</h2><ul><li>ISA是一种规约，规定了如何使用硬件。<ul><li>它规定了包括：指令格式、操作种类、操作数类型、存储空间大小、编址方式、大小端以及寻址方式等。</li></ul></li></ul><h3 id="2-1-CISC-和-RISC"><a href="#2-1-CISC-和-RISC" class="headerlink" title="2.1 CISC 和 RISC"></a>2.1 CISC 和 RISC</h3><ul><li>主要分为CISC 和 RISC。<ul><li>由于CISC指令定义的指令只有20%经常被使用到，而那些不常用的指令使得CPU的设计变得极为复杂，增加成本。</li><li>RISC只包含那20%常用的指令，对于不常用的可以组合多条指令完成。</li></ul></li></ul><h3 id="2-2-32-64位架构"><a href="#2-2-32-64位架构" class="headerlink" title="2.2 32 &amp; 64位架构"></a>2.2 32 &amp; 64位架构</h3><ul><li>位数一般就是指通用寄存器的位宽，决定了寻址范围的大小，2^32&#x2F;2^64；决定了数据处理能力的强弱，一个周期处理32bit&#x2F;64bit的数据。</li><li>注意：<strong>指令集架构的位宽与指令长度无关。</strong></li></ul><h3 id="2-3-常见的指令集架构"><a href="#2-3-常见的指令集架构" class="headerlink" title="2.3 常见的指令集架构"></a>2.3 常见的指令集架构</h3><ul><li>x86：CISC指令集，之后发展的“微码化”可以实现一种近似RISC的形式。但是还是需要额外的硬件解码器。（Intel、AMD是主要的x86处理器芯片供应商）。</li><li>MIPS：RISC指令集。</li><li>ARM：RISC指令集。</li><li>RISC-V：免费开放架构，没有专利桎梏。</li></ul><h2 id="3-冯诺依曼-哈佛-结构"><a href="#3-冯诺依曼-哈佛-结构" class="headerlink" title="3. 冯诺依曼 &amp; 哈佛 结构"></a>3. 冯诺依曼 &amp; 哈佛 结构</h2><ul><li>两者区别<ul><li>冯诺依曼 将指令和数据放在一个存储器中，指令和数据宽度一致；哈佛结构 将指令和数据分开存储在两个存储器中，指令和数据宽度不一致。  </li><li>冯诺依曼的指令和数据共享一根总线，所以在执行操作时都需要先取指令后取数据（顺序串行）；而哈佛结构的两个存储器是分开的，有两根总线，可以在读取指令时对数据进行操作（并行），效率更高。</li></ul></li><li>在<a href="https://www.cnblogs.com/qianbinbin/p/17468356.html">这篇博客</a>中，可以看到在CPU内部，L1 Cache是有ICache和DCache，可以理解CPU内部为哈佛结构。<ul><li>在L2 Cache及更外面的Cache以及主存中均为指令和数据缓存在一起，可认为是冯诺依曼结构。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统层次</title>
    <link href="/2023/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1/"/>
    <url>/2023/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://www.icourse163.org/learn/NJU-1001625001">https://www.icourse163.org/learn/NJU-1001625001</a></li></ul></li></ul><h2 id="1-计算机系统层次"><a href="#1-计算机系统层次" class="headerlink" title="1.  计算机系统层次"></a>1.  计算机系统层次</h2><ul><li><p>软件程序的转换处理过程</p><ul><li>以C-源程序为例，在GCC+Linux平台中的处理如下：<ul><li>（1）首先输入源程序文件hello.c，经过<strong>预处理</strong>（使用cpp）得到hello.i文件，其仍为源程序。</li><li>（2）对hello.i文件进行<strong>编译</strong>，得到hello.s文件，其为汇编语言程序。 </li><li>（3）将hello.s文件送入<strong>汇编器</strong>中，得到hello.o文件，其为可重定位目标程序（二进制，包括多条机器指令）。</li><li>（4）在程序中可能还有其它源程序参与，所以需要拿到其它源程序的.o文件，并进行<strong>链接</strong>，得到可执行目标程序（二进制）。</li></ul></li><li>上面介绍为计算机软件层实现的，从<strong>高级语言源程序-汇编语言源程序-机器语言目标程序</strong>的过程。</li><li>在计算机硬件层面，有<strong>指令译码器</strong>对机器语言的<strong>二进制指令进行译码</strong>，生成对应的控制信号来实现计算机的一些硬件操作。</li></ul></li><li><p>现代计算机系统层次如下图所示。</p><ul><li>其中语言处理系统包括：<ul><li>各种语言处理程序（如编译、汇编、链接）。</li><li>运行时的系统：如库函数，调试、优化等功能。</li></ul></li><li>其中操作系统包括人机交互界面、提供服务功能的内核例程。</li><li>其中指令集体系结构（ISA）可以认为是对计算机硬件设计的抽象，而所有的软件功能也都是建立在ISA之上。<ul><li>其中ISA相关的内容可以看<a href="https://www.cnblogs.com/qianbinbin/p/17515912.html">这篇博客</a>。</li><li>计算机硬件需要满足ISA规定的功能。</li></ul></li></ul></li></ul><pre><code class=" mermaid">graph TBA(应用程序) --&gt; B(语言处理系统) --&gt; C(操作系统) --&gt; D(指令集体系结构) --&gt; E(计算机硬件)</code></pre><h2 id="2-可执行文件生成过程详解"><a href="#2-可执行文件生成过程详解" class="headerlink" title="2. 可执行文件生成过程详解"></a>2. 可执行文件生成过程详解</h2><h3 id="2-1-预处理"><a href="#2-1-预处理" class="headerlink" title="2.1 预处理"></a>2.1 预处理</h3><ul><li><p>仍以C-源程序、GCC+Linux平台为例；预处理命令格式如下：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">gcc -E a.c -o a.i</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或直接使用预处理命令：cpp</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">cpp a.c &gt; a.i</span><br></code></pre></td></tr></table></figure></li><li><p>预处理主要完成以下任务</p><ul><li><p>处理源文件中以 “#” 开头的预编译指令，包括：</p><ul><li>删除 “#define” 并展开所定义的宏。</li><li>处理所有条件预编译指令，如 “ #if”，“#ifdef”，“#endif” 等。</li><li>处理源文件中的“#include”，将头文件插入此处；如果头文件中也有#include，可以进行递归处理。</li><li>添加代码行号和文件名标识，方便编译时编译器产生调试用的行号信息等。</li><li>保留所有 “#pragma” 编译指令，在后面编译时，编译器需要使用。</li></ul></li><li><p>经过预处理后，得到的仍是源文件，只是不包含任何宏定义。</p></li><li><p>举例如下</p>  <img src="image-20231030201350657.png" style="zoom:50%;" /></li></ul></li></ul><h3 id="2-2-编译"><a href="#2-2-编译" class="headerlink" title="2.2 编译"></a>2.2 编译</h3><ul><li><p>对预处理后得到的文件进行词法分析、语法分析、语义分析并优化，生成汇编代码文件。</p></li><li><p>编译命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">gcc -S a.i -o a.s</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或直接使用编译命令 cc1</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">/users/.../cc1 a.i</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果将预处理和编译放在一起进行</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">gcc -S a.c -o a.s</span><br></code></pre></td></tr></table></figure></li><li><p>可以看到无论是预处理、编译还是后面的汇编，都可以使用gcc命令。</p><ul><li>gcc命令实际上是具体程序（如 ccp&#x2F;cc1&#x2F;as 等）的包装命令。</li><li>用户可以使用gcc命令，并加上特定选项来使用特定的程序。</li></ul></li></ul><h3 id="2-3-汇编"><a href="#2-3-汇编" class="headerlink" title="2.3 汇编"></a>2.3 汇编</h3><ul><li><p>汇编指令和机器指令是一一对应的，前者是后者的符号表示，都是机器级指令。</p></li><li><p>汇编指令格式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">gcc -c a.s -o a.o</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或直接使用汇编命令as</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">as a.s -o a.o</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以使用下面命令直接完成三步</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">gcc -c a.c -o a.o</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-4-链接"><a href="#2-4-链接" class="headerlink" title="2.4 链接"></a>2.4 链接</h3><ul><li><p>链接指令格式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">其中myproc为链接后生成的可执行文件</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">gcc -static -o myproc main.o test.o</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或直接采用链接命令ld</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">ld -static -o myproc main.o test.o</span><br></code></pre></td></tr></table></figure></li><li><p>链接操作步骤</p><ul><li>（1）确定符号引用关系，代码段符号、数据段符号相互关联起来。</li><li>（2）合并相关的.o文件，将相关的代码段和数据段分别合并在一起。</li><li>（3）在合并后，就可以确定每个符号的地址，如下图的P0,P1,A,B,C等。</li><li>（4）在指令中添入新的地址。</li><li>第（1）步为符号解析，后面三步称为重定位。</li></ul><img src="2.png" style="zoom:50%;" /></li><li><p>C语言程序举例</p><ul><li>下图为<strong>可重定位目标文件和可执行目标文件</strong>之间映射关系。<ul><li>注意：swap()函数中的temp变量为局部变量，其被分配在栈中，不会在过程外被引用，因此不是符号定义。</li><li>在链接过程中会将相同的节进行合并。并完成符号解析和重定位。</li><li>图中text节为代码节，data节为已初始化后的数据节，bss为未初始化的全局变量和局部静态变量。还有许多其它未介绍的节，可以网上查阅。<ul><li>注意：bss节中默认初始值为0，因此在磁盘并不需要占实际空间，只需要在节头表中声明此处需要多少长度的内存空间。</li><li>在写入虚拟内存时，需要为4个节分配存储空间，分别为text，data，bss 和 rodata。</li><li>节头表包括了每个节的节名、偏移、大小、访问属性、对齐方式等信息。</li></ul></li></ul></li></ul><img src="image-20231030215107334.png" style="zoom:50%;" /><img src="3.png" alt="3" style="zoom:50%;" /><ul><li><p>下图为磁盘中的<strong>可执行目标文件和虚拟内存</strong>之间的映射关系。</p><ul><li>其中<strong>ELF</strong>为Linux下的<strong>目标文件格式</strong>，后面会进行详细介绍。<ul><li>ELF头 包括了文件类型，大端&#x2F;小端，机器类型，以及程序头表和节头表相关信息（偏移、大小、个数等）。<ul><li>对于可执行目标文件，ELF头需要给字段 e_entry 执行程序时第一条指令的地址。而在可重定位文件中因为并不需要进行执行，所以该字段为0.</li></ul></li></ul></li><li>其中程序（段）头表中说明了每个段的属性，包括：可执行目标文件中的节与虚拟地址的映射关系、段的大小、在虚拟空间中的位置、对齐方式以及访问属性等。<ul><li>程序头表中有<strong>两个表项为可装入段</strong>(即：Type&#x3D;LOAD)，完成向虚拟空间装入<strong>只读代码段以及读写数据段。</strong></li></ul></li><li>像前面介绍，在写入虚拟内存时，只需要为4个节分配存储空间。因此下图中可执行目标文件灰色部分的节不需要装入到存储空间。</li><li>另外，可执行目标文件比可重定位目标文件<strong>多了一个.init节</strong>，用于定义_init函数，该函数是用来进行执行目标文件时的初始化工作的。</li></ul><img src="4.png" alt="4" style="zoom:50%;" /></li></ul></li></ul><h3 id="2-5-目标文件"><a href="#2-5-目标文件" class="headerlink" title="2.5 目标文件"></a>2.5 目标文件</h3><ul><li>三类目标文件<ul><li>可重定位目标文件 (.o)<ul><li>为汇编之后得到的文件，其代码和数据可以和其它可重定位文件合并为可执行文件。</li><li>每个.o文件的代码和数据地址都是从0开始。</li></ul></li><li>可执行目标文件（Linux默认为a.out，windows中为*.exe）<ul><li>包含代码和数据可以被直接映射到虚拟内存中被执行。</li><li>代码和数据的地址为虚拟内存空间中的地址。</li></ul></li><li>共享的目标文件（Linux中的*.so）<ul><li>特殊的可重定位目标文件，能够在运行时自动被装入到内存中并自动链接到某个存在相关调用的可执行目标文件中。</li><li>这种是<strong>动态的被链接</strong>，区别于前面添加多个相关的可重定位目标文件进行的<strong>静态链接</strong>。</li><li>更详细的会在后续动态链接处进行介绍。</li></ul></li></ul></li><li>目标文件格式<ul><li>DOS 操作系统：COM格式。<ul><li>仅包含代码和数据，且被加载到内存的固定位置，不采用虚拟地址。</li></ul></li><li>System V UNIX 早期版本：COFF格式。<ul><li>不仅包含代码和数据，还包含<strong>重定位信息、调试信息、符号表等</strong>。</li></ul></li><li>Windows：PE格式，COFF的变种。</li><li>Linux：ELF (Executable and Linkable Format) 格式，COFF的变种。</li></ul></li></ul><h2 id="3-ELF格式"><a href="#3-ELF格式" class="headerlink" title="3. ELF格式"></a>3. ELF格式</h2><ul><li><p>存在两种视图，包括链接视图(Linkable)和执行视图(Executable)。</p><ul><li><p>链接视图</p><ul><li>主要展示被链接的情况，按照相同特征划分为不同节。</li></ul></li><li><p>执行视图</p><ul><li>主要展示被执行的情况，将具有相同访问属性的节合并成段。</li><li>前面也有介绍，段的属性被包括在程序（段）头表中。</li></ul><p><img src="/2023/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1/811006-20180503113716101-439702289.png"></p></li></ul></li></ul><p>​</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
      <category>软件层</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cache一致性</title>
    <link href="/2023/10/29/Cache%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <url>/2023/10/29/Cache%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/136300660">https://zhuanlan.zhihu.com/p/136300660</a></li><li><a href="https://zhuanlan.zhihu.com/p/515450647">https://zhuanlan.zhihu.com/p/515450647</a></li></ul></li></ul><hr><h2 id="1-Cache-的-invalidate-clean"><a href="#1-Cache-的-invalidate-clean" class="headerlink" title="1. Cache 的 invalidate &amp; clean"></a>1. Cache 的 invalidate &amp; clean</h2><ul><li>invalidate<ul><li>将相应位置的cacheline状态置为无效，<strong>将valid bit置为0</strong>. 并不需要清除相应位置的cacheline数据。</li><li>复位之后，需要将所有的cacheline的valid信号置为0，防止复位后，cache命中拿到错误未定义的数据。</li></ul></li><li>clean<ul><li>将<strong>dirty bit</strong> 为1的cacheline写回主存中，同时拉低cacheline的dirty bit，通过这种方式可以将cache中的数据和主存中数据保持一致（针对写回策略）。</li></ul></li></ul><h2 id="2-Cache-DMA一致性"><a href="#2-Cache-DMA一致性" class="headerlink" title="2. Cache &amp; DMA一致性"></a>2. Cache &amp; DMA一致性</h2><ul><li>DMA &amp; Cache<ul><li>DMA相关内容可见<a href="https://i.cnblogs.com/posts?cateId=2319426">这个专题</a>。DMA可以实现不经过CPU实现外设和存储器以及存储器和存储器的数据传输。</li><li><a href="https://www.cnblogs.com/qianbinbin/p/17468440.html">这篇博客</a>中介绍Cache的位置为 CPU Registers 和 主存之间数据交互的桥梁。 </li><li>可能会出现如下情况：Cache采用写回策略，Cache中更改的数据暂未被写回到主存，但此时DMA已经将主存中旧的数据传输给外设接口；程序运行出现问题。</li></ul></li><li>Cache的总线监视技术<ul><li>为了解决上面Cache和DMA不一致的问题，可以在DMA通过总线获取数据时，先检查cache是否命中，如果命中的话，数据应该来自cache而不是主存。</li><li>可以通过cache的总线监视技术实现，cache控制器会监视总线上的每一条内存访问，检查是否命中，根据命中情况做下一步操作。<ul><li>DMA操作的是物理地址，cache若想监视DMA的访问地址，那么需要Cache也是按照物理地址进行查找的，所以选择PIPT Cache结构。</li></ul></li><li>对于一些已经设计完成的硬件电路，并不支持总线监视技术，那么也可以通过其它方式避免DMA和Cache不一致的问题。</li></ul></li><li>No Cache<ul><li><a href="https://www.cnblogs.com/qianbinbin/p/17491401.html">这篇博客</a>中有介绍DMA在主存中实现双缓冲用做主存到IO口&#x2F;IO口到主存的数据传输，为了避免cache的影响，我们可以选择将这段内存映射为no cache。</li><li>这种方法很简单实用，但缺点是：如果偶尔使用DMA，但将缓冲区一段的内存设为nocache，导致 CPU Register-主存 的性能损失。</li></ul></li><li>软件维护一致性<ul><li>为了避免No Cache带来的性能损失，可以选择映射仍采用cache的方式，根据DMA传输方向不同分情况讨论。<ul><li>DMA传输方向为：I&#x2F;O -&gt; 内存(DMA Buffer)<ul><li>在DMA传输之前，可以invalidate DMA buffer段的cache。</li><li>在DMA传输完成之后，由于buffer对应段的cacheline valid置为0，数据需要重新加载，并将valid重新置为1.这样CPU读cache中的数据就不会读到过时的数据了。</li></ul></li><li>DMA传输方向为：内存(DMA Buffer) -&gt; I&#x2F;O<ul><li>在DMA传输前，可以clean DMA buffer段的cache。</li><li>将cache中dirty bit被拉高的cache line写回主存中，这样在DMA传输时，就不会将主存中过时数据发送到I&#x2F;O设备。</li></ul></li></ul></li><li>注意：在DMA传输没有完成期间，我们需要保证CPU不要访问DMA Buffer。因为可能CPU读走的数据并不是最终完成DMA传输的数据，导致程序错误。</li></ul></li><li>DMA Buffer对齐<ul><li>实例可以看<a href="https://zhuanlan.zhihu.com/p/109919756">这篇文章</a>。</li><li>简要概述一下文章中描述的情况，如下：<ul><li><p>若未对齐，那么变量temp和buffer在cacheline中的存放如下图所示。</p></li><li><p>现DMA进行外设-&gt;内存传输数据到buffer变量中。</p></li><li><p>但在传输过程中，DMA传输到buff[3]时，CPU对temp的进行改动；之后DMA传输到buff[50]时，由于其它操作可能需要替换掉temp所在cacheline，发现dirty bit被拉高，便需要将该行cacheline写回。这个过程都发生在DMA传输过程中。</p></li><li><p>从图中可以看到写回的时buffer[0]-buffer[59],直接覆盖掉DMA从外设传输过来的buffer值。</p></li><li><p>可以通过对齐DMA buffer来解决这个问题，即让buffer变量不和其它数据公用一个cacheline。</p><p><img src="/2023/10/29/Cache%E4%B8%80%E8%87%B4%E6%80%A7/3201119-20230811122740521-659669830.png"></p></li></ul></li></ul></li></ul><h2 id="3-ICache-和-DCache-一致性"><a href="#3-ICache-和-DCache-一致性" class="headerlink" title="3. ICache 和 DCache 一致性"></a>3. ICache 和 DCache 一致性</h2><ul><li><a href="https://www.cnblogs.com/qianbinbin/p/17468356.html">这篇博客</a>中有介绍，在CPU的L1 Cache会单独分为ICache和DCache。而L2和L3不会区分ICache和DCache。</li><li>ICache的歧义和别名<ul><li>歧义和别名在<a href="https://www.cnblogs.com/qianbinbin/p/17470849.html">这篇博客</a>中有介绍。</li><li>歧义可以通过 Physical Tag 解决，对于VIPT型Cache，仍然存在别名的问题。</li><li>考虑到ICache的Read Only特性，所以即使两个Cache line上缓存一个物理地址上的数据也没有关系。</li></ul></li><li>不一致性的情况<ul><li>程序在执行过程中，指令一般不会修改，此时不会出现一致性问题。</li><li>但是对于一些特殊情况：self-modifying code，在执行时会修改自己的指令，它们修改指令的过程为：<ul><li>将需要修改的指令加载到dCache中。</li><li>修改成新指令，写回dCache。</li></ul></li><li>可能会出现的问题<ul><li>如果旧指令已经缓存在iCache中。那么对于程序执行来说依然会命中iCache。这不是我们想要的结果。</li><li>如果旧指令没有在iCache中，那么CPU会去主存中取指令数据，而如果dCache采用的是写回策略，那么指令会被写回到dCache，而不会写回主存，那么从主存中取出的指令也不是想要的。</li></ul></li></ul></li><li>不一致性的解决方案<ul><li>硬件维护<ul><li>硬件上让iCache和dCache之间通信。</li><li>每一次修改dCache数据时，去查一下iCache是否命中；如果命中，那么也更新一下iCache。</li><li>当加载指令时，先去查找iCache中是否命中，如果没有命中，再去dCache中查找。如果都没有命中再去查找主存。</li><li>但是self-modifying code是少数，为了解决少数的情况，却给硬件带来了很大的负担。</li></ul></li><li>软件维护<ul><li>可以通过下面的步骤维护一致性。<ul><li>（1）将需要修改的指令数据加载到dCache中。</li><li>（2）修改成新指令，写回dCache。</li><li>（3）clean dCache中修改的指令对应的cacheline，保证dCache中新指令写回主存。</li><li>（4）invalid iCache中修改的指令对应的cacheline，保证从主存中读取新指令。</li></ul></li></ul></li></ul></li></ul><h2 id="4-多核Cache一致性"><a href="#4-多核Cache一致性" class="headerlink" title="4. 多核Cache一致性"></a>4. 多核Cache一致性</h2><ul><li>每个CPU之间都有一个L1 Cache，如果为多核，需要考虑多核Cache之间的一致性。</li><li>不一致性的情况<ul><li>假设存在两个CPU，都有对应的L1 Cache。首先两个CPU都读取了0x40地址数据，CPU从主存加载数据到对应的Cache Line中。</li><li>采用写回策略，CPU0写数据会更新其对应的L1_Cahce0，dirty bit被拉高。之后CPU1发现命中了L1_Cache1，将未被修改的值读出。导致数据读出错误。</li></ul></li><li>解决思路<ul><li>思路一：CPU0修改0x40的时候，除了更新CPU0的Cache之外，还应该通知CPU1的Cache更新其Cache 0x40的数据。  </li><li>思路二：<ul><li>CPU0修改0x40的时候，除了更新CPU0的Cache之外，还可以通知CPU1的Cache将0x40地址所在cache line置成invalid。保证CPU1读取数据时不会命中自己的Cache。</li><li>不命中CPU1的Cache之后，我们有两种选择保证读取到最新的数据。<ul><li>(a) 从CPU0的私有cache中返回0x40的数据给CPU1；</li><li>(b) CPU0发出clear信号后，将cache0 0x40的数据写回主存，CPU1 cache置为invalid，从主存读取最新的数据。</li></ul></li></ul></li></ul></li><li>解决方法<ul><li>现在几乎不会使用软件维护一致性，因为成本过高，维护一致性带来的性能损失会抵消掉一部分cache带来的性能提升。</li><li>目前主要采用硬件维护，这里介绍Bus Snooping Protocol和MESI Protocol。</li><li>Bus Snooping Protocol <ul><li>实现思路<ul><li>总线监控协议，当CPU0修改自己私有的Cache时，硬件就会广播通知到总线上其它的CPU。</li><li>对于每个CPU来说，会有特殊的硬件去监听广播事件，并检查是否有相同地址的数据被缓存在自己的CPU上。</li><li>如果其它CPU缓存上存在相同地址的数据，那么也需要对应更新cache line。</li></ul></li><li>存在问题<ul><li>总线需要每时每刻监听总线上的一切活动，一定程度上增加了总线负载和读写延迟。</li></ul></li></ul></li><li>MESI Protocol<ul><li>主要解决针对Bus Snooping Protocol存在的问题。</li><li>MESI：主要是指四种状态，Modified、Exclusive、Shared、Invalid。</li><li>举例，继续上面的例子。<ul><li>当CPU0从主存中读取0x40的数据，将数据加载到cache0中。此时CPU1的cache1中没有该地址数据，所以可以在cache0中标记该cache line为<strong>Exclusive</strong>状态。表示该cache line的数据是某一个CPU独占的。</li><li>当CPU1也想读0x40的数据，CPU1就会发送消息给其它CPU，发现cache0中存在该数据，那么数据将会从cache0给到cache1.cache line的状态变为<strong>Shared</strong>。表示该数据在多个CPU的cache中被缓存，且与主存数据保持一致。</li><li>当CPU0继续修改0x40地址的数据，发现该地址cache line为shared状态，CPU0会发送<strong>Invalid</strong>信息给到其它CPU。<ul><li>CPU1接收到invalid信号，将对应地址(0x40)cache line置为invalid。</li><li>CPU0收到CPU1更改invalid状态的信息之后，修改0x40所在的cache line中的数据，并更新cache line的状态为<strong>Modified</strong>。</li><li>Modified表示该cache line数据是某一个CPU私有的，且与主存中的数据不一致，表示被修改。</li></ul></li><li>如果CPU0还想要修改cache0 0x40的数据，并发现cache line的状态为Modified；此时CPU0不需要向其它CPU发送消息，直接更新数据就可以。因为当前cache line数据是其CPU独有的。</li><li>如果当前cache line需要被替换，发现cache line的状态是Modified，数据会先被写回主存中。</li></ul></li><li>上面介绍的例子中，如果cache line的状态是Modified&#x2F;Exclusive状态，修改其数据并不需要通知其它CPU，这在一定程度上减轻了带宽的压力。</li></ul></li><li>MESI Protocol Messages<ul><li>CPU、L1 Cache之间的数据和状态是通过发送message进行同步的。</li><li>主要包括以下几种Messages：<ul><li>Read: CPU需要读取某个地址的数据，发送Read Message。</li><li>Read Response: 读回复，并且返回需要读取的数据。</li><li>Invalidate: 要求其他CPU invalid对应地址的cache line。</li><li>Invalidate Acknowledge: 回复 发起invalidate的CPU，表明对应的cache line已经被invalidate。</li><li>Read Invalidate: Read + Invalidate消息的组合。</li><li>Writeback: 该消息包含从Cache Line要回写到主存的地址和数据。</li></ul></li><li>更多关于MESI协议相关内容可见<a href="https://www.cnblogs.com/qianbinbin/p/17731460.html">这篇博客</a>.</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
      <category>Cache</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TLB</title>
    <link href="/2023/10/29/TLB/"/>
    <url>/2023/10/29/TLB/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/108425561">https://zhuanlan.zhihu.com/p/108425561</a></li></ul></li></ul><hr><h2 id="1-TLB由来"><a href="#1-TLB由来" class="headerlink" title="1. TLB由来"></a>1. TLB由来</h2><ul><li>在<a href="https://www.cnblogs.com/qianbinbin/p/17466384.html">这篇博客</a>中有简单介绍。</li><li>MMU根据页表，将虚拟地址映射得到对应的物理地址。<ul><li>页表在64bit系统中，常见为3-5级，以4级为例，分别有PGD\PUD\PMD\PTE四级页表。</li><li>硬件上有一个<strong>页表基地址寄存器</strong>，存放着PGD页表的首地址；之后根据虚拟地址中PGD index查找到对应的PUD页表的首地址，依次类推，最后找到PTE中存放的物理地址。示意图在<a href="https://zhuanlan.zhihu.com/p/108425561">这篇文章</a>中，结合看更清晰。</li></ul></li><li>上面所描述的查找过程十分费时，影响性能，考虑加一块缓存，提高速度。于是就出现了TLB。<ul><li>TLB本质上是一块高速缓存，在虚拟地址到物理地址转换时，首先查找TLB，是否命中，如果命中直接得到物理地址。如果未命中，仍需要一级一级查找页表获取物理地址，并需要将虚拟地址和物理地址的映射关系缓存到TLB中。</li></ul></li></ul><h2 id="2-TLB-的歧义-别名"><a href="#2-TLB-的歧义-别名" class="headerlink" title="2. TLB 的歧义&amp;别名"></a>2. TLB 的歧义&amp;别名</h2><ul><li>由于TLB用途就是根据虚拟地址查找cache，所以TLB必定是VIVT。<a href="https://www.cnblogs.com/qianbinbin/p/17470849.html">这篇博客</a>中有介绍VIVT存在<strong>歧义和别名</strong>的问题。</li></ul><h3 id="2-1-TLB-特殊处理"><a href="#2-1-TLB-特殊处理" class="headerlink" title="2.1 TLB 特殊处理"></a>2.1 TLB 特殊处理</h3><ul><li>TLB 有些不同于前面学习的Cache，在<a href="https://www.cnblogs.com/qianbinbin/p/17466384.html">这篇博客</a>中，可以看到虚拟地址映射单位为Page，一般Page大小取4KB，所以TLB不需要存储虚拟地址的低12bit，在最后得到PPN的值后直接拼接低12bits即可。</li><li>另外，命中cache之后，cache line中的数据即page index，所以都会被取出，不需要offset域。</li><li>index域是否存在取决于是否为全相联缓存。</li></ul><h3 id="2-2-别名"><a href="#2-2-别名" class="headerlink" title="2.2 别名"></a>2.2 别名</h3><ul><li>VIVT 数据Cache出现别名的主要原因在<a href="https://www.cnblogs.com/qianbinbin/p/17470849.html">这篇博客</a>。根本在于存在一个修改<strong>地址-数据映射关系</strong>，且未被同步。</li><li>TLB虽然是VIVT，但是由于其不存在修改<strong>虚拟地址-物理地址映射关系</strong>，那么就不会出现别名情况。</li></ul><h3 id="2-3-歧义"><a href="#2-3-歧义" class="headerlink" title="2.3 歧义"></a>2.3 歧义</h3><ul><li>VIVT 出现歧义的主要原因在于不同进程中，相同虚拟地址可能对应着不同的物理地址。</li><li>解决方法：与VIVT 数据Cache 相同，采用切换进程时flush TLB，将整个TLB置为无效；但会导致性能损失。</li></ul><h3 id="2-4-如何尽量避免flush-TLB"><a href="#2-4-如何尽量避免flush-TLB" class="headerlink" title="2.4 如何尽量避免flush TLB"></a>2.4 如何尽量避免flush TLB</h3><ul><li>前面介绍，TLB存在歧义问题主要是不同进程的相同虚拟地址对应不同物理地址，那么如果可以<strong>区分不同进程的TLB表项</strong>就可以避免flush TLB。     </li><li>上面的想法可以通过每行cache line扩展几bit作为<strong>分辨进程ID</strong>（ASID:Address Space ID），在判断TLB是否命中时，除了比较tag，还需要比较ASID，选择当前进程匹配的ASID的cacheline进行操作。</li><li>ASID的管理<ul><li>需要注意：<strong>ASID和进程ID并不是一个</strong>，进程ID取值范围很大，但ASID一般为8&#x2F;16bit，只能区分256&#x2F;65536个进程。所以ASID和进程ID不可能一一对应。</li><li>每创建一个新进程时，就会为之分配一个ASID，当所有的ASID都分配完了，就会flush TLB，之后重新分配。</li><li>ASID一方面需要放在TLB Cache line中，另一方面可以将其放在前面介绍的页表基地址寄存器中拓展若干bit；在查TLB是否命中时，比较tag，以及这两部分的ASID是否相等。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
      <category>Cache</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cache-虚拟地址&amp;物理地址</title>
    <link href="/2023/10/29/Cache-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80&amp;%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/"/>
    <url>/2023/10/29/Cache-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80&amp;%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/107096130">https://zhuanlan.zhihu.com/p/107096130</a></li></ul></li></ul><hr><h2 id="1-VIVT（Virtually-Indexed-Virtually-Tagged）"><a href="#1-VIVT（Virtually-Indexed-Virtually-Tagged）" class="headerlink" title="1. VIVT（Virtually Indexed Virtually Tagged）"></a>1. VIVT（Virtually Indexed Virtually Tagged）</h2><ul><li>虚拟高速缓存：以虚拟地址作为查找对象。</li><li>首先虚拟地址给cache，如果命中，则返回数据给cpu，如果未命中，则将虚拟地址通过MMU转化为物理地址，根据物理地址从主存中读取数据。</li><li>优点<ul><li>不需要在查找cache过程将虚拟地址翻译成物理地址，节省了MMU转换的时间，提高访问cache的访问速度。</li></ul></li><li>缺点<ul><li>引入软件使用上的问题，歧义（ambiguity）和别名（alias）。</li></ul></li></ul><h2 id="2-歧义"><a href="#2-歧义" class="headerlink" title="2. 歧义"></a>2. 歧义</h2><ul><li>歧义是指数据在cache中有相同的tag和index。</li><li>发生情况：<strong>不同进程，相同的虚拟地址映射不同的物理地址。</strong><ul><li>可能出现A进程地址a映射的数据为b，而B进程地址a映射的数据为c，当A进程运行时，访问地址a会将数据b加载到cache上，而进程B运行时，访问地址a时命中了并将数据b返回给CPU，但是实际上B进程应该把数据c给CPU。</li></ul></li><li>解决方法：切换进程，flush cache，主要有两种。<ul><li>使主存储器有效：首先将主存置为有效，将cacheline上已经修改的数据写回主存上，避免修改的数据丢失。</li><li>使高速缓存无效：首先将cacheline都置为无效，保证切换时不会有进程误命中上一进程的数据。</li></ul></li><li>所以对于VIVT来说，每次进程切换时，都可能出现大量的cache缺失，且只要切换进程就需要flush cache，导致性能的缺失。</li></ul><h2 id="3-别名"><a href="#3-别名" class="headerlink" title="3. 别名"></a>3. 别名</h2><ul><li>发生情况：不同虚拟地址映射到相同物理地址。 <ul><li>可能出现物理地址A对应的虚拟地址为B和C，index值B&lt;C,那么当程序想要修改物理地址A对应的数据时，采用写回策略，对B进行修改，且修改的值没有同步到主存中，当程序想要访问虚拟地址C时，命中，但是取出的数据是未修改的。</li></ul></li><li>解决方法<ul><li>（1）采用nocache映射，不通过cache映射，CPU直接去主存读写数据。既适用于不同进程共享数据也适用于相同进程共享数据。</li><li>（2）不同进程共享数据，可以选择在进程切换时，flush cache，（主要因为存在一个向主存写数据的过程）。</li><li>（3）同一进程共享数据，保证虚拟地址cache大小对齐，保证每次虚拟地址都会找到同一个cacheline，下面有更详细的描述。</li></ul></li></ul><h2 id="4-PIPT（Physically-Indexed-Physically-Tagged"><a href="#4-PIPT（Physically-Indexed-Physically-Tagged" class="headerlink" title="4. PIPT（Physically Indexed Physically Tagged)"></a>4. PIPT（Physically Indexed Physically Tagged)</h2><ul><li>物理高速缓存：为了解决VIVT歧义和别名的问题，tag和index都取自物理地址，对于物理地址来说tag和index都是唯一的。</li><li>实现过程<ul><li>CPU发出的虚拟地址首先经过MMU转化为物理地址，给到cache控制器观察是否命中。如果未命中，将去主存中根据物理地址取出数据。</li></ul></li><li>缺点<ul><li>硬件设计较VIVT要复杂很多，需要等待MMU转换之后才可以查cache。</li><li>为了加快MMU转换速度，硬件上也会加一块TLB，虚拟地址和物理地址转换可以<a href="https://www.cnblogs.com/qianbinbin/p/17466384.html">这篇博客</a>。</li><li>很多CPU都使用PIPT高速缓存。</li></ul></li></ul><h2 id="5-VIPT（Virtually-Indexed-Physically-Tagged）"><a href="#5-VIPT（Virtually-Indexed-Physically-Tagged）" class="headerlink" title="5. VIPT（Virtually Indexed Physically Tagged）"></a>5. VIPT（Virtually Indexed Physically Tagged）</h2><ul><li>物理标记的虚拟高速缓存</li><li>使用虚拟index查找cacheline，与此同时，将虚拟地址给MMU转换为物理地址。MMU转换完之后cache也查找结束了，此时比对物理tag是否相同，以判断是否命中cache。</li><li>不会存在歧义<ul><li>关键在于 VIPT的tag使用的是物理地址的PFN，是唯一的。</li></ul></li><li>不会存在别名（特定情况下）<ul><li>对于大部分系统来说，虚拟地址和物理地址之间的映射最小是以页为单位，在<a href="https://www.cnblogs.com/qianbinbin/p/17466384.html">这篇博客</a>中有介绍，页addr[11:0]内的内容无论是物理地址还是虚拟地址都是相同的。</li><li>所以对于直接映射高速缓存，如果cache的大小小于等于4KB，那么意味着虚拟地址和物理地址的index是一样的，此时VIPT和PIPT是相同的。</li><li>对于多路组相连高速缓存，每一组大小小于等于4KB，使用虚拟地址（此时等于物理地址）来做index寻址，并选择物理地址的tag来选择命中哪路的cache line。</li></ul></li><li>别名问题<ul><li>若cache的大小大于4KB，还是会出现别名问题。</li><li>目的：避免相同物理地址的数据被加载到不同cacheline中。<ul><li>解决方法：相同物理地址数据对应的虚拟地址满足cache大小对齐。</li><li>举例：cache大小8KB &#x3D; 2^13，cache line大小为256B &#x3D; 2^8，那么虚拟地址应该是下表几种情况，这样才会都找到第4行cacheline，不会出现别名的情况。</li><li>Linux实现中，采用该方法解决的别名问题。<style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style></li></ul></li></ul></li></ul><div class="center"><table><thead><tr><th>address</th></tr></thead><tbody><tr><td>0_00100_0000_0000</td></tr><tr><td>1_00100_0000_0000</td></tr><tr><td>10_00100_0000_0000</td></tr><tr><td>…</td></tr></tbody></table></div><ul><li>对于L1 Cache的ICache，如果使用VIPT，虽然存在别名问题，但是考虑其为<strong>只读</strong>，所以即使多个虚拟地址对应一个物理地址也没有关系。</li></ul><h2 id="6-不存在的PIVT高速缓存"><a href="#6-不存在的PIVT高速缓存" class="headerlink" title="6. 不存在的PIVT高速缓存"></a>6. 不存在的PIVT高速缓存</h2><ul><li>没有任何优点，首先需要通过MMU转换，消耗时间。还存在歧义和别名的问题。</li></ul><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><ul><li>VIVT几乎没有人使用，软件维护成本过高。</li><li>对于多路组相连高速缓存的一路大小小于等于4KB，采用VIPT。</li><li>对于一路大于4KB的，一般采用PIPT，VIPT也可以，但是还是需要特殊处理一下别名问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
      <category>Cache</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cache-分配策略&amp;更新策略</title>
    <link href="/2023/10/29/Cache-%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5&amp;%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/"/>
    <url>/2023/10/29/Cache-%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5&amp;%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/102293437">https://zhuanlan.zhihu.com/p/102293437</a></li><li>《计算机组成与设计 第五版》</li></ul></li></ul><hr><h2 id="1-分配策略"><a href="#1-分配策略" class="headerlink" title="1. 分配策略"></a>1. 分配策略</h2><ul><li>分配策略是指什么情况需要为数据分配cache line。</li><li>读分配<ul><li>当CPU读数据时，cache缺失，分配一个cache line来缓存从主存中取出的数据。</li></ul></li><li>写分配<ul><li>场景：CPU写数据时，cache缺失。</li><li>当不支持写分配时，写指令直接更新主存的数据。例如：对某一页内存进行初始化操作（全部写0），此时就没必要将对应数据写入cache中。</li><li>支持写分配时，会首先将主存中的数据加载到cache line中，（变成命中），然后更新cache line的数据&#x2F;主存的数据。</li></ul></li></ul><h2 id="2-更新策略"><a href="#2-更新策略" class="headerlink" title="2. 更新策略"></a>2. 更新策略</h2><ul><li>更新策略是指当cache命中时，写操作如何更新数据。</li><li>写直通（Write Through）<ul><li>例如，CPU执行store指令，且cache命中，首先更新cache中的数据，并更新主存中的数据。cache 和主存的数据保持一致。</li><li>但是<strong>性能不佳</strong>，因为每次写操作都会引起写主存的操作，这个延时是比较大的，至少100个处理器时钟周期，大大降低处理器性能。</li><li>上面描述情况的解决方案是：<strong>write buffer</strong><ul><li>数据写入cache的同时也写入写缓冲中，之后处理器继续执行。</li><li>写缓冲不断向主存中写入数据，如果写缓冲满了，那么处理器必须停顿流水线直到写缓冲中出现空闲表项。<ul><li>我认为有点类似乒乓操作。</li></ul></li><li>如果主存写操作的速率小于处理器产生写操作的速率，那么多大容量的缓冲都没用，都会很快就满了。</li><li>即使处理器产生写操作的写速率小于主存写操作速率，也可能会产生停顿，例如出现写burst传输时，此时可以增加写缓冲容量解决。</li></ul></li></ul></li><li>写回（Write Back）<ul><li>仍是CPU执行store指令，且cache命中，我们只更新cache中的数据，而不立即写入主存，此时cache和主存的数据不一致。</li><li><strong>cache line有1个bit（dirty bit）用于记录数据是否被修改过。</strong> </li><li>当cache中的数据要被替换（如：出现写失效），才会写回主存中。</li><li>需要实现一个<strong>write-back buffer</strong>。<ul><li>在出现写失效时，需要根据dirty bit判断是否要将cache line中的数据写回到主存中。</li><li>在主存读取需要填充到cache中的数据时，将cache line中的数据写入write-back buffer中。</li><li>之后再由buffer写入主存中。</li></ul></li></ul></li><li>写回 &amp; 写直通<ul><li>写直通的写操作可以在一个周期内完成，读取标签的同时将数据写入对应的数据块。<ul><li>如果tag匹配，那么完成写操作，处理器继续执行。</li><li>如果tag不匹配，那么产生写失效，将主存中对应地址的数据取出送到cache中。</li></ul></li><li>写回的写操作至少需要两个周期去处理：第一个周期用于判断tag是否命中，若命中则第二个周期进行cache写操作。<ul><li>不能一个周期就完成的原因：如果在第一个周期就将数据写入，如果tag没有命中，会导致cacheline原有数据未来得及写回主存中，导致数据被破坏。 </li><li>也可以像写直通一样实现一个<strong>store buffer</strong>。<ul><li>第一个周期，将数据写入store buffer中，同时查找cache，判断是否命中。</li><li>如果命中，在下一个无用的cache访问周期将新数据从buffer中写入cache。</li></ul></li></ul></li></ul></li></ul><h2 id="3-实例"><a href="#3-实例" class="headerlink" title="3. 实例"></a>3. 实例</h2><ul><li>具体内容可以看<a href="https://zhuanlan.zhihu.com/p/102293437">这篇文章</a>中的实例。</li><li>这里只列出我觉得需要特殊注意的地方<ul><li>当发现cache缺失时，会出现CPU从主存中取数据给cache line的情况，此时需要注意dirty bit是否被拉高。<ul><li>如果该bit被拉高，那么cache的数据不能直接覆盖，说明这个数据对应的地址之前发生过写回操作，并没有同步到主存中，如果直接覆盖则会丢失这部分的数据。</li><li>将被替换这部分数据写回至主存中。</li><li>将主存中0x28地址（cache line地址对齐，这里应该要被8整除）开始的8个数据写入cache line中，并清除掉dirty bit，将offset找到的数据返回给CPU。</li></ul></li></ul></li></ul><h2 id="4-Cache-性能评估"><a href="#4-Cache-性能评估" class="headerlink" title="4. Cache 性能评估"></a>4. Cache 性能评估</h2><ul><li>$ CPU时间 &#x3D; (CPU执行的时钟周期数 + 等待存储访问的时钟周期数) * 时钟周期 $ </li><li>假设等待存储访问的时钟周期数主要来自于cache引起的，下面根据读和写分开讨论。<ul><li>读操作带来的停顿周期数 只由读失效带来。<br>$$<br>读操作带来的停顿周期数&#x3D;\frac{读操作数目}{程序}*\frac{读失效次数}{指令数目}*读失效代价<br>$$  </li><li>写操作带来的停顿周期数 <ul><li>写直通策略<ul><li>有两个停顿的来源，写失效和写缓冲停顿。后者为buffer满时仍进行写操作引发的停顿。<br>$$<br>写操作带来的停顿周期数 &#x3D; \frac{写操作数目}{程序}*\frac{写失效次数}{指令数目}*写失效代价+写缓冲满时的停顿周期<br>$$</li></ul></li><li>写回策略<ul><li>停顿主要来源于cache line要被替换，并需要将原数据写回主存中。</li></ul></li></ul></li></ul></li><li>前面介绍是未命中时对性能的影响，但是除了失效率，还有命中时间也会对性能有很大的影响。<ul><li>举例：增大Cache的容量（主要是Cache line的个数），更大的Cache需要更久的命中时间。这个命中时间可以算在CPU执行的时钟周期数上。</li><li>定义 平均存储访问时间(AMAT) 将Cache的命中时间也考虑在内，公式如下。<br>$$<br>AMAT &#x3D; 命中时间+失效率*失效代价<br>$$</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
      <category>Cache</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FIFO</title>
    <link href="/2023/10/29/FIFO/"/>
    <url>/2023/10/29/FIFO/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li>Clifford E. Cummings《Simulation_and_Synthesis_Techniques_for_Asynchrono.pdf》</li><li>Vijay A. Nebhrajani《异步FIFO结构》</li><li>《硬件架构的艺术》</li></ul></li></ul><hr><h2 id="1-关于FIFO"><a href="#1-关于FIFO" class="headerlink" title="1. 关于FIFO"></a>1. 关于FIFO</h2><ul><li>FIFO不需要读写地址线，顺序写入顺序读出。只有读写指针。</li><li>FIFO的深度确定<ul><li>读的速度大于写的速度：FIFO的深度为1，也可以。因为瞬间就会被读走。</li><li>写的速度大于读的速度：FIFO的深度需要确保接收方未能将发送方发送的数据接收完毕的话，剩下的数据可以存储在FIFO内部而不会溢出。当发送结束后 接收方可以从容地接收剩下的数据。</li></ul></li><li>同步 &amp; 异步 FIFO<ul><li>同步FIFO是指读写时钟为同一个时钟，在时钟沿到来时同时发生读写操作。</li><li>异步FIFO是指读写时钟不一致，两个时钟相互独立。</li></ul></li></ul><h2 id="2-同步FIFO"><a href="#2-同步FIFO" class="headerlink" title="2. 同步FIFO"></a>2. 同步FIFO</h2><ul><li><p>同步FIFO电路如下图所示。FIFO本质上是一个没有读写地址线的DPRAM。</p><p><img src="/2023/10/29/FIFO/3201119-20230717223202474-401688599.png"></p></li><li><p>在没有可以写的空间时，写指针等于RAM_SIZE-1.此时进行一个写操作时，会使写指针回滚到0，并将fifo_full信号拉高。如下图。</p><ul><li><p>因此可以很清楚的看到，当读指针和写指针相等时，不是写满就是读空。可以采用下面增加1bit MSB算法检测满&#x2F;空。</p><p><img src="/2023/10/29/FIFO/3201119-20230717223927945-843903393.png"></p></li></ul></li></ul><p>​</p><ul><li>也可以采用计数器来持续计数FIFO内空满位置的个数，直接比较计数器的值判断。<ul><li>但是该算法需要增加额外的硬件电路（比较器），尤其当FIFO深度增加时，宽度也增加。因此产生空满信号的比较器也需要更高级的序列比较器。导致FIFO的操作频率会被拉低。</li></ul></li></ul><h2 id="3-异步FIFO"><a href="#3-异步FIFO" class="headerlink" title="3. 异步FIFO"></a>3. 异步FIFO</h2><h3 id="3-1-异步FIFO电路结构"><a href="#3-1-异步FIFO电路结构" class="headerlink" title="3.1 异步FIFO电路结构"></a>3.1 异步FIFO电路结构</h3><ul><li>异步FIFO电路如下图所示。<ul><li><p>当fifo_full被拉高时，不可以往FIFO写入数据，否则会将FIFO的数据覆盖掉。</p></li><li><p>当fifo_empty被拉高时，不应该读出数据，否则会读出垃圾数据。</p><p><img src="/2023/10/29/FIFO/3201119-20230718091205557-2044425801.png"></p></li></ul></li></ul><h3 id="3-2-同步指针"><a href="#3-2-同步指针" class="headerlink" title="3.2 同步指针"></a>3.2 同步指针</h3><ul><li><p>由于读写在两个时钟域，如果需要判断是否写满或读空，需要跨时钟传输。</p></li><li><p>如果采用同步电路，则至少需要两个触发器，在下面波形可以看到：rd_ptr_sync比rd_ptr要延后两个周期，导致即使FIFO已经未满了，但是由于延迟，仍认为其为满的，出现虚满情况。</p></li><li><p>同理，将写指针同步到读时钟域上也会导致最少两个读时钟的延迟，出现即使已经向里面写数据了，但仍判断为空，出现虚空情况。</p></li></ul><p>  <img src="/2023/10/29/FIFO/3201119-20230718133418930-1697507285.png"></p><ul><li>对于数值连续的信号，可以采用格雷码进行传输，每次只翻转1bit，错误出现概率小。</li></ul><h3 id="3-3-满-空-判断方法"><a href="#3-3-满-空-判断方法" class="headerlink" title="3.3 满&#x2F;空 判断方法"></a>3.3 满&#x2F;空 判断方法</h3><ul><li><p>满&#x2F;空 判断方法</p><ul><li><p>读写地址比较</p><ul><li>对于深度为2^N的FIFO，指针宽度设置为N+1.  </li><li>当指针<strong>二进制码</strong>MSB不一致，而其它位数都相同时，则FIFO为满。</li><li>当指针二进制码所有都完全相同时，FIFO为空。</li></ul></li><li><p>实现电路结构如下图所示。采用的是3.2介绍的两级同步电路来解决跨时钟域的问题。</p><ul><li><p>首先需要一个格雷码计数器，实现如下。</p><ul><li>将格雷码转换为二进制。</li><li>根据条件递增二进制。</li><li>将二进制转为格雷码。</li></ul></li><li><p>需要将格雷码计数器输出转二进制再送去比较器产生空&#x2F;满信号。</p></li><li><p>FIFO的最大操作频率取决于格雷码计数器的速度。</p><p><img src="/2023/10/29/FIFO/3201119-20230718142842878-462284819.png"></p></li></ul></li><li><p>也可以直接根据格雷码进行判断</p><ul><li><p>判断空：所有bit全都相同。</p></li><li><p>判断满：同步后的读指针和写指针的前两bit MSB都为相反数，其余都匹配，那么为将满。</p></li><li><p>实现上面满逻辑的代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> rd_2nd_msb = rd_ptr_sync[SIZE] ^ rd_ptr_sync[SIZE-<span class="hljs-number">1</span>];<br><span class="hljs-keyword">wire</span> wr_2nd_msb = wr_gtemp[SIZE] ^ wr_gtemp[SIZE-<span class="hljs-number">1</span>];<br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> nrst)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(!nrst)<br>    fifo_full &lt;= <span class="hljs-number">1&#x27;b1</span>;<br>  <span class="hljs-keyword">else</span><br>      fifo_full &lt;= (wr_gtemp[SIZE] != rd_ptr_sync[SIZE]) &amp;&amp; (rd_2nd_msb != wr_2nd_msb) <br>                  &amp;&amp; (wr_gtemp[SIZE-<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] == rd_ptr_sync[SIZE-<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p>电路结构如下所示。</p><p><img src="/2023/10/29/FIFO/3201119-20230718164507099-627637052.png"></p></li></ul></li></ul></li><li><p>将满&#x2F;将空状态产生</p><ul><li><p>在Clifford E. Cummings的文章中提到了对将满&#x2F;将空的判断算法。注意此算法比较的是<strong>格雷码</strong>。</p></li><li><p>假设FIFO 深度为16，按照最高两bit将FIFO的地址分为四部分，根据前两bit值的大小来生成 将满&#x2F;将空 信号。</p></li><li><p>具体逻辑关系如下两张图的表达式。</p><ul><li><p>第一张图的表达式检查读指针所在象限是否大于写指针<strong>一个象限</strong>的位置，说明写地址快要追上读地址，应拉高将满信号。</p></li><li><p>第二张图的表达式检查写指针所在象限是否大于读指针<strong>一个象限</strong>的位置，说明读地址快要追上写地址，应拉高将空信号。</p></li><li><p>至于为什么下图中 <code>dirset_n</code> 和 <code>dirclr_n</code> 在判断逻辑之外还加了一个取反逻辑。</p><ul><li>可以参考 Cummings 论文中的结构，因为 direction 触发器的reset 和 clr 为低电平。</li></ul><img src="3201119-20230717221508083-2130354287.png" style="zoom:57%;" /><img src="3201119-20230718154204192-1526316347.png" style="zoom:67%;" /></li></ul></li></ul></li></ul><h2 id="4-格雷码"><a href="#4-格雷码" class="headerlink" title="4. 格雷码"></a>4. 格雷码</h2><h3 id="4-1-格雷码特点"><a href="#4-1-格雷码特点" class="headerlink" title="4.1 格雷码特点"></a>4.1 格雷码特点</h3><ul><li><p>顺序值变化时，只有1bit发生变化。</p><ul><li>二进制：0111 -&gt; 1000，所有bit都发生变化的情况。</li><li>格雷码：0101 -&gt; 0100，这样只有1bit的变化。</li></ul></li><li><p>FIFO的读写指针定义为格雷码，有个局限点：深度只能定义为2^n，否则从FIFO底端地址到FIFO顶端地址就不止1bit变化了。</p></li></ul><p>  <img src="/2023/10/29/FIFO/3201119-20230717222735526-1817794379.png"></p><h3 id="4-2-生成格雷码"><a href="#4-2-生成格雷码" class="headerlink" title="4.2 生成格雷码"></a>4.2 生成格雷码</h3><ul><li>直接排列</li></ul><table><thead><tr><th>原始值</th><th>000</th></tr></thead><tbody><tr><td>改变最右侧位元值</td><td>001</td></tr><tr><td>改变右起第一个为1的位元左边的位元</td><td>011</td></tr><tr><td>改变最右边的位元</td><td>010</td></tr><tr><td>改变右起第一个为1的位元左边的位元</td><td>110</td></tr><tr><td>改变最右边的位元</td><td>111</td></tr><tr><td>改变右起第一个为1的位元左边的位元</td><td>101</td></tr><tr><td>改变最右边的位元</td><td>100</td></tr></tbody></table><ul><li>镜射排列</li></ul><table><thead><tr><th>产生0，1两个字符串</th><th>0 - 1</th></tr></thead><tbody><tr><td>在第一步的基础上，正向每一个字符串都分别加0，然后反向迭代每个字符串加1</td><td>00 - 01-11-10</td></tr><tr><td>与上一步相同</td><td>000-001-011-010-110-111-101-100</td></tr></tbody></table><h3 id="4-3-格雷码-二进制-转换"><a href="#4-3-格雷码-二进制-转换" class="headerlink" title="4.3 格雷码 &amp; 二进制 转换"></a>4.3 格雷码 &amp; 二进制 转换</h3><ul><li><p>二进制码转格雷码</p><ul><li>保留格雷码的最高位作为二进制的最高位，次高位二进制为高位二进制与次高位格雷码相异或，其它自然二进制码与此类似。<ul><li>二进制数： $B_{n-1}B_{n-2}….B_2B_1B_0 $</li><li>对应的格雷码：$G_{n-1}G_{n-2}…G_2G_1G_0 $</li><li>其中最高位保留：$G_{n-1} &#x3D; B_{n-1} $</li><li>其它各位：$G_i &#x3D; B_{i+1}\bigoplus B_i$</li></ul></li></ul></li><li><p>格雷码转二进制码</p><ul><li>保留二进制码的最高位，次高位格雷码为二进制码的高位和次高位相异或。<ul><li>格雷码：$G_{n-1}G_{n-2}…G_2G_1G_0$</li><li>对应的二进制数： $B_{n-1}B_{n-2}….B_2B_1B_0$</li><li>其中最高位保留：$B_{n-1} &#x3D; G_{n-1}$</li><li>其它各位：$B_{i} &#x3D; G_{i}\bigoplus B_{i+1}$</li></ul></li></ul></li></ul><h3 id="4-4-格雷码计数器"><a href="#4-4-格雷码计数器" class="headerlink" title="4.4 格雷码计数器"></a>4.4 格雷码计数器</h3><ul><li><p>3.3节中有介绍可以直接根据格雷码判断空满信号。但是，计数器仍需要将格雷码转为二进制码之后再递增，之后再转换为格雷码，仍会限制整体电路的速度。</p></li><li><p>在Clifford E. Cummings的文章中，提出了下面这种可以直接实现格雷码计数器的电路。</p><ul><li><p>实现逻辑较为简单，代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//以wptr为例，rptr与此相似</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> wclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(!rst_n) <span class="hljs-keyword">begin</span><br>        wbin &lt;= <span class="hljs-number">&#x27;d0</span>;<br>        wptr &lt;= <span class="hljs-number">&#x27;d0</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        wbin &lt;= wbnext;<br>        wptr &lt;= wgnext;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">assign</span> wbnext = !wfull ? wbin+winc : wbin;<br><span class="hljs-keyword">assign</span> wgnext = (wbnext&gt;&gt;<span class="hljs-number">1</span>) ^ wbnext;<br></code></pre></td></tr></table></figure></li></ul><img src="3201119-20231221220239492-1337729734.png" style="zoom:67%;" /></li></ul><p>​        </p>]]></content>
    
    
    <categories>
      
      <category>硬件设计基础</category>
      
      <category>CDC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cache-直接映射缓存&amp;多路组连缓存</title>
    <link href="/2023/10/29/Cache-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E7%BC%93%E5%AD%98&amp;%E5%A4%9A%E8%B7%AF%E7%BB%84%E8%BF%9E%E7%BC%93%E5%AD%98/"/>
    <url>/2023/10/29/Cache-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E7%BC%93%E5%AD%98&amp;%E5%A4%9A%E8%B7%AF%E7%BB%84%E8%BF%9E%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/102293437">https://zhuanlan.zhihu.com/p/102293437</a></li><li>公众号：老秦谈芯</li><li>《计算机组成与设计 第五版》</li></ul></li></ul><hr><h2 id="1-Cache-line"><a href="#1-Cache-line" class="headerlink" title="1. Cache line"></a>1. Cache line</h2><ul><li>cache size：这里只考虑cache可以缓存最大<strong>数据</strong>的大小。这里忽略了tag和valid bit的占用。</li><li>将cache均分相等的块，每一块称为cache line，现在的硬件设计中，一般cache line的大小为4-128字节，cache line做的太小会导致tag资源占用过大。</li><li><strong>cache line 是 cache 和主存之间数据传输的最小单位。</strong><ul><li>考虑到程序的空间局部性：即一个数据被访问了，那么它周围的数据在之后也有可能被访问。所以cache会选择连续一段数据公用一个tag，一起被传输。 </li><li>在cache缺失时，即使CPU只需要从主存中读1个字节的数据出来，但是还是会直接load出8（该值为设定的cache line大小）个字节填充整个cache line。</li></ul></li><li>Cache line size 的选择<ul><li>size指的是offset的大小，也就是Cache line的容量。</li><li>size增大，失效率一般会下降（更大程度的挖掘空间局部性）。</li><li>但是当Cache line size占cache容量比例增加到一定程度，失效率会随之上升。原因如下： <ul><li>上面所描述的情况会导致Cache中可存放的cache line数变少了，会导致数据经常被挤走。</li><li>cache line的size不断增大，导致各字之间的空间局部性也会降低，失效率的收益不断减小。</li><li>失效损失增大，失效损失主要指从主存中读取数据并加载到cache的时间，size不断增大，导致传输时间也不断增大。</li></ul></li></ul></li></ul><h2 id="2-Cache控制器怎么确定是否命中"><a href="#2-Cache控制器怎么确定是否命中" class="headerlink" title="2. Cache控制器怎么确定是否命中"></a>2. Cache控制器怎么确定是否命中</h2><ul><li>首先假设cache 大小为64Bytes，cache line大小为8Bytes。假设CPU想从地址为0x0654地址取一个字节数据。</li><li>考虑cache line大小为8Bytes，使用地址低3bit来寻址其中的一个字节。(offset[2:0])</li><li>计算可得有8个cache line，可以使用3bit地址来寻址是哪个cacheline。(index[5:3])</li><li>对于一个地址，即使确定了[5：3]bit，也不能就确信找到了正确的地址，还有更高位数信息。<ul><li>cache将高位信息用tag表示， tag、index、offset可以确定唯一的那个地址。</li></ul></li><li>检查是否命中：首先根据index找到cacheline，然后将cache的tag与地址的tag比对，如果相等，说明命中，如果不等，说明缺失。</li></ul><p><img src="/2023/10/29/Cache-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E7%BC%93%E5%AD%98&%E5%A4%9A%E8%B7%AF%E7%BB%84%E8%BF%9E%E7%BC%93%E5%AD%98/3201119-20230609140440924-1848801620.png"></p><ul><li>valid bit<ul><li>tag 前面还加了一位valid bit，首先判断该位，判断缓存中的数据是否有效，若无效不用判断是否命中，直接缺失。</li><li>目的：考虑一些情况如：处理器刚启动时，cache中没有有效数据，对比是无用的。以及运行过程中，cache的一些cacheline可能还是空的，对比也是无用的。</li></ul></li><li>Cache 失效的处理<ul><li>这里以指令Cache失效为例。<ul><li>对于按序处理器，Cache失效，需要停顿流水线等待内存返回数据。<ul><li>对于乱序处理器，Cache失效，在等待cache失效处理时允许继续执行指令，更为复杂，这里暂不讨论。</li></ul></li><li>将PC值-4发送给内存。<ul><li>考虑到程序计数器是在执行的第一个时钟周期递增的，所以引发指令Cache失效的指令地址等于当前PC-4。</li></ul></li><li>对主存进行读操作，等待主存完成本次访问。</li><li>写Cache line，将内存获取的数据写入，将高位填充到tag字段，将有效位拉高。</li><li>重启指令执行，重新取指，此次取指将会在指令cache中命中。</li></ul></li><li>数据Cache控制本质和上面相同，失效也需要短暂的暂停处理器，直到内存返回数据给Cache。</li></ul></li></ul><h2 id="3-直接映射缓存的优缺点"><a href="#3-直接映射缓存的优缺点" class="headerlink" title="3. 直接映射缓存的优缺点"></a>3. 直接映射缓存的优缺点</h2><ul><li>优点：硬件设计更简单、成本低。</li><li>缺点：cache thrashing（cache 颠簸）<ul><li>与上面假设相同，此时cpu想依次访问0x00，0x40，0x80地址的数据，这三个对应的index和offset都是一个，唯一区别是tag值。</li><li>访问0x00时，cache缺失，cpu从主存中load出8个字节大小的数据填充cache line。</li><li>访问0x40时，索引到第0行cacheline，但这里存的是0x00对应的数据，仍缺失，再加载0x40地址的数据。</li><li>依次类推，0x80也要经过刚才两步：缺失+从主存中load。</li><li>这样cache对性能没什么提升。</li></ul></li><li>为了解决这个问题，引入了多路组相连缓存。</li></ul><h2 id="4-两路组相连缓存"><a href="#4-两路组相连缓存" class="headerlink" title="4. 两路组相连缓存"></a>4. 两路组相连缓存</h2><ul><li>假设cache 大小为64Bytes，cache line大小为8Bytes。假设CPU想从地址为0x0654地址取一个字节数据。<ul><li>一共有8个cache line，将一路改成两路4个cache line。</li><li>offset依然是3bit，index只需要2bit即可。</li><li>找到某行index，对应两个cache line。然后将两个cache line对应的tag与地址部分的tag进行对比。</li></ul></li><li>下图中，Tag的比较和Data SRAM的数据读取是并行的，可以增加cache读取速度。<ul><li>也可以串行，先比较Tag，再根据Tag比较结果去访问Data SRAM。</li></ul></li></ul><p><img src="/2023/10/29/Cache-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E7%BC%93%E5%AD%98&%E5%A4%9A%E8%B7%AF%E7%BB%84%E8%BF%9E%E7%BC%93%E5%AD%98/3201119-20230807213451864-968491639.png"></p><ul><li>缺点<ul><li>硬件成本更高，每次比较tag要比较多个cacheline对应的tag。</li></ul></li><li>优点<ul><li>可以降低cache颠簸可能性。前面提到的问题，0x00和0x40可以被加载到不同的路中。</li></ul></li></ul><h2 id="5-全相连缓存"><a href="#5-全相连缓存" class="headerlink" title="5. 全相连缓存"></a>5. 全相连缓存</h2><ul><li>取消index信号，每个cache line占一个way。其实就相当于不考虑offset的3bit，其余地址一个一个放在表中的一条一条上，在这个表里挨个查，显而易见只适合小容量的cache。</li><li>此时查找是否命中，需要将地址的tag与所有组的tag进行比较。</li><li>因为不存在index，任意数据可以存在任意位置，可以最大程度降低cache的颠簸性。</li><li>硬件成本最高。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
      <category>Cache</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Cache</title>
    <link href="/2023/10/29/%E5%85%B3%E4%BA%8ECache/"/>
    <url>/2023/10/29/%E5%85%B3%E4%BA%8ECache/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/102293437">https://zhuanlan.zhihu.com/p/102293437</a></li><li><a href="https://zhuanlan.zhihu.com/p/102326184">https://zhuanlan.zhihu.com/p/102326184</a></li><li>公众号：老秦谈芯</li></ul></li></ul><hr><ul><li>后续有时间的情况下，可以阅读《计算机组成与设计-硬件软件接口》第五章的内容，对写的博客进行补充。</li></ul><hr><h2 id="1-为什么需要Cache"><a href="#1-为什么需要Cache" class="headerlink" title="1. 为什么需要Cache"></a>1. 为什么需要Cache</h2><ul><li>运行一个进程的步骤（假设为一个变量a加1）<ul><li>首先从磁盘（辅存）中读出可执行程序，并将其load到主存储器中。</li><li>CPU从主存储器中读出地址为A的数据发到CPU的通用寄存器中。</li><li>将通用寄存器的值加1.</li><li>CPU再将通用寄存器的值写给主存储器。</li></ul></li><li>上面的步骤中，第三步的速度很快，但是第二步和第四步，与主存的交互很慢。为了解决这个问题，使用一块速度极快但是容量小的存储设备：cache meomory。</li></ul><p><img src="/2023/10/29/%E5%85%B3%E4%BA%8ECache/3201119-20230609101424628-456798622.png"></p><ul><li>将Cache放在CPU和主存之间，作为主存数据的缓存，当CPU想从主存中取数据会首先检查Cache中是否有对应地址的数据，如果有的话就可以直接取出给CPU使用。</li></ul><h2 id="2-多级Cache存储结构"><a href="#2-多级Cache存储结构" class="headerlink" title="2. 多级Cache存储结构"></a>2. 多级Cache存储结构</h2><ul><li>Cache不可避免的需要在容量和速度之间进行平衡，但是即使多级Cache的速度仍比主存要快的多.</li><li>以Cortex-A53为例，三级Cache分布如下<ul><li>每个CPU都有一个L1 Cache，L1 Cache会分为单独的ICache（指令）和DCache（数据）。<ul><li>ICache和DCache本质是一样的，L1 Cache单独分开的原因：<ul><li>CPU执行时，可以同时从两个Cache中获取指令和数据，做到硬件上的并行，提升性能。</li><li>DCache不仅需要考虑读出还要考虑写入的问题；而ICache只会被读取。分开两个电路设计，为了更快！</li></ul></li><li>L1 Cache是最接近处理器的，要求其与CPU有近似的速度，也就注定了其容量不能太大，一般使用SRAM实现。</li><li>L1 Cache中，ICache和DCache的大小一般32-64KB，2-4个时钟周期访问时间。</li></ul></li><li>一个Cluster内所有的CPU都共享一个L2 Cache。<ul><li>L2 Cache是指令和数据共享，速度可以比CPU慢一些，主要功能是尽量保存更多的内容。</li><li>一般也是SRAM实现，大小为256KB-2MB，10-20个时钟周期的访问时间。<ul><li>虽然与L1一样都是SRAM实现，但是L1的SRAM设计是为了速度进行优化，采用更复杂更大更多的晶体管，因此成本和功耗都增加了不少。</li></ul></li></ul></li><li>所有的Cluster之间共享L3 Cache。而L3 Cache通过总线与主存相连。 <ul><li>在一些系统设计中，L3 cache及更高级采用的是DRAM设计，成本更低。</li><li>L3 Cache一般大小为8-80MB，20-50个时钟周期的访问时间。</li></ul></li></ul></li><li>注意：上面描述的多个cluster就有多个二级缓存，那么就牵扯到<strong>缓存一致性</strong>的问题，后面会介绍。</li></ul><h2 id="3-多级Cache之间的配合"><a href="#3-多级Cache之间的配合" class="headerlink" title="3. 多级Cache之间的配合"></a>3. 多级Cache之间的配合</h2><ul><li>inclusive cache（一个地址的数据可以存在多级缓存中）<ul><li>CPU想获取主存某地址的数据时，首先先访问L1 Cache，看是否命中，如果命中直接返回数据给GPU。</li><li>如果L1 Cache缺失，则会在L2 Cache中继续寻找，如果找到，那么会把数据返回给L1和CPU.(返回给L1是为了下次可以在L1的时候就命中)。</li><li>同理，L2找不到去找L3，找到返回L1,L2，CPU。</li><li>如果 L3也缺失，CPU只能去主存储器中找数据，找到返回给L1,L2,L3,CPU。</li></ul></li><li>exclusive cache：某一地址的数据只能存在于多级Cache中的一级。</li></ul><h2 id="4-Cache对代码的影响"><a href="#4-Cache对代码的影响" class="headerlink" title="4. Cache对代码的影响"></a>4. Cache对代码的影响</h2><ul><li>首先看两端代码片段<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int arr[<span class="hljs-number">10</span>][<span class="hljs-number">128</span>]<span class="hljs-comment">;</span><br><br>for (i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 10; i++)</span><br>        for (j <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; 128; j++)</span><br>                arr[i][j] <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int arr[<span class="hljs-number">10</span>][<span class="hljs-number">128</span>]<span class="hljs-comment">;</span><br><br>for (i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 128; i++)</span><br>        for (j <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; 10; j++)</span><br>                arr[j][i] <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>假设cache line的大小是64字节</li><li>首先分析第一段代码<ul><li>cache控制器发现arr[0][0]缺失，便从主存中取出arr[0][0]到arr[0][15]（int数据类型占4个字节）。对于arr[0][1]-[15]来说就命中了。</li><li>之后到arr[0][16]时，又缺失，便又会在主存那里load出16个数据，64个字节。</li><li>这种情况得命中率还是较高的。</li></ul></li><li>分析第二段代码<ul><li>cache控制器发现arr[0][0]缺失，便从主存中取出arr[0][0]到arr[0][15]，之后读第二个数据arr[1][0]，结果发现又缺失了，依次类推。</li><li>当访问到arr[0][1]时，需要考虑cache的大小，如果大于数组arr的大小，那么经过前面的一系列缓存，arr[0][0]- arr[9][15]都被缓存下来，与第一段代码差不多的命中率。</li><li>但是如果cache的大小小于数组的大小，那么第二段代码的命中率就没有第一段高，自然要消耗更多的时间从主存中load数据。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
      <category>Cache</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FIR - IIR 滤波器</title>
    <link href="/2023/10/28/FIR%20&amp;%20IIR%20%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2023/10/28/FIR%20&amp;%20IIR%20%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://www.cnblogs.com/alifpga/p/7902759.html">https://www.cnblogs.com/alifpga/p/7902759.html</a></li><li><a href="https://www.zhihu.com/question/323353814">https://www.zhihu.com/question/323353814</a></li></ul></li></ul><hr><h2 id="1-FIR-物理意义"><a href="#1-FIR-物理意义" class="headerlink" title="1. FIR 物理意义"></a>1. FIR 物理意义</h2><ul><li>滤波，就是输入信号频率 X(f) 和期望的频率特征函数 H(f) 进行相乘；这是在频域的计算。那么在时间域，是做了一个卷积的计算。</li><li>因此FIR做的就是将各个时刻的输入和对应的权重参数相乘，并叠加之后输出。<ul><li>如下图所示，为一N点的FIR滤波器。满足$ y(n) &#x3D; \sum\limits_{k&#x3D;0}^{N-1}h(k)x(n-k)$</li></ul></li></ul><p><img src="/2023/10/28/FIR%20&%20IIR%20%E6%BB%A4%E6%B3%A2%E5%99%A8/3201119-20230718173257360-1137724047.png"></p><ul><li>由于FIR每一时刻的输出都取决于之前有限个输入，因此是“有限冲激响应”。</li></ul><h2 id="2-IIR-物理意义"><a href="#2-IIR-物理意义" class="headerlink" title="2. IIR 物理意义"></a>2. IIR 物理意义</h2><ul><li>IIR 滤波器设计的基本方法<ul><li>先设计一个合适的模拟滤波器，然后利用复值映射把模拟滤波器变换成数字滤波器。</li></ul></li><li>模拟原型滤波器<ul><li>有 巴特沃斯滤波器、切比雪夫滤波器、贝塞尔滤波器、椭圆滤波器等。</li><li>之后有时间会进行更详细的学习。</li></ul></li><li>模拟滤波器到数字滤波器的变换<ul><li>主要有两种方法<ul><li>脉冲响应不变法：从时域响应出发，让数字滤波器的单位脉冲响应h(n)模仿模拟滤波器的单位冲激响应ha(t)，h(n)等于ha(t)的取样值。  </li><li>双线性变换法：从频率响应出发，让数字滤波器的频率响应逼近模拟滤波器的频率响应，进而求得数字滤波器得系统函数。</li></ul></li></ul></li><li>无限冲激响应的理解<ul><li>首先看IIR滤波器表达式:<br>$$<br> y[n] &#x3D; a_0x[n]+a_1x[n-1]+a_2x[n-2]+a_3x[n-3]+…<br> +b_1y[n-1]+b_2y[n-2]+b_3y[n-3]+…<br>$$<ul><li>可以看到该公式是存在一个递归关系的，本步的计算结果会作为下一步的输入，无限递归下去。</li></ul></li><li>由于IIR是由模拟滤波器变换得到的，以下面滤波器为例。<ul><li><p>当给输入一个电压值（给输入一个冲激信号），电容会被充电，但是当电压值取消后，电容的电荷会被逐渐放掉，但是理论上永远不会变成0，导致输入会在无限长的时间产生影响。</p><p><img src="/2023/10/28/FIR%20&%20IIR%20%E6%BB%A4%E6%B3%A2%E5%99%A8/3201119-20230718224246063-1237397880.png"></p></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>I2S协议</title>
    <link href="/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li>NXP 《I2S bus specification》</li><li>NXP 《I2S在Kinetis上的应用   》</li><li><a href="https://www.python100.com/html/R62183SDTAU0.html">https://www.python100.com/html/R62183SDTAU0.html</a></li><li><a href="https://blog.51cto.com/u_15459030/5225825">https://blog.51cto.com/u_15459030/5225825</a></li></ul></li></ul><hr><h2 id="1-I2S概述"><a href="#1-I2S概述" class="headerlink" title="1. I2S概述"></a>1. I2S概述</h2><h3 id="1-1-为什么需要I2S"><a href="#1-1-为什么需要I2S" class="headerlink" title="1.1 为什么需要I2S"></a>1.1 为什么需要I2S</h3><ul><li>I2S是I2C的变种，全称：InterIc-Sound. 专门为传输音频数据而设计的。</li><li>I2S 相较于I2C和SPI有以下优点<ul><li>更低的延迟：由于I2S数据传输是连续的，不需要等待ACK信号的回复，I2S只需要使用WS和SCK信号进行数据的同步；响应速度更快。</li><li>更高的精度：I2C一次可以传输8位的数据，但是I2S可以传输16&#x2F;24位的数据，对于高精度的音频设备，I2S能够满足要求。</li></ul></li></ul><h3 id="1-2-I2S-三条总线"><a href="#1-2-I2S-三条总线" class="headerlink" title="1.2 I2S 三条总线"></a>1.2 I2S 三条总线</h3><ul><li><p>之前介绍I2C有两条总线:SCL&#x2F;SDA。而I2S有三条总线如下。</p><ul><li>SCK(Continuous Serial Clock)：串行时钟，也称为位时钟BCLK。<ul><li>SCK的时钟频率 &#x3D; 声道数 * 采样频率 * 采样位数。</li></ul></li><li>WS(Word Select)：字段（声道）选择信号，也称为帧时钟LRCK。<ul><li>其频率等于采样频率。</li><li>在<strong>I2S模式下</strong>：WS&#x3D;1，表示传递的是右声道数据。WS&#x3D;0，表示传递的是左声道数据。后面有介绍，其它模式不同。</li></ul></li><li>SD(Serial Data)：串行数据。</li></ul></li><li><p>控制器（Controller）产生SCK信号和WS信号，控制器可以是Transmitter也可以是Receiver，也可以是单独设计的控制模块。</p><p><img src="/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/3201119-20230724112142940-41134477.png"></p></li></ul><h3 id="1-3-I2S的三种操作模式"><a href="#1-3-I2S的三种操作模式" class="headerlink" title="1.3 I2S的三种操作模式"></a>1.3 I2S的三种操作模式</h3><ul><li><p>图片来自TI的TLV320AIC3104的数据表，其中WCLK为LRCLK信号，BCLK为SCK信号。</p></li><li><p>无论哪种模式，串行数据都是以二进制补码进行传输的，且先传输MSB，LSB的位置取决于I2S的位宽，长会被截断，短会被补零。</p></li><li><p>根据下面的波形可以看到：I2S模式，WS&#x3D;0-&gt;左，WS&#x3D;1-&gt;右;而左对齐和右对齐和I2S模式规定相反。</p></li><li><p>不同的模式决定了解码方式也不同。</p></li><li><p>根据SD和WCLK情况可分为三种模式：  </p><ul><li><p>I2S模式</p><ul><li>在WCLK下降沿之后的一个BCLK周期的上升沿采到的数据有效。</li><li>WCLK在BCLK下降沿变化，发送方在BCLK下降沿改变数据，而接收方在BCLK上升沿采样数据。</li></ul><p><img src="/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/3201119-20230724144906940-1187645121.png"></p></li><li><p>左对齐模式</p><ul><li>相较于I2S模式，没有延迟一个BCLK周期。</li><li>不需要关心数据的长度，只会对LSB进行处理，截取&#x2F;补零；但是MSB不会有问题。</li><li>发送方在BCLK下降沿改变数据，而接收方在BCLK上升沿采样数据。</li></ul><p><img src="/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/3201119-20230724145852016-1096610293.png"></p></li><li><p>右对齐模式</p><ul><li>不足：接收设备需要事先知道传输数据的长度，否则可能会导致MSB被截断</li></ul><p><img src="/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/3201119-20230724162951792-210572944.png"></p></li></ul></li><li><p>对于I2S模式和左对齐模式，可以允许发送端和接收端数据长度不同，因为接收端和发送端可以进行相应的截断和补0.</p><ul><li>为了保证数据音频信号的正确传输，发送端和接收端最好使用相同的数据格式和长度。</li></ul></li></ul><h2 id="2-I2S-应用"><a href="#2-I2S-应用" class="headerlink" title="2. I2S 应用"></a>2. I2S 应用</h2><ul><li>注意：这里只讨论I2S模式，不讨论左对齐&#x2F;右对齐模式。</li><li>讨论基于DMA和中断的乒乓缓冲区方案，旨在降低用于处理音频数据流的CPU开销。</li><li>为什么需要该方案<ul><li>采样率一般会在8KHz-48KHz之间，甚至可以更高。如果使用CPU去处理每个中断，那么系统效率会非常低。</li><li>另外大部分的音频算法会累积音频流中的数据形成缓冲数据块，之后再对缓存数据块进行处理。</li></ul></li></ul><h3 id="2-1-方案概述"><a href="#2-1-方案概述" class="headerlink" title="2.1 方案概述"></a>2.1 方案概述</h3><ul><li>具体方案结构框图如下图所示。<ul><li>其中R和L分别代表右通道&#x2F;左通道。每个通道都有用于乒乓操作的两个缓冲区（红色和黑色）。<ul><li>乒乓相关知识可以看<a href="https://www.cnblogs.com/qianbinbin/p/17482594.html">这篇博客</a>。</li></ul></li><li>我对框图的工作模式理解是<ul><li>前面介绍，缓冲区被划分为四块；我们这里看红色和黑色两部分。红色部分我们使用DMA将其传送到I2S TX模块。<ul><li>根据要求假设N为缓冲区中采样数据数量，DMA传送了N个采样数据之后，DMA会向CPU发起一个中断。</li></ul></li><li>中断期间，CPU执行音频解码算法之后获得的输出数据，并将输出数据填充到缓冲区。</li><li>可以看到存在一个乒乓的工作模式：<ul><li>T1：中断：CPU计算完成，将数据送到缓冲区R_TX0。与此同时DMA在搬移R_TX1的数据。</li><li>T2：DMA搬移结束后再次触发中断，此时DMA继续搬移R_TX0中的数据。CPU完成计算，并将数据送到缓冲区R_TX1中。</li><li>依次类推，形成乒乓的工作模式。</li></ul></li></ul></li><li>注意：考虑到音频信号具有较强的实时性要求，因此，所有计算都必须在下个中断发生之前完成，否则会导致系统故障。</li></ul></li></ul><p><img src="/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/3201119-20230724200700025-1774790489.png"></p><h3 id="2-2-I2S-的-FIFO-特性"><a href="#2-2-I2S-的-FIFO-特性" class="headerlink" title="2.2 I2S 的 FIFO 特性"></a>2.2 I2S 的 FIFO 特性</h3><ul><li>I2S 的 FIFO 从DMA中读数据，FIFO中的数据会交替发送到左右通道；判断依据可选择FIFO中是否存在空数据。<ul><li><p>如下图所示，当FIFO的空数据计数为2时，就会让DMA加载一条数据进入左通道，一条数据进入右通道。  </p><p><img src="/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/3201119-20230724220704113-1334935146.png"></p></li></ul></li></ul><h3 id="2-3-DMA-和中断-配置"><a href="#2-3-DMA-和中断-配置" class="headerlink" title="2.3 DMA 和中断 配置"></a>2.3 DMA 和中断 配置</h3><ul><li>2.1节中有介绍到DMA和中断CPU处理之间的乒乓工作模式。下面会依据实例详细介绍。</li><li>下图可以看到，共有四个数据块，每个数据块有四个采样，每个采样都有四个字节。<ul><li>DMA的访问顺序是左右通道交叉，如：0x00,0x20,0x04,0x24…</li></ul></li><li>乒乓操作实现<ul><li>当DMA读取地址经过0x00,0x20…到达0x2c时，TX0内的所有数据都已经发送完毕，发起一个中断。</li><li>随后，CPU进行算法计算，并将数据填充到BLOCK0和BLOCK2中；与此同时，DMA处理BLOCK1和BLOCK3。</li><li>当DMA到达地址0x3c时，会发起另一个中断。</li><li>随后，CPU进行算法计算，并将数据填充到BLOCK1和BLOCK3中；与此同时，DMA处理BLOCK0和BLOCK2。</li></ul></li></ul><img src="3201119-20230724221806028-635573909.png" width = 60%/>  ]]></content>
    
    
    <categories>
      
      <category>串行接口通信协议</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>I2C协议（一）</title>
    <link href="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/362287272">https://zhuanlan.zhihu.com/p/362287272</a></li><li><a href="https://zhuanlan.zhihu.com/p/282949543">https://zhuanlan.zhihu.com/p/282949543</a></li><li><a href="https://blog.csdn.net/zhangduang_KHKW/article/details/121953275">https://blog.csdn.net/zhangduang_KHKW/article/details/121953275</a></li></ul></li></ul><hr><ul><li>波形文件来自NXP的IIC user manual.</li></ul><hr><h2 id="1-I2C-用来做什么？"><a href="#1-I2C-用来做什么？" class="headerlink" title="1. I2C 用来做什么？"></a>1. I2C 用来做什么？</h2><ul><li>全称：Inter-Integrated Circuit.</li><li>一个双向，两线（SCL&#x2F;SDA）制总线协议；用于主控器件和外围设备器件互联通信。简化PCB布线，降低成本。</li><li>I2C是一种多主机总线，所以也提供了仲裁功能，仲裁相关内容见<a href="https://www.cnblogs.com/qianbinbin/p/17489279.html">这篇博客</a>。</li></ul><h2 id="2-I2C-的5种速率模式"><a href="#2-I2C-的5种速率模式" class="headerlink" title="2. I2C 的5种速率模式"></a>2. I2C 的5种速率模式</h2><ul><li>对于不同的器件使用不同的模式，一共有5种模式，具体可看<a href="https://zhuanlan.zhihu.com/p/362287272">这篇文章</a>.</li></ul><h2 id="3-通信过程"><a href="#3-通信过程" class="headerlink" title="3. 通信过程"></a>3. 通信过程</h2><ul><li>（1）当总线空闲时，SDA和SCL都处于高电平状态。</li><li>（2）当主设备决定开始通讯时，需要<strong>首先发送开始信号</strong> 。</li><li>（3）发送从机设备的地址（7 bits）以及1bit数据传送方向（R&#x2F;W）；一共8bit，一个字节大小的数据。</li><li>（4）被寻址的从机发送应答信号给主机。</li><li>（5）发送器送出一个字节的数据，接收器收到完毕返回一个应答信号给主机。（发送器和接收器根据（3）中指定的传送方向分别选择为主机&#x2F;从机）。</li><li>（6）重复（5）直到通信完成后，主机发送停止信号释放总线。</li><li>注意：<strong>发送数据过程中不可以改变数据传送方向，在（3）那步指定之后就不可更改。</strong>除非重启通信。</li></ul><h2 id="4-I2C的基础信号"><a href="#4-I2C的基础信号" class="headerlink" title="4. I2C的基础信号"></a>4. I2C的基础信号</h2><ul><li><p>起始、停止、应答和非应答信号。</p><ul><li>起始信号：SCL处于高电平时，SDA从高电平到低电平变化，为起始信号。</li><li>停止信号：SCL处于高电平时，SDA从低电平到高电平变化，为停止信号。</li></ul><p><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/3201119-20230618154435605-1791635155.png"></p><ul><li>应答信号：其出现在一个字节传输完成之后，第9个SCL时钟周期内，SDA总线的控制权从主机给到从机，SDA总线由于上拉电阻的原因为高，如果从机正确的收到了数据，那么会将SDA拉低。<ul><li>主机发现SDA被拉低之后，可以选择下一步操作（发下一字节的传输&#x2F;停止传输）。</li><li>需要注意，应答信号是接收设备给发送设备的反馈信号，而并不一定是从机给主机的反馈信号。</li></ul></li></ul><p><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/3201119-20230618155923953-611387111.png"></p><ul><li>非应答信号：第9个SCL时钟周期，SDA保持高电平，表示非应答，主机就需要发送停止信号，结束通信。以下情况可能会出现非应答：<ul><li>主机指定的地址，I2C总线上没有对应地址的从机设备。</li><li>主机发送从机地址，希望通信时；从机正忙，没办法通信。</li><li>主机接收从机发送的数据，主机产生非应答信号，告诉从机不要再发数据了，传输结束了。</li></ul></li></ul></li><li><p>数据有效性</p><ul><li>I2C在进行数据传送时，在SCL为低电平时发送器向SDA上送1bit数据，此时SDA可以发生变化；在SCL为高电平时，接收器从SDA上采样1bit数据，SDA需要保持稳定。</li></ul></li></ul><p><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/3201119-20230618154320356-1776344245.png"></p><ul><li>I2C传输的一帧有9位信号，包括一个字节的传输信号和1bit的应答&#x2F;非应答信号。对于第一笔主机发送从机的传输包括（地址7bits + 传输方向1bit）+ 1bit应答信号。<ul><li>对于1字节的数据，先发送高位，再传送低位。</li></ul></li><li>前面介绍的SCL和SDA高低电平判断有些混乱，这里做一下总结。<ul><li>在开始和结束的判断，需要判断SCL信号为高电平时，SDA的变化。</li><li>在采样SDA时，需要判断SCL信号是否为高电平&#x2F;低电平采样。</li><li>在判断应答&#x2F;非应答，需要在SCL为高电平时，判断SDA信号是否被拉高&#x2F;拉低。</li></ul></li></ul><hr><p>如有问题，请指正！！ </p>]]></content>
    
    
    <categories>
      
      <category>串行接口通信协议</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>I2C协议（二）</title>
    <link href="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/zhangduang_KHKW/article/details/121953275">https://blog.csdn.net/zhangduang_KHKW/article/details/121953275</a></li><li><a href="https://blog.csdn.net/u010027547/article/details/47779975">https://blog.csdn.net/u010027547/article/details/47779975</a></li><li><a href="https://blog.csdn.net/NeoZng/article/details/128486366">https://blog.csdn.net/NeoZng/article/details/128486366</a></li><li><a href="https://www.cnblogs.com/DoreenLiu/p/14297191.html">https://www.cnblogs.com/DoreenLiu/p/14297191.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/388835566?utm_id=0">https://zhuanlan.zhihu.com/p/388835566?utm_id=0</a></li></ul></li></ul><hr><h2 id="1-仲裁机制"><a href="#1-仲裁机制" class="headerlink" title="1. 仲裁机制"></a>1. 仲裁机制</h2><ul><li>I2C是一个多主机的通信协议，那么就会出现 多个主机都申请SDA总线权限发送开始信号和从机地址 的情况，这就需要仲裁机制。</li></ul><h3 id="1-1-SCL的同步"><a href="#1-1-SCL的同步" class="headerlink" title="1.1 SCL的同步"></a>1.1 SCL的同步</h3><ul><li>这里以两个主机为例，可以拓展到多个主机上。目的：多个主机产生一个可公用的时钟。</li><li>两个主机的时钟频率不同，相位不同，使用时钟同步机制如下图所示：<ul><li>总线空闲时，SCL被上拉电阻拉高，当开始通信时，CLK1首先变成低电平，SCL也变成低电平，CLK2看到SCL拉低，便自己也拉低，并开始<strong>计数</strong>到CLK2虚线（原本应该拉低的位置）。</li><li>CLK2的低电平时间比CLK1要长，所以CLK1从拉高开始<strong>计数</strong>到CLK2和CLK1同时拉高（此时SCL也被拉高）的位置。 </li><li>至此，CLK1获得了需要延长的低电平时间，CLK2获得了需要减短的高电平时间，都是通过前面计数得到的。CLK1和CLK2可以根据计数值进行调整，完成时钟的同步。</li></ul></li></ul><p><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230618163225074-2122545585.png"></p><h3 id="1-2-时钟扩展"><a href="#1-2-时钟扩展" class="headerlink" title="1.2 时钟扩展"></a>1.2 时钟扩展</h3><ul><li>目的：I2C可以动态的调整总线的通信速率。</li><li>时钟扩展是从机发起的。<ul><li><a href="https://www.cnblogs.com/qianbinbin/p/17488308.html">这篇博客</a>介绍了非应答信号，即从机正忙，没办法通信。SCL是正常由主机控制，在SCL为高电平时，主机采到第9个SCL周期，SDA为高，此时为非应答；主机就会发起停止信号，结束通信。</li><li>现在想要即使出现非应答也可以等待从机忙完之后可以继续传输的情况，可以对SCL信号做处理，如下。</li></ul></li><li>时钟扩展在基于上面描述，增加了从机可以控制SCL信号的硬件电路，从机在第9个SCL周期将SCL拉低，由于正忙，没办法接收处理传输的数据；主机检测到SCL被拉低，便会进入等待状态。等待从机忙完可以处理时，将SCL释放（I2C两条总线都接了上拉电阻，默认是高电平）并返回主机ACK信号，主机可以进行下一步的操作。</li></ul><h3 id="1-3-SDA仲裁"><a href="#1-3-SDA仲裁" class="headerlink" title="1.3 SDA仲裁"></a>1.3 SDA仲裁</h3><ul><li>**”线与逻辑”**，在SCL为高电平时，SDA的数据等于各个主机的数据相与；每个主机将自己的数据和SDA上的数据进行比对，如果不一致，便知道失去了仲裁，就不再向SDA写数据。</li><li>如果两个主机都是向相同地址从机发起通信，那么仲裁继续，直到后续的数据位决定总线的归属权。</li><li>这种仲裁方式并不会破坏数据的有效性，因为总是有主机可以进行通信，且数据不会被改变。但这种仲裁方式无法提前设定主机的优先级。</li></ul><p><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230618163641198-821963823.png"></p><h2 id="2-读写时序"><a href="#2-读写时序" class="headerlink" title="2. 读写时序"></a>2. 读写时序</h2><ul><li>相同传送方向，不需要每次传输主机都发送开始信号。</li></ul><p><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230618183803454-485534870.png"></p><ul><li><p>主机写给从机</p><ul><li>其中器件地址为slave地址信息，而字地址为读&#x2F;写从机内部存储单元的地址信息。</li></ul><p><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230903220933713-114181872.png"></p></li><li><p>主机读从机数据</p><ul><li><p>当前地址读 </p><ul><li>I2C在读写操作之后，内部的地址指针自动加1，因此当前地址读不需要再次发送从机内部存储单元地址信息了。</li></ul><p><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230903221220802-876809426.png"></p></li><li><p>随机地址读</p><ul><li>如下图所示，需要先Start Bit、发送slave地址，并设置传输为写方向；之后发送内部寄存器地址。这个过程称为Dummy Write.</li><li>之后再次重新发送Start Bit、slave地址，并设置传输为读方向。从机应答，从机发送8bit数据。</li><li>为什么需要<strong>Dummy Write</strong>？因为是随机读，我们需要让从机存储单元的地址指针指向随机读取的地址，所以可以先进行Dummy Write，让存储单元的地址指针指向随机读的地址，等待从机应答后，就可以读取数据了。</li></ul></li></ul><p><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230903213717676-1981068318.png"></p></li><li><p>主机读后写&#x2F;写后读</p><ul><li>传输过程中，改变传送方向，不需要主机发送停止信号释放总线，只需要重新发送开始信号就可以。</li></ul></li></ul><p><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230618184525407-257373124.png"></p>]]></content>
    
    
    <categories>
      
      <category>串行接口通信协议</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>串行接口通信协议-概述</title>
    <link href="/2023/10/28/%E4%B8%B2%E8%A1%8C%E6%8E%A5%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/10/28/%E4%B8%B2%E8%A1%8C%E6%8E%A5%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/Rocher_22/article/details/116590629">https://blog.csdn.net/Rocher_22/article/details/116590629</a></li></ul></li></ul><hr><h2 id="1-串行通信-并行通信"><a href="#1-串行通信-并行通信" class="headerlink" title="1. 串行通信 &amp; 并行通信"></a>1. 串行通信 &amp; 并行通信</h2><ul><li>串行通信：利用一条传输线将数据位一位一位的传送。</li><li>并行通信：利用多条传输线将一个数据的多bit同时传送。</li><li>串行和并行哪个更快？<ul><li>在时钟频率较低时，因为并行可以同时传输多个bit，所以速率比串行要快。 </li><li>时钟频率提高到一定程度时，由于并行通信存在很多平行且紧密的导线，信号变化越来越快，导致导线之间的干扰越来越严重。</li><li>串行通信导线少，且有差分信号加持，抗干扰能力更强，可以通过不断提升时钟频率来获得更高的传输速率，所以很多高速传输也使用串行通信，如USB、PCIe等。</li></ul></li></ul><h2 id="2-单工-半双工-全双工"><a href="#2-单工-半双工-全双工" class="headerlink" title="2. 单工 &amp; 半双工 &amp; 全双工"></a>2. 单工 &amp; 半双工 &amp; 全双工</h2><ul><li>串行通信按照传输的方向分类，有以下三种：<ul><li>单工：数据传输只能在一个固定方向上传输，这个方向固定后就不可更改，不能实现双向通信。</li><li>半双工：传输方向可以切换，但是在某个时刻，只允许数据在一个方向上传输。（如IIC通信）</li><li>全双工：允许数据同时两个方向传输，可以认为发送和接收是完全独立的。（如SPI通信）</li></ul></li></ul><h2 id="3-同步通信和异步通信"><a href="#3-同步通信和异步通信" class="headerlink" title="3.同步通信和异步通信"></a>3.同步通信和异步通信</h2><ul><li>串行通信按照传输的方式分类，有以下两种：<ul><li>同步<ul><li>收发双方使用一根时钟信号，来进行双方数据同步，一般双方会规定在时钟上升&#x2F;下降沿对数据进行采样。</li><li>SPI，IIC</li></ul></li><li>异步 <ul><li>不使用时钟信号进行数据同步，而是<strong>在数据信号中穿插一些用于同步的信号位</strong>，或者以数据帧的格式传输数据，例如规定起始位、数据位、奇偶校验位、停止位等。</li><li>一些通讯还需要使用波特率衡量数据传送速率，以便更好的同步。</li><li>UART，但是USART可以同步&amp;异步通信。</li></ul></li><li>两者比较<ul><li>对于同步来说，传输内容大部分就是有效数据；而异步，传输内容会包含帧的各种标识符；所以同步通讯的效率更高。</li><li>但是同步对发送和接收方的时钟允许误差要求较小。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>串行接口通信协议</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIPI-CSI-1</title>
    <link href="/2023/10/28/MIPI-CSI-1/"/>
    <url>/2023/10/28/MIPI-CSI-1/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/sinat_43629962/article/details/123089993">https://blog.csdn.net/sinat_43629962/article/details/123089993</a></li><li><a href="https://zhuanlan.zhihu.com/p/599531271">https://zhuanlan.zhihu.com/p/599531271</a></li><li><a href="https://www.mipi.org/">https://www.mipi.org/</a></li></ul></li></ul><hr><h2 id="1-CSI-Camera-Serial-Interface-Layer-Definitions"><a href="#1-CSI-Camera-Serial-Interface-Layer-Definitions" class="headerlink" title="1. CSI (Camera Serial Interface) Layer Definitions"></a>1. CSI (Camera Serial Interface) Layer Definitions</h2><ul><li>观察下图，可以看到CSI是<strong>单向差分</strong>串行接口，传输数据和时钟信号。CCI(Camera Control Interface)是<strong>双线、双向、半双工的串行接口</strong>。数据传输协议符合I2C标准。I2C相关知识见<a href="https://www.cnblogs.com/qianbinbin/p/17488308.html">这篇博客</a>。</li></ul><p>​<img src="3201119-20230903112723912-1950951905.png" width = 50%/></p><ul><li>如下图所示，CSI-2可以分为5层，分别为：应用层、组包&#x2F;解包层，底层协议层（Low Level Protocol）、通道管理层和物理层。下面对每一层进行解释。<ul><li>PHY Layer：物理层<ul><li>该层定义了传输介质，输入&#x2F;输出电路和时钟的机制，以便可以正确的从bit stream中捕获正确的0&#x2F;1.</li><li>记录传输介质的电气参数特性以及数据和时钟之间的时序关系，记录了传输的起始位(SoT)和终止位(EoT)。</li></ul></li><li>Protocal Layer：协议层<ul><li>Pixel2Byte&#x2F;Byte2Pixel Packing&#x2F;Unpacking Layer：像素&#x2F;字节转换层。<ul><li>Transmitter在将从Application接收到的数据发送前需要将像素数据转换为对应的字节流。Receiver在将数据提供给Application之前，需要将字节流数据转换为像素数据。</li></ul></li></ul></li><li>Low Level Protocol(LLP)：底层协议层<ul><li>指的是SoT与EoT之间的数据包字节流协议，最小单元是字节。</li></ul></li><li>Lane Management：Lane管理层<ul><li>Lane 是指一对差分数据对，在上面Figure1中，有N对差分数据，所以有N个Lane。</li><li>在Transimitter端，需要把上层打包好的数据按顺序依次Distribute到不同的lane上。</li><li>而在Reciever端需要从不同的lane上依次接收数据并把其按顺序Merge起来。</li><li>总结<ul><li>在Transmitter端，从Apllication层接收到的数据，被打包成字节流数据包，可以选择将错误检查信息附加在要发送的数据流上，在底层协议层进行传输，并在Lane Management层进行分发到不同的Lane上。</li><li>在Reciever端，从PHY层接收到数据后，经过Lane Management层进行按序Merge，在底层协议层传输时，可以将Transmitter附加的信息剥离下来，并通过相对应的逻辑进行解释，检查数据发送的完整性和正确性。</li></ul></li></ul></li><li>Application layer<ul><li>该层主要用于不同场景对数据进行处理的过程，对于Transimitter，一般为Camera生成数据包；对于Reciever，多为SOC对数据进行处理。</li></ul></li></ul></li></ul><p>​<img src="3201119-20230903115043490-1797678616.png" width = 50%/></p><h2 id="2-Lane-Management"><a href="#2-Lane-Management" class="headerlink" title="2. Lane Management"></a>2. Lane Management</h2><h3 id="2-1-Multi-Lane-Distribution-and-Merging"><a href="#2-1-Multi-Lane-Distribution-and-Merging" class="headerlink" title="2.1 Multi-Lane Distribution and Merging"></a>2.1 Multi-Lane Distribution and Merging</h3><ul><li><p>对于带宽有高要求&#x2F;想要降低时钟频率的应用，可以通过扩展多条Lane来得到更大的带宽。</p></li><li><p>在PHY层和协议层之间还存在一个处理多通道配置的层，下面介绍TX端和RX端该层的结构。</p><ul><li><p>Transmitter端</p><ul><li><p>下面两张图分别为D-PHY和C-PHY下 TX端 Lane Manager Layer的结构示意图。</p></li><li><p>包含通道分配功能(Lane Distribution Function,LDF)，LDF模块接收low level protocol(LLP)层输入的数据包字节序列，并将它们分布到N个通道中，之后依次通过SerDes和Lane传输出去。</p><img src="image-20240409185751691.png" alt="image-20240409185751691" style="zoom:50%;" /><img src="image-20240409200611831.png" alt="image-20240409200611831" style="zoom:50%;" /></li></ul></li><li><p>Reciever 端</p><ul><li><p>下面两张图分别为D-PHY和C-PHY下 Lane Manager Layer的结构示意图。</p></li><li><p>包含通道合并功能(Lane  Merging Function,LMF)，从N条Lane中收集字节，并将它们合并为完整的数据包，送到LLP层的分解器(decomposer)处理。</p></li><li><p>在Transmitter端发送数据之前，所有的Lane会并行的执行SOT序列，以向后续模块指示接收数据包开始的第一个字节。</p><img src="image-20240409202423590.png" alt="image-20240409202423590" style="zoom:50%;" /><img src="image-20240409202628351.png" alt="image-20240409202628351" style="zoom:50%;" /></li></ul></li></ul></li><li><p>在Lane的数据分发实例</p><ul><li><p>DPHY</p><ul><li><p>下图为DPHY层两条Lane的传输情况，由于总字节数可能不是通道数N的整数倍；因此在传输结束时，可能会有额外的字节。</p><ul><li>处理方法<ul><li>一条&#x2F;多条Lane出现无数据发送时，会让对应的Lane提前发送EOT序列完成传输，并进入LPS状态。</li><li>其余还有有效数据的Lane并行的将最后一次数据传输完成之后，发送EOT序列。</li><li>并无效掉所有Lane上的数据，表示无数据要传输。</li></ul></li></ul></li><li><p>对于多条Lane，同样道理。</p><img src="image-20240410095031308.png" alt="image-20240410095031308" style="zoom:67%;" /></li><li><p>当进行短包传输时，即传输字节数&#x3D;4，而Lane 个数 N&gt;4，不接受字节的通道保持在LPS状态。</p><img src="image-20240410100119216.png" alt="image-20240410100119216" style="zoom:67%;" /></li></ul></li><li><p>CPHY</p><ul><li><p>下图为CPHY层两条Lane的传输情况，其不存在DPHY有额外字节的问题，因为在LLP层会确保传输字节数B是2N的整数倍。</p></li><li><p>在发送最后一组并行的数据包之后，会同时无效所有Lane中的数据，并通知每条Lane，可以开始它的EOT序列。</p><p><img src="/2023/10/28/MIPI-CSI-1/image-20240410100350088.png" alt="image-20240410100350088"></p></li></ul></li></ul></li></ul><h3 id="2-2-Multi-Lane-Interoperability-互操作性"><a href="#2-2-Multi-Lane-Interoperability-互操作性" class="headerlink" title="2.2  Multi-Lane Interoperability(互操作性)"></a>2.2  Multi-Lane Interoperability(互操作性)</h3><ul><li><p>当 Transimitter PHY层的Lane的个数M与Reciever PHY层的Lane的个数N不相等时，主要分为下面两种情况。</p><ul><li>（1）M &lt;&#x3D; N：不会损失性能，因为接收机有足够的数据通道来匹配发射机。</li><li>（2）M &gt; N：可能会出现性能损失（如帧率），因为接收机的数据通道少于发射机。</li></ul><img src="image-20240410103804969.png" alt="image-20240410103804969" style="zoom:67%;" /><img src="image-20240410103827584.png" alt="image-20240410103827584" style="zoom:67%;" /></li></ul>]]></content>
    
    
    <categories>
      
      <category>高速串行总线</category>
      
      <category>MIPI 接口协议</category>
      
      <category>CSI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIPI-概述</title>
    <link href="/2023/10/28/MIPI-%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/10/28/MIPI-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/92682047">https://zhuanlan.zhihu.com/p/92682047</a></li></ul></li></ul><hr><h2 id="1-关于-MIPI"><a href="#1-关于-MIPI" class="headerlink" title="1. 关于 MIPI"></a>1. 关于 MIPI</h2><ul><li>MIPI：Mobile Industry Processor Interface，MIPI联盟发起的为移动应用处理器部分接口制定的开放标准。</li><li>MIPI 包含了一套协议和标准，MIPI alliance官网可以看到下面几种应用场景，都有相对应的协议。</li></ul><p>​<img src="3201119-20230902162549960-1373239895.png" width = 60%/></p><ul><li>以 Mobile System 为例，如下图。</li></ul><p>​<img src="3201119-20230902163024179-34270586.png" width = 40%/></p><h2 id="2-MIPI-Multimedia"><a href="#2-MIPI-Multimedia" class="headerlink" title="2. MIPI Multimedia"></a>2. MIPI Multimedia</h2><ul><li>下图为MIPI Multimedia涉及到的协议。分为三层：应用层、协议层和物理层。</li></ul><p>​<img src="3201119-20230902171954203-567302188.png" width = 50%/></p>]]></content>
    
    
    <categories>
      
      <category>高速串行总线</category>
      
      <category>MIPI 接口协议</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>硬件预取</title>
    <link href="/2023/10/28/%E7%A1%AC%E4%BB%B6%E9%A2%84%E5%8F%96/"/>
    <url>/2023/10/28/%E7%A1%AC%E4%BB%B6%E9%A2%84%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/373038275">https://zhuanlan.zhihu.com/p/373038275</a></li><li>《A Primer on Hardware Prefetching》</li><li><a href="http://home.ustc.edu.cn/~shaojiemike/posts/cache/">http://home.ustc.edu.cn/~shaojiemike/posts/cache/</a></li><li><a href="http://staff.ustc.edu.cn/~xhzhou/CA-Spring2020/chapter04-03.pdf">http://staff.ustc.edu.cn/~xhzhou/CA-Spring2020/chapter04-03.pdf</a></li></ul></li></ul><hr><h2 id="1-预取相关"><a href="#1-预取相关" class="headerlink" title="1. 预取相关"></a>1. 预取相关</h2><h3 id="1-1-为什么需要预取"><a href="#1-1-为什么需要预取" class="headerlink" title="1.1 为什么需要预取"></a>1.1 为什么需要预取</h3><ul><li>Cache的设计可以一定程度上弥补CPU和内存之间的速度差距。</li><li>多级Cache的设计与两种类型的内存访问局限性相关，分别为：时间局域性和空间局域性。但局域性原理依赖于两个基本前提：<ul><li>（1）缓存的大小适合所有的工作负载和访问模式。<ul><li>但，工作负载的容量需求变化是高度动态的，不同工作负载下所适合的缓存层次和容量与速度之间的权衡各不同。</li></ul></li><li>（2）分配和替换缓存项的策略适用于所有工作负载和访问模式。 <ul><li>但，内存访问模式也是高度动态的，所以很难说某个分配策略可以在所有情况下都表现良好。</li></ul></li></ul></li><li>考虑到上面的内容，Cache虽然可以一定程度上提升性能，但仍还需要其它的优化算法。</li></ul><h3 id="1-2-预取算法"><a href="#1-2-预取算法" class="headerlink" title="1.2 预取算法"></a>1.2 预取算法</h3><ul><li>预取算法，是一种利用存储器的空闲带宽，提前预测取数据来隐藏内存访问延迟的方法。<ul><li>通过预测后续的内存访问，并提前完成该访问，（访问可能与CPU的其它不需要内存访问的操作并行进行），隐藏内存访问延时。</li><li>假设理想情况，预测都命中了，那么内存访问几乎不会造成任何延时开销；但实际上，预测并不总是及时&#x2F;正确的。</li></ul></li><li>预测机制需要考虑以下因素<ul><li>内存访问的地址的预测</li><li>预测何时发出预取<ul><li>如果太早，会在暂存位置（这里假设是cache）保持一段时间，期间可能会挤走有用的cacheline，也可能会被其它挤走。</li><li>如果太晚，没有实现隐藏内存访问延迟的功能。</li></ul></li><li>选择合适的暂存 预取数据&#x2F;地址 的位置</li></ul></li><li>预取实现方式<ul><li>硬件</li><li>软件</li><li>编译器</li></ul></li><li>评估指标<ul><li>覆盖率（coverage）<ul><li>预取命中占总访存比例。</li></ul></li><li>准确度（accuracy）<ul><li>所有预取中有效预取的占比。</li></ul></li></ul></li></ul><h3 id="1-3-预取值-暂存位置"><a href="#1-3-预取值-暂存位置" class="headerlink" title="1.3 预取值 暂存位置"></a>1.3 预取值 暂存位置</h3><ul><li>根据预取值的暂存位置，可以分为绑定预取和非绑定预取。</li><li>绑定预取(binding prefetch)<ul><li>预取值直接加载到处理器的寄存器中。</li><li>在发起预取之后，寄存器的值将会被绑定。</li><li>缺点<ul><li>消耗了宝贵的寄存器资源。</li><li>在预取地址错误时，可能会导致程序语义错误。</li></ul></li></ul></li><li>非绑定预取(non-binding prefetch)<ul><li>将预取值放入cache中，或是用于增强cache层次的补充缓冲区(supplemental buffer)。 </li><li>对于多核，预取值所在的cache或是buffer也需要满足cache coherence，因此该部分地址空间的信息可能也会改变。</li><li>目前大部分处理器使用的都是非绑定预取策略。</li></ul></li></ul><h2 id="2-地址预测"><a href="#2-地址预测" class="headerlink" title="2. 地址预测"></a>2. 地址预测</h2><ul><li>如果没有准确的预测到地址，可能导致污染cache（将有效的cacheline内容挤出），以及消耗了额外的通信量和争用资源。</li><li>数据的地址预测<ul><li>主要考虑是对 独立变量还是数据结构元素或是其它数据类型 的访问，以及数据在程序中执行的操作。<ul><li>举例：按顺序读取数组的每一个元素等，这种数据结构和操作方式很好预测。</li><li>举例：对变量交错访问&#x2F;多个数据结构之间的遍历访问等，这种预测较为复杂。</li></ul></li></ul></li><li>指令的地址预测<ul><li>主要考虑程序是 顺序执行 还是 执行分支（一些跳转指令）。</li></ul></li><li>Cache 层级对地址预测的影响<ul><li>在最高层，处理器和L1 Cache的接口 包含了所有可以用来预测内存引用的信息，基于这些信息可以实现高精度的预取。</li><li>在较低的层级中，关于预测内存引用的信息会被过滤。例如高层cache命中后，相关的信息就不会传到低层cache，只能观察到来自高层缺失的信息。</li><li>因此地址预测还与cache块的放置策略和替换策略相关。</li></ul></li></ul><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
