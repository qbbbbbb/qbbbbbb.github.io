<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>FIR &amp; IIR 滤波器</title>
    <link href="/2023/10/28/FIR%20&amp;%20IIR%20%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2023/10/28/FIR%20&amp;%20IIR%20%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://www.cnblogs.com/alifpga/p/7902759.html">https://www.cnblogs.com/alifpga/p/7902759.html</a></li><li><a href="https://www.zhihu.com/question/323353814">https://www.zhihu.com/question/323353814</a></li></ul></li></ul><hr><h2 id="1-FIR-物理意义"><a href="#1-FIR-物理意义" class="headerlink" title="1. FIR 物理意义"></a>1. FIR 物理意义</h2><ul><li>滤波，就是输入信号频率 X(f) 和期望的频率特征函数 H(f) 进行相乘；这是在频域的计算。那么在时间域，是做了一个卷积的计算。</li><li>因此FIR做的就是将各个时刻的输入和对应的权重参数相乘，并叠加之后输出。<ul><li>如下图所示，为一N点的FIR滤波器。满足$ y(n) &#x3D; \sum\limits_{k&#x3D;0}^{N-1}h(k)x(n-k)$<br><img src="/2023/10/28/FIR%20&%20IIR%20%E6%BB%A4%E6%B3%A2%E5%99%A8/3201119-20230718173257360-1137724047.png"></li></ul></li><li>由于FIR每一时刻的输出都取决于之前有限个输入，因此是“有限冲激响应”。</li></ul><h2 id="2-IIR-物理意义"><a href="#2-IIR-物理意义" class="headerlink" title="2. IIR 物理意义"></a>2. IIR 物理意义</h2><ul><li>IIR 滤波器设计的基本方法<ul><li>先设计一个合适的模拟滤波器，然后利用复值映射把模拟滤波器变换成数字滤波器。</li></ul></li><li>模拟原型滤波器<ul><li>有 巴特沃斯滤波器、切比雪夫滤波器、贝塞尔滤波器、椭圆滤波器等。</li><li>之后有时间会进行更详细的学习。</li></ul></li><li>模拟滤波器到数字滤波器的变换<ul><li>主要有两种方法<ul><li>脉冲响应不变法：从时域响应出发，让数字滤波器的单位脉冲响应h(n)模仿模拟滤波器的单位冲激响应ha(t)，h(n)等于ha(t)的取样值。  </li><li>双线性变换法：从频率响应出发，让数字滤波器的频率响应逼近模拟滤波器的频率响应，进而求得数字滤波器得系统函数。</li></ul></li></ul></li><li>无限冲激响应的理解<ul><li>首先看IIR滤波器表达式:<br>$$<br> y[n] &#x3D; a_0x[n]+a_1x[n-1]+a_2x[n-2]+a_3x[n-3]+…<br> +b_1y[n-1]+b_2y[n-2]+b_3y[n-3]+…<br>$$ <ul><li>可以看到该公式是存在一个递归关系的，本步的计算结果会作为下一步的输入，无限递归下去。</li></ul></li><li>由于IIR是由模拟滤波器变换得到的，以下面滤波器为例。<ul><li>当给输入一个电压值（给输入一个冲激信号），电容会被充电，但是当电压值取消后，电容的电荷会被逐渐放掉，但是理论上永远不会变成0，导致输入会在无限长的时间产生影响。<br><img src="/2023/10/28/FIR%20&%20IIR%20%E6%BB%A4%E6%B3%A2%E5%99%A8/3201119-20230718224246063-1237397880.png"></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>I2S协议</title>
    <link href="/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li>NXP 《I2S bus specification》</li><li>NXP 《I2S在Kinetis上的应用   》</li><li><a href="https://www.python100.com/html/R62183SDTAU0.html">https://www.python100.com/html/R62183SDTAU0.html</a></li><li><a href="https://blog.51cto.com/u_15459030/5225825">https://blog.51cto.com/u_15459030/5225825</a></li></ul></li></ul><hr><h2 id="1-I2S概述"><a href="#1-I2S概述" class="headerlink" title="1. I2S概述"></a>1. I2S概述</h2><h3 id="1-1-为什么需要I2S"><a href="#1-1-为什么需要I2S" class="headerlink" title="1.1 为什么需要I2S"></a>1.1 为什么需要I2S</h3><ul><li>I2S是I2C的变种，全称：InterIc-Sound. 专门为传输音频数据而设计的。</li><li>I2S 相较于I2C和SPI有以下优点<ul><li>更低的延迟：由于I2S数据传输是连续的，不需要等待ACK信号的回复，I2S只需要使用WS和SCK信号进行数据的同步；响应速度更快。</li><li>更高的精度：I2C一次可以传输8位的数据，但是I2S可以传输16&#x2F;24位的数据，对于高精度的音频设备，I2S能够满足要求。</li></ul></li></ul><h3 id="1-2-I2S-三条总线"><a href="#1-2-I2S-三条总线" class="headerlink" title="1.2 I2S 三条总线"></a>1.2 I2S 三条总线</h3><ul><li>之前介绍I2C有两条总线:SCL&#x2F;SDA。而I2S有三条总线如下。<ul><li>SCK(Continuous Serial Clock)：串行时钟，也称为位时钟BCLK。<ul><li>SCK的时钟频率 &#x3D; 声道数 * 采样频率 * 采样位数。</li></ul></li><li>WS(Word Select)：字段（声道）选择信号，也称为帧时钟LRCK。<ul><li>其频率等于采样频率。</li><li>在<strong>I2S模式下</strong>：WS&#x3D;1，表示传递的是右声道数据。WS&#x3D;0，表示传递的是左声道数据。后面有介绍，其它模式不同。</li></ul></li><li>SD(Serial Data)：串行数据。</li></ul></li><li>控制器（Controller）产生SCK信号和WS信号，控制器可以是Transmitter也可以是Receiver，也可以是单独设计的控制模块。<br><img src="/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/3201119-20230724112142940-41134477.png"></li></ul><h3 id="1-3-I2S的三种操作模式"><a href="#1-3-I2S的三种操作模式" class="headerlink" title="1.3 I2S的三种操作模式"></a>1.3 I2S的三种操作模式</h3><ul><li>图片来自TI的TLV320AIC3104的数据表，其中WCLK为LRCLK信号，BCLK为SCK信号。</li><li>无论哪种模式，串行数据都是以二进制补码进行传输的，且先传输MSB，LSB的位置取决于I2S的位宽，长会被截断，短会被补零。</li><li>根据下面的波形可以看到：I2S模式，WS&#x3D;0-&gt;左，WS&#x3D;1-&gt;右;而左对齐和右对齐和I2S模式规定相反。</li><li>不同的模式决定了解码方式也不同。</li><li>根据SD和WCLK情况可分为三种模式：  <ul><li>I2S模式<ul><li>在WCLK下降沿之后的一个BCLK周期的上升沿采到的数据有效。</li><li>WCLK在BCLK下降沿变化，发送方在BCLK下降沿改变数据，而接收方在BCLK上升沿采样数据。<br><img src="/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/3201119-20230724144906940-1187645121.png"></li></ul></li><li>左对齐模式<ul><li>相较于I2S模式，没有延迟一个BCLK周期。</li><li>不需要关心数据的长度，只会对LSB进行处理，截取&#x2F;补零；但是MSB不会有问题。</li><li>发送方在BCLK下降沿改变数据，而接收方在BCLK上升沿采样数据。<br><img src="/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/3201119-20230724145852016-1096610293.png"></li></ul></li><li>右对齐模式<ul><li>不足：接收设备需要事先知道传输数据的长度，否则可能会导致MSB被截断<br><img src="/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/3201119-20230724162951792-210572944.png"></li></ul></li></ul></li><li>对于I2S模式和左对齐模式，可以允许发送端和接收端数据长度不同，因为接收端和发送端可以进行相应的截断和补0.<ul><li>为了保证数据音频信号的正确传输，发送端和接收端最好使用相同的数据格式和长度。</li></ul></li></ul><h2 id="2-I2S-应用"><a href="#2-I2S-应用" class="headerlink" title="2. I2S 应用"></a>2. I2S 应用</h2><ul><li>注意：这里只讨论I2S模式，不讨论左对齐&#x2F;右对齐模式。</li><li>讨论基于DMA和中断的乒乓缓冲区方案，旨在降低用于处理音频数据流的CPU开销。</li><li>为什么需要该方案<ul><li>采样率一般会在8KHz-48KHz之间，甚至可以更高。如果使用CPU去处理每个中断，那么系统效率会非常低。</li><li>另外大部分的音频算法会累积音频流中的数据形成缓冲数据块，之后再对缓存数据块进行处理。</li></ul></li></ul><h3 id="2-1-方案概述"><a href="#2-1-方案概述" class="headerlink" title="2.1 方案概述"></a>2.1 方案概述</h3><ul><li>具体方案结构框图如下图所示。<ul><li>其中R和L分别代表右通道&#x2F;左通道。每个通道都有用于乒乓操作的两个缓冲区（红色和黑色）。<ul><li>乒乓相关知识可以看<a href="https://www.cnblogs.com/qianbinbin/p/17482594.html">这篇博客</a>。</li></ul></li><li>我对框图的工作模式理解是<ul><li>前面介绍，缓冲区被划分为四块；我们这里看红色和黑色两部分。红色部分我们使用DMA将其传送到I2S TX模块。<ul><li>根据要求假设N为缓冲区中采样数据数量，DMA传送了N个采样数据之后，DMA会向CPU发起一个中断。</li></ul></li><li>中断期间，CPU执行音频解码算法之后获得的输出数据，并将输出数据填充到缓冲区。</li><li>可以看到存在一个乒乓的工作模式：<ul><li>T1：中断：CPU计算完成，将数据送到缓冲区R_TX0。与此同时DMA在搬移R_TX1的数据。</li><li>T2：DMA搬移结束后再次触发中断，此时DMA继续搬移R_TX0中的数据。CPU完成计算，并将数据送到缓冲区R_TX1中。</li><li>依次类推，形成乒乓的工作模式。</li></ul></li></ul></li><li>注意：考虑到音频信号具有较强的实时性要求，因此，所有计算都必须在下个中断发生之前完成，否则会导致系统故障。<br><img src="/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/3201119-20230724200700025-1774790489.png"></li></ul></li></ul><h3 id="2-2-I2S-的-FIFO-特性"><a href="#2-2-I2S-的-FIFO-特性" class="headerlink" title="2.2 I2S 的 FIFO 特性"></a>2.2 I2S 的 FIFO 特性</h3><ul><li>I2S 的 FIFO 从DMA中读数据，FIFO中的数据会交替发送到左右通道；判断依据可选择FIFO中是否存在空数据。<ul><li>如下图所示，当FIFO的空数据计数为2时，就会让DMA加载一条数据进入左通道，一条数据进入右通道。<br><img src="/2023/10/28/I2S%E5%8D%8F%E8%AE%AE/3201119-20230724220704113-1334935146.png"></li></ul></li></ul><h3 id="2-3-DMA-和中断-配置"><a href="#2-3-DMA-和中断-配置" class="headerlink" title="2.3 DMA 和中断 配置"></a>2.3 DMA 和中断 配置</h3><ul><li>2.1节中有介绍到DMA和中断CPU处理之间的乒乓工作模式。下面会依据实例详细介绍。</li><li>下图可以看到，共有四个数据块，每个数据块有四个采样，每个采样都有四个字节。<ul><li>DMA的访问顺序是左右通道交叉，如：0x00,0x20,0x04,0x24…</li></ul></li><li>乒乓操作实现<ul><li>当DMA读取地址经过0x00,0x20…到达0x2c时，TX0内的所有数据都已经发送完毕，发起一个中断。</li><li>随后，CPU进行算法计算，并将数据填充到BLOCK0和BLOCK2中；与此同时，DMA处理BLOCK1和BLOCK3。</li><li>当DMA到达地址0x3c时，会发起另一个中断。</li><li>随后，CPU进行算法计算，并将数据填充到BLOCK1和BLOCK3中；与此同时，DMA处理BLOCK0和BLOCK2。  <div align=center><img src="3201119-20230724221806028-635573909.png" width = 60%/></div></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>串行接口通信协议</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>I2C协议（一）</title>
    <link href="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/362287272"class="uri">https://zhuanlan.zhihu.com/p/362287272</a></li><li><a href="https://zhuanlan.zhihu.com/p/282949543"class="uri">https://zhuanlan.zhihu.com/p/282949543</a></li><li><ahref="https://blog.csdn.net/zhangduang_KHKW/article/details/121953275"class="uri">https://blog.csdn.net/zhangduang_KHKW/article/details/121953275</a></li></ul></li></ul><hr /><ul><li>波形文件来自NXP的IIC user manual.</li></ul><hr /><h2 id="i2c-用来做什么">1. I2C 用来做什么？</h2><ul><li>全称：Inter-Integrated Circuit.</li><li>一个双向，两线（SCL/SDA）制总线协议；用于主控器件和外围设备器件互联通信。简化PCB布线，降低成本。</li><li>I2C是一种多主机总线，所以也提供了仲裁功能，仲裁相关内容见<ahref="https://www.cnblogs.com/qianbinbin/p/17489279.html">这篇博客</a>。</li></ul><h2 id="i2c-的5种速率模式">2. I2C 的5种速率模式</h2><ul><li>对于不同的器件使用不同的模式，一共有5种模式，具体可看<ahref="https://zhuanlan.zhihu.com/p/362287272">这篇文章</a>.</li></ul><h2 id="通信过程">3. 通信过程</h2><ul><li>（1）当总线空闲时，SDA和SCL都处于高电平状态。</li><li>（2）当主设备决定开始通讯时，需要<strong>首先发送开始信号</strong>。</li><li>（3）发送从机设备的地址（7bits）以及1bit数据传送方向（R/W）；一共8bit，一个字节大小的数据。</li><li>（4）被寻址的从机发送应答信号给主机。</li><li>（5）发送器送出一个字节的数据，接收器收到完毕返回一个应答信号给主机。（发送器和接收器根据（3）中指定的传送方向分别选择为主机/从机）。</li><li>（6）重复（5）直到通信完成后，主机发送停止信号释放总线。</li><li>注意：<strong>发送数据过程中不可以改变数据传送方向，在（3）那步指定之后就不可更改。</strong>除非重启通信。</li></ul><h2 id="i2c的基础信号">4. I2C的基础信号</h2><ul><li>起始、停止、应答和非应答信号。<ul><li>起始信号：SCL处于高电平时，SDA从高电平到低电平变化，为起始信号。</li><li>停止信号：SCL处于高电平时，SDA从低电平到高电平变化，为停止信号。<img src="3201119-20230618154435605-1791635155.png" /></li><li>应答信号：其出现在一个字节传输完成之后，第9个SCL时钟周期内，SDA总线的控制权从主机给到从机，SDA总线由于上拉电阻的原因为高，如果从机正确的收到了数据，那么会将SDA拉低。<ul><li>主机发现SDA被拉低之后，可以选择下一步操作（发下一字节的传输/停止传输）。</li><li>需要注意，应答信号是接收设备给发送设备的反馈信号，而并不一定是从机给主机的反馈信号。<img src="3201119-20230618155923953-611387111.png" /></li></ul></li><li>非应答信号：第9个SCL时钟周期，SDA保持高电平，表示非应答，主机就需要发送停止信号，结束通信。以下情况可能会出现非应答：<ul><li>主机指定的地址，I2C总线上没有对应地址的从机设备。</li><li>主机发送从机地址，希望通信时；从机正忙，没办法通信。</li><li>主机接收从机发送的数据，主机产生非应答信号，告诉从机不要再发数据了，传输结束了。</li></ul></li></ul></li><li>数据有效性<ul><li>I2C在进行数据传送时，在SCL为低电平时发送器向SDA上送1bit数据，此时SDA可以发生变化；在SCL为高电平时，接收器从SDA上采样1bit数据，SDA需要保持稳定。<img src="3201119-20230618154320356-1776344245.png" /></li></ul></li><li>I2C传输的一帧有9位信号，包括一个字节的传输信号和1bit的应答/非应答信号。对于第一笔主机发送从机的传输包括（地址7bits+ 传输方向1bit）+ 1bit应答信号。<ul><li>对于1字节的数据，先发送高位，再传送低位。<br /></li></ul></li><li>前面介绍的SCL和SDA高低电平判断有些混乱，这里做一下总结。<ul><li>在开始和结束的判断，需要判断SCL信号为高电平时，SDA的变化。</li><li>在采样SDA时，需要判断SCL信号是否为高电平/低电平采样。</li><li>在判断应答/非应答，需要在SCL为高电平时，判断SDA信号是否被拉高/拉低。</li></ul></li></ul><hr /><p>如有问题，请指正！！</p>]]></content>
    
    
    <categories>
      
      <category>串行接口通信协议</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>I2C协议（二）</title>
    <link href="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/zhangduang_KHKW/article/details/121953275">https://blog.csdn.net/zhangduang_KHKW/article/details/121953275</a></li><li><a href="https://blog.csdn.net/u010027547/article/details/47779975">https://blog.csdn.net/u010027547/article/details/47779975</a></li><li><a href="https://blog.csdn.net/NeoZng/article/details/128486366">https://blog.csdn.net/NeoZng/article/details/128486366</a></li><li><a href="https://www.cnblogs.com/DoreenLiu/p/14297191.html">https://www.cnblogs.com/DoreenLiu/p/14297191.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/388835566?utm_id=0">https://zhuanlan.zhihu.com/p/388835566?utm_id=0</a></li></ul></li></ul><hr><h2 id="1-仲裁机制"><a href="#1-仲裁机制" class="headerlink" title="1. 仲裁机制"></a>1. 仲裁机制</h2><ul><li>I2C是一个多主机的通信协议，那么就会出现 多个主机都申请SDA总线权限发送开始信号和从机地址 的情况，这就需要仲裁机制。</li></ul><h3 id="1-1-SCL的同步"><a href="#1-1-SCL的同步" class="headerlink" title="1.1 SCL的同步"></a>1.1 SCL的同步</h3><ul><li>这里以两个主机为例，可以拓展到多个主机上。目的：多个主机产生一个可公用的时钟。</li><li>两个主机的时钟频率不同，相位不同，使用时钟同步机制如下图所示：<ul><li>总线空闲时，SCL被上拉电阻拉高，当开始通信时，CLK1首先变成低电平，SCL也变成低电平，CLK2看到SCL拉低，便自己也拉低，并开始<strong>计数</strong>到CLK2虚线（原本应该拉低的位置）。</li><li>CLK2的低电平时间比CLK1要长，所以CLK1从拉高开始<strong>计数</strong>到CLK2和CLK1同时拉高（此时SCL也被拉高）的位置。 </li><li>至此，CLK1获得了需要延长的低电平时间，CLK2获得了需要减短的高电平时间，都是通过前面计数得到的。CLK1和CLK2可以根据计数值进行调整，完成时钟的同步。<br><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230618163225074-2122545585.png"></li></ul></li></ul><h3 id="1-2-时钟扩展"><a href="#1-2-时钟扩展" class="headerlink" title="1.2 时钟扩展"></a>1.2 时钟扩展</h3><ul><li>目的：I2C可以动态的调整总线的通信速率。</li><li>时钟扩展是从机发起的。<ul><li><a href="https://www.cnblogs.com/qianbinbin/p/17488308.html">这篇博客</a>介绍了非应答信号，即从机正忙，没办法通信。SCL是正常由主机控制，在SCL为高电平时，主机采到第9个SCL周期，SDA为高，此时为非应答；主机就会发起停止信号，结束通信。</li><li>现在想要即使出现非应答也可以等待从机忙完之后可以继续传输的情况，可以对SCL信号做处理，如下。</li></ul></li><li>时钟扩展在基于上面描述，增加了从机可以控制SCL信号的硬件电路，从机在第9个SCL周期将SCL拉低，由于正忙，没办法接收处理传输的数据；主机检测到SCL被拉低，便会进入等待状态。等待从机忙完可以处理时，将SCL释放（I2C两条总线都接了上拉电阻，默认是高电平）并返回主机ACK信号，主机可以进行下一步的操作。</li></ul><h3 id="1-3-SDA仲裁"><a href="#1-3-SDA仲裁" class="headerlink" title="1.3 SDA仲裁"></a>1.3 SDA仲裁</h3><ul><li>**”线与逻辑”**，在SCL为高电平时，SDA的数据等于各个主机的数据相与；每个主机将自己的数据和SDA上的数据进行比对，如果不一致，便知道失去了仲裁，就不再向SDA写数据。</li><li>如果两个主机都是向相同地址从机发起通信，那么仲裁继续，直到后续的数据位决定总线的归属权。</li><li>这种仲裁方式并不会破坏数据的有效性，因为总是有主机可以进行通信，且数据不会被改变。但这种仲裁方式无法提前设定主机的优先级。<br><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230618163641198-821963823.png"></li></ul><h2 id="2-读写时序"><a href="#2-读写时序" class="headerlink" title="2. 读写时序"></a>2. 读写时序</h2><ul><li><p>相同传送方向，不需要每次传输主机都发送开始信号。<br><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230618183803454-485534870.png"> </p></li><li><p>主机写给从机</p><ul><li>其中器件地址为slave地址信息，而字地址为读&#x2F;写从机内部存储单元的地址信息。<br><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230903220933713-114181872.png"></li></ul></li><li><p>主机读从机数据</p><ul><li>当前地址读 <ul><li>I2C在读写操作之后，内部的地址指针自动加1，因此当前地址读不需要再次发送从机内部存储单元地址信息了。<br><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230903221220802-876809426.png"></li></ul></li><li>随机地址读<ul><li>如下图所示，需要先Start Bit、发送slave地址，并设置传输为写方向；之后发送内部寄存器地址。这个过程称为Dummy Write.</li><li>之后再次重新发送Start Bit、slave地址，并设置传输为读方向。从机应答，从机发送8bit数据。</li><li>为什么需要<strong>Dummy Write</strong>？因为是随机读，我们需要让从机存储单元的地址指针指向随机读取的地址，所以可以先进行Dummy Write，让存储单元的地址指针指向随机读的地址，等待从机应答后，就可以读取数据了。<br><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230903213717676-1981068318.png"></li></ul></li></ul></li><li><p>主机读后写&#x2F;写后读</p><ul><li>传输过程中，改变传送方向，不需要主机发送停止信号释放总线，只需要重新发送开始信号就可以。<br><img src="/2023/10/28/I2C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3201119-20230618184525407-257373124.png"></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>串行接口通信协议</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>串行接口通信协议-概述</title>
    <link href="/2023/10/28/%E4%B8%B2%E8%A1%8C%E6%8E%A5%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/10/28/%E4%B8%B2%E8%A1%8C%E6%8E%A5%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/Rocher_22/article/details/116590629">https://blog.csdn.net/Rocher_22/article/details/116590629</a></li></ul></li></ul><hr><h2 id="1-串行通信-并行通信"><a href="#1-串行通信-并行通信" class="headerlink" title="1. 串行通信 &amp; 并行通信"></a>1. 串行通信 &amp; 并行通信</h2><ul><li>串行通信：利用一条传输线将数据位一位一位的传送。</li><li>并行通信：利用多条传输线将一个数据的多bit同时传送。</li><li>串行和并行哪个更快？<ul><li>在时钟频率较低时，因为并行可以同时传输多个bit，所以速率比串行要快。 </li><li>时钟频率提高到一定程度时，由于并行通信存在很多平行且紧密的导线，信号变化越来越快，导致导线之间的干扰越来越严重。</li><li>串行通信导线少，且有差分信号加持，抗干扰能力更强，可以通过不断提升时钟频率来获得更高的传输速率，所以很多高速传输也使用串行通信，如USB、PCIe等。</li></ul></li></ul><h2 id="2-单工-半双工-全双工"><a href="#2-单工-半双工-全双工" class="headerlink" title="2. 单工 &amp; 半双工 &amp; 全双工"></a>2. 单工 &amp; 半双工 &amp; 全双工</h2><ul><li>串行通信按照传输的方向分类，有以下三种：<ul><li>单工：数据传输只能在一个固定方向上传输，这个方向固定后就不可更改，不能实现双向通信。</li><li>半双工：传输方向可以切换，但是在某个时刻，只允许数据在一个方向上传输。（如IIC通信）</li><li>全双工：允许数据同时两个方向传输，可以认为发送和接收是完全独立的。（如SPI通信）</li></ul></li></ul><h2 id="3-同步通信和异步通信"><a href="#3-同步通信和异步通信" class="headerlink" title="3.同步通信和异步通信"></a>3.同步通信和异步通信</h2><ul><li>串行通信按照传输的方式分类，有以下两种：<ul><li>同步<ul><li>收发双方使用一根时钟信号，来进行双方数据同步，一般双方会规定在时钟上升&#x2F;下降沿对数据进行采样。</li><li>SPI，IIC</li></ul></li><li>异步 <ul><li>不使用时钟信号进行数据同步，而是<strong>在数据信号中穿插一些用于同步的信号位</strong>，或者以数据帧的格式传输数据，例如规定起始位、数据位、奇偶校验位、停止位等。</li><li>一些通讯还需要使用波特率衡量数据传送速率，以便更好的同步。</li><li>UART，但是USART可以同步&amp;异步通信。</li></ul></li><li>两者比较<ul><li>对于同步来说，传输内容大部分就是有效数据；而异步，传输内容会包含帧的各种标识符；所以同步通讯的效率更高。</li><li>但是同步对发送和接收方的时钟允许误差要求较小。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>串行接口通信协议</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIPI-CSI</title>
    <link href="/2023/10/28/MIPI-CSI/"/>
    <url>/2023/10/28/MIPI-CSI/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://blog.csdn.net/sinat_43629962/article/details/123089993">https://blog.csdn.net/sinat_43629962/article/details/123089993</a></li><li><a href="https://zhuanlan.zhihu.com/p/599531271">https://zhuanlan.zhihu.com/p/599531271</a></li><li><a href="https://www.mipi.org/">https://www.mipi.org/</a></li></ul></li></ul><hr><h2 id="1-CSI（Camera-Serial-Interface）"><a href="#1-CSI（Camera-Serial-Interface）" class="headerlink" title="1. CSI（Camera Serial Interface）"></a>1. CSI（Camera Serial Interface）</h2><ul><li><p>观察下图，可以看到CSI是<strong>单向差分</strong>串行接口，传输数据和时钟信号。CCI(Camera Control Interface)是<strong>双线、双向、半双工的串行接口</strong>。数据传输协议符合I2C标准。I2C相关知识见<a href="https://www.cnblogs.com/qianbinbin/p/17488308.html">这篇博客</a>。</p><div align=center><img src="3201119-20230903112723912-1950951905.png" width = 50%/></div></li><li><p>CSI-2 layer Definitions</p><ul><li>如下图所示，CSI-2可以分为5层，分别为：应用层、组包&#x2F;解包层，底层协议层（Low Level Protocol）、通道管理层和物理层。下面对每一层进行解释。</li><li>PHY Layer：物理层<ul><li>该层定义了传输介质，输入&#x2F;输出电路和时钟的机制，以便可以正确的从bit stream中捕获正确的0&#x2F;1.</li><li>记录传输介质的电气参数特性以及数据和时钟之间的时序关系，记录了传输的起始位(SoT)和终止位(EoT)。</li></ul></li><li>Protocal Layer：协议层<ul><li>Pixel2Byte&#x2F;Byte2Pixel Packing&#x2F;Unpacking Layer：像素&#x2F;字节转换层。<ul><li>Transmitter在将从Application接收到的数据发送前需要将像素数据转换为对应的字节流。Receiver在将数据提供给Application之前，需要将字节流数据转换为像素数据。</li></ul></li><li>Low Level Protocol(LLP)：底层协议层<ul><li>指的是SoT与EoT之间的数据包字节流协议，最小单元是字节。</li></ul></li><li>Lane Management：Lane管理层<ul><li>Lane 是指一对差分数据对，在上面Figure1中，有N对差分数据，所以有N个Lane。</li><li>在Transimitter端，需要把上层打包好的数据按顺序依次Distribute到不同的lane上。</li><li>而在Reciever端需要从不同的lane上依次接收数据并把其按顺序Merge起来。</li></ul></li><li>总结<ul><li>在Transmitter端，从Apllication层接收到的数据，被打包成字节流数据包，可以选择将错误检查信息附加在要发送的数据流上，在底层协议层进行传输，并在Lane Management层进行分发到不同的Lane上。</li><li>在Reciever端，从PHY层接收到数据后，经过Lane Management层进行按序Merge，在底层协议层传输时，可以将Transmitter附加的信息剥离下来，并通过相对应的逻辑进行解释，检查数据发送的完整性和正确性。</li></ul></li></ul></li><li>Application layer<ul><li>该层主要用于不同场景对数据进行处理的过程，对于Transimitter，一般为Camera生成数据包；对于Reciever，多为SOC对数据进行处理。<div align=center><img src="3201119-20230903115043490-1797678616.png" width = 50%/></div></li></ul></li></ul></li></ul><h2 id="2-CCI（Camera-Control-Interface）"><a href="#2-CCI（Camera-Control-Interface）" class="headerlink" title="2. CCI（Camera Control Interface）"></a>2. CCI（Camera Control Interface）</h2><h3 id="2-1-CCI-主从机定义"><a href="#2-1-CCI-主从机定义" class="headerlink" title="2.1 CCI 主从机定义"></a>2.1 CCI 主从机定义</h3><ul><li>I2C支持多主机多从机传输，但CCI只支持一个主机的传输。</li><li>CCI将CSI的Transmitter配置为Slave，而将Reciever配置为Master。</li></ul><h3 id="2-2-CCI-Message-Types"><a href="#2-2-CCI-Message-Types" class="headerlink" title="2.2 CCI Message Types"></a>2.2 CCI Message Types</h3><ul><li>CCI 传输信息类型包括：Start信号、ACK信号、Stop信号以及从机地址、从机内部寄存器子地址。<ul><li>CCI的从机地址位为7bit，8bit DATA传输，以及8bit&#x2F;16bit INDEX传输。   <div align=center><img src="3201119-20230903161249778-1539658959.png" width = 50%/></div></li></ul></li></ul><h3 id="2-3-读写操作"><a href="#2-3-读写操作" class="headerlink" title="2.3 读写操作"></a>2.3 读写操作</h3><ul><li><p>CCI支持四种读操作和两种写操作，下面展开介绍。</p></li><li><p>（1）随机位置单次读</p><ul><li>如下图所示，主机先会发起一个虚拟的写操作，指定好从机地址以及INDEX值后，再发起读操作。至于为什么需要Dummy Write可以看<a href="https://www.cnblogs.com/qianbinbin/p/17489279.html">这篇博客</a>。</li><li>和I2C一样，更改数据传输方向需要再次发起开始信号Sr，并且主机需要再次给从机的地址，但不需要给INDEX值。</li><li>完成一次数据读操作之后，将SDA信号拉高表示主机不应答，结束传输。<div align=center><img src="3201119-20230903163440137-201009953.png" width = 50%/></div></li></ul></li><li><p>（2）随机位置连续读</p><div align=center><img src="3201119-20230903224825560-1446970425.png" width = 50%/></div></li><li><p>（3）当前位置单次读</p><ul><li>使用的是Previous_index + 1，不需要Dummy Write。 <div align=center><img src="3201119-20230903223348145-837229902.png" width = 50%/></div></li></ul></li><li><p>（4）当前位置连续读</p><div align=center><img src="3201119-20230903224946740-1858592558.png" width = 50%/></div></li><li><p>（5）随机位置单次写 </p><div align=center><img src="3201119-20230903225103926-1703203642.png" width = 50%/></div></li><li><p>（6）随机位置连续写</p><ul><li>下图中，我认为最后一个Data对应的Index值应为M+L-1。   <div align=center><img src="3201119-20230903225324858-1566777564.png" width = 50%/></div></li></ul></li></ul><h3 id="2-4-CCI-Multi-Byte-Registers"><a href="#2-4-CCI-Multi-Byte-Registers" class="headerlink" title="2.4 CCI Multi-Byte Registers"></a>2.4 CCI Multi-Byte Registers</h3><ul><li>CSI-2 协议支持以下寄存器宽度<ul><li>8-bits - 常用寄存器宽度</li><li>16bits - parameters like line-length, frame-length and exposure values（曝光值）</li><li>32bits - 用于高精度的寄存器宽度</li><li>64bits - for needs of future sensors</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>MIPI 接口协议</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIPI-概述</title>
    <link href="/2023/10/28/MIPI-%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/10/28/MIPI-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/92682047">https://zhuanlan.zhihu.com/p/92682047</a></li></ul></li></ul><hr><h2 id="1-关于-MIPI"><a href="#1-关于-MIPI" class="headerlink" title="1. 关于 MIPI"></a>1. 关于 MIPI</h2><ul><li><p>MIPI：Mobile Industry Processor Interface，MIPI联盟发起的为移动应用处理器部分接口制定的开放标准。</p></li><li><p>MIPI 包含了一套协议和标准，MIPI alliance官网可以看到下面几种应用场景，都有相对应的协议。</p><div align=center><img src="3201119-20230902162549960-1373239895.png" width = 60%/></div></li><li><p>以 Mobile System 为例，如下图。</p><div align=center><img src="3201119-20230902163024179-34270586.png" width = 40%/></div></li></ul><h2 id="2-MIPI-Multimedia"><a href="#2-MIPI-Multimedia" class="headerlink" title="2. MIPI Multimedia"></a>2. MIPI Multimedia</h2><ul><li>下图为MIPI Multimedia涉及到的协议。分为三层：应用层、协议层和物理层。<div align=center><img src="3201119-20230902171954203-567302188.png" width = 50%/></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>MIPI 接口协议</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>硬件预取</title>
    <link href="/2023/10/28/%E7%A1%AC%E4%BB%B6%E9%A2%84%E5%8F%96/"/>
    <url>/2023/10/28/%E7%A1%AC%E4%BB%B6%E9%A2%84%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/373038275">https://zhuanlan.zhihu.com/p/373038275</a></li><li>《A Primer on Hardware Prefetching》</li><li><a href="http://home.ustc.edu.cn/~shaojiemike/posts/cache/">http://home.ustc.edu.cn/~shaojiemike/posts/cache/</a></li><li><a href="http://staff.ustc.edu.cn/~xhzhou/CA-Spring2020/chapter04-03.pdf">http://staff.ustc.edu.cn/~xhzhou/CA-Spring2020/chapter04-03.pdf</a></li></ul></li></ul><hr><h2 id="1-预取相关"><a href="#1-预取相关" class="headerlink" title="1. 预取相关"></a>1. 预取相关</h2><h3 id="1-1-为什么需要预取"><a href="#1-1-为什么需要预取" class="headerlink" title="1.1 为什么需要预取"></a>1.1 为什么需要预取</h3><ul><li>Cache的设计可以一定程度上弥补CPU和内存之间的速度差距。</li><li>多级Cache的设计与两种类型的内存访问局限性相关，分别为：时间局域性和空间局域性。但局域性原理依赖于两个基本前提：<ul><li>（1）缓存的大小适合所有的工作负载和访问模式。<ul><li>但，工作负载的容量需求变化是高度动态的，不同工作负载下所适合的缓存层次和容量与速度之间的权衡各不同。</li></ul></li><li>（2）分配和替换缓存项的策略适用于所有工作负载和访问模式。 <ul><li>但，内存访问模式也是高度动态的，所以很难说某个分配策略可以在所有情况下都表现良好。</li></ul></li></ul></li><li>考虑到上面的内容，Cache虽然可以一定程度上提升性能，但仍还需要其它的优化算法。</li></ul><h3 id="1-2-预取算法"><a href="#1-2-预取算法" class="headerlink" title="1.2 预取算法"></a>1.2 预取算法</h3><ul><li>预取算法，是一种利用存储器的空闲带宽，提前预测取数据来隐藏内存访问延迟的方法。<ul><li>通过预测后续的内存访问，并提前完成该访问，（访问可能与CPU的其它不需要内存访问的操作并行进行），隐藏内存访问延时。</li><li>假设理想情况，预测都命中了，那么内存访问几乎不会造成任何延时开销；但实际上，预测并不总是及时&#x2F;正确的。</li></ul></li><li>预测机制需要考虑以下因素<ul><li>内存访问的地址的预测</li><li>预测何时发出预取<ul><li>如果太早，会在暂存位置（这里假设是cache）保持一段时间，期间可能会挤走有用的cacheline，也可能会被其它挤走。</li><li>如果太晚，没有实现隐藏内存访问延迟的功能。</li></ul></li><li>选择合适的暂存 预取数据&#x2F;地址 的位置</li></ul></li><li>预取实现方式<ul><li>硬件</li><li>软件</li><li>编译器</li></ul></li><li>评估指标<ul><li>覆盖率（coverage）<ul><li>预取命中占总访存比例。</li></ul></li><li>准确度（accuracy）<ul><li>所有预取中有效预取的占比。</li></ul></li></ul></li></ul><h3 id="1-3-预取值-暂存位置"><a href="#1-3-预取值-暂存位置" class="headerlink" title="1.3 预取值 暂存位置"></a>1.3 预取值 暂存位置</h3><ul><li>根据预取值的暂存位置，可以分为绑定预取和非绑定预取。</li><li>绑定预取(binding prefetch)<ul><li>预取值直接加载到处理器的寄存器中。</li><li>在发起预取之后，寄存器的值将会被绑定。</li><li>缺点<ul><li>消耗了宝贵的寄存器资源。</li><li>在预取地址错误时，可能会导致程序语义错误。</li></ul></li></ul></li><li>非绑定预取(non-binding prefetch)<ul><li>将预取值放入cache中，或是用于增强cache层次的补充缓冲区(supplemental buffer)。 </li><li>对于多核，预取值所在的cache或是buffer也需要满足cache coherence，因此该部分地址空间的信息可能也会改变。</li><li>目前大部分处理器使用的都是非绑定预取策略。</li></ul></li></ul><h2 id="2-地址预测"><a href="#2-地址预测" class="headerlink" title="2. 地址预测"></a>2. 地址预测</h2><ul><li>如果没有准确的预测到地址，可能导致污染cache（将有效的cacheline内容挤出），以及消耗了额外的通信量和争用资源。</li><li>数据的地址预测<ul><li>主要考虑是对 独立变量还是数据结构元素或是其它数据类型 的访问，以及数据在程序中执行的操作。<ul><li>举例：按顺序读取数组的每一个元素等，这种数据结构和操作方式很好预测。</li><li>举例：对变量交错访问&#x2F;多个数据结构之间的遍历访问等，这种预测较为复杂。</li></ul></li></ul></li><li>指令的地址预测<ul><li>主要考虑程序是 顺序执行 还是 执行分支（一些跳转指令）。</li></ul></li><li>Cache 层级对地址预测的影响<ul><li>在最高层，处理器和L1 Cache的接口 包含了所有可以用来预测内存引用的信息，基于这些信息可以实现高精度的预取。</li><li>在较低的层级中，关于预测内存引用的信息会被过滤。例如高层cache命中后，相关的信息就不会传到低层cache，只能观察到来自高层缺失的信息。</li><li>因此地址预测还与cache块的放置策略和替换策略相关。</li></ul></li></ul><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
